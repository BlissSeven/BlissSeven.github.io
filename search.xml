<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>cpp-review</title>
      <link href="/2019/08/30/cpp-review/"/>
      <url>/2019/08/30/cpp-review/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>network-program</title>
      <link href="/2019/08/28/network-program/"/>
      <url>/2019/08/28/network-program/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="1-epoll"><a href="#1-epoll" class="headerlink" title="1. epoll"></a>1. epoll</h1><ul><li><p>epoll_create</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment">select 中为了存放监视对象文件描述符，声明了一个fd_set变量。epoll类似，由操作系统负责保存监视对象文件描述符，需要向操作系统请求创建保存文件描述符的空间。</span></span></span><br><span class="line"><span class="function"><span class="comment">linux2.6.8之后忽略，内核根据情况调整epoll 一个实例的大小</span></span></span><br><span class="line"><span class="function"><span class="comment">成功时返回epoll实例文件描述符，失败-1</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br></pre></td></tr></table></figure></li><li><p>epoll_ctl</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* epoll中监视对象事件 的结构*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>&#123;</span></span><br><span class="line"><span class="keyword">__uint32_t</span> events;</span><br><span class="line"><span class="keyword">epoll_data_t</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data&#123;</span><br><span class="line">    <span class="keyword">void</span>* ptr;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    __UInt32_t u32;</span><br><span class="line">    <span class="keyword">__uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">events:</span></span><br><span class="line"><span class="comment">EPOLLIN :读取数据</span></span><br><span class="line"><span class="comment">EPOLLOUT:s输出缓冲为空，可以立即发送数据</span></span><br><span class="line"><span class="comment">EPOLLPRI：收到OOB的情况</span></span><br><span class="line"><span class="comment">EPOLLRDHUP:断开连接或者半关闭情况，边缘触发时非常有用</span></span><br><span class="line"><span class="comment">EPOLLERR：发生错误</span></span><br><span class="line"><span class="comment">EPOLLET:边缘触发的方式得到事件通知</span></span><br><span class="line"><span class="comment">EPOLLONESHOT:发生一次事件后，相应文件描述符不在收到事件通知。需要向epoll——ctl函数第二个参数</span></span><br><span class="line"><span class="comment">传递EPOLL_CTL_MOD，再次设置事件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">epfd epoll实例的文件描述符 epoll_create返回值</span></span><br><span class="line"><span class="comment">op 监视对象的操作</span></span><br><span class="line"><span class="comment">fd 监视对象的文件描述符</span></span><br><span class="line"><span class="comment">event 监视对象的事件类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">epoll_ctl(<span class="keyword">int</span> epfd,<span class="keyword">int</span> op,<span class="keyword">int</span> fd,struct epoll_event * event);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">op</span></span><br><span class="line"><span class="comment">EPOLL_CTL_ADD 文件描述符注册到epoll实例</span></span><br><span class="line"><span class="comment">EPOLL_CTL_DEL 从epoll例程中删除文件描述符</span></span><br><span class="line"><span class="comment">EPOLL_CTL_MOD 更改注册的文件描述符的关注事件发生的情况</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>epoll_wait</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回发生事件的文件描述符的个数</span></span><br><span class="line"><span class="comment">epfd epoll文件描述符</span></span><br><span class="line"><span class="comment">events 保存事件发生的文件描述符集合的结构体地址</span></span><br><span class="line"><span class="comment">maxevents 第二个参数中可以保存的最大事件数</span></span><br><span class="line"><span class="comment">timeout 1/1000秒为单位的等待事件，-1永不超时，一直等待直至发生事件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd,struct epoll_evetn* events,<span class="keyword">int</span> maxevents,<span class="keyword">int</span> timeout)</span></span></span><br></pre></td></tr></table></figure></li><li><p>条件触发–默认方式</p><ul><li>只要输入缓冲有数据就会一直通知该事件</li><li>select模型———-条件触发</li></ul></li><li><p>边缘触发</p><ul><li><p>边缘触发输入缓冲收到数据时仅注册1次事件，即使输入缓冲中还有数据，也不会再次进行注册。接受数据时，仅仅注册一次事件。所以一旦发生事件，需要读取输入缓冲中的全部数据。</p></li><li><p>通过以下方式验证输入缓冲是否为空</p><ul><li>read函数返回-1，且全局变量errno=EAGAIN</li></ul></li><li><p>设置文件描述符为非阻塞式</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> filedes,<span class="keyword">int</span> cmd,....)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment">int flag=fcntl(fd,F_GETFL,0);//获取之前的属性</span></span></span><br><span class="line"><span class="function"><span class="comment">fcntl(fd,F_SETFL,flag|O_NONBLOCK);//设置非阻塞</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br></pre></td></tr></table></figure></li><li><p>边缘触发下，以阻塞方式工作的read&amp;write函数有可能引起服务器端的长时间停顿。边缘触发一定采用非阻塞read&amp;write</p></li></ul></li><li><p><strong>可以分离接受数据和处理数据的时间点</strong></p></li></ul></li></ul><h1 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h1><ul><li><p>读panda有感</p><ul><li><a href="https://blog.csdn.net/kwanson/article/details/81160437" target="_blank" rel="noopener">https://blog.csdn.net/kwanson/article/details/81160437</a></li><li><a href="https://github.com/kwansoner/panda.git" target="_blank" rel="noopener">https://github.com/kwansoner/panda.git</a></li></ul></li><li><p>threadpool</p><ul><li><p>线程池的任务队列中存放的是IThreadHandle* ，有threadhandle接口,即线程处理函数</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Queue::CQueue&lt;IThreadHandle *&gt; <span class="keyword">queue_handle_t</span>;<span class="comment">//线程处理函数</span></span><br><span class="line"><span class="keyword">queue_handle_t</span> m_taskqueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">pthread_t</span>&gt; <span class="keyword">vector_tid_t</span>;<span class="comment">//创建的线程ID</span></span><br><span class="line"><span class="keyword">vector_tid_t</span> m_thread;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在CThreadPool构造函数中调用create_threadpool 来产生一定数量的线程，并保存创建好的线程的id,每个线程都相应函数都为process_task。这里利用领导者/跟随者模式从任务队列中取出任务并执行thread_handle。</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">CThreadPool::CThreadPool(<span class="keyword">size_t</span> threadnum, <span class="keyword">size_t</span> tasknum): </span><br><span class="line">m_taskqueue(tasknum), m_hasleader(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">m_threadnum = (threadnum &gt; THREADNUM_MAX)? THREADNUM_MAX: threadnum;</span><br><span class="line">create_threadpool();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> CThreadPool::create_threadpool()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">pthread_attr_t</span> thread_attr;</span><br><span class="line">pthread_attr_init(&amp;thread_attr);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m_threadnum; i++)&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> tid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(pthread_create(&amp;tid, &amp;thread_attr, process_task, (<span class="keyword">void</span> *)<span class="keyword">this</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">errsys(<span class="string">"create thread[%d] filed\n"</span>, (<span class="keyword">int</span>)i);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m_thread.push_back(tid);</span><br><span class="line">&#125;</span><br><span class="line">pthread_attr_destroy(&amp;thread_attr);</span><br><span class="line">trace(<span class="string">"create thread pool, thread number %d\n"</span>, (<span class="keyword">int</span>)m_thread.size());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> *CThreadPool::process_task(<span class="keyword">void</span> * arg)</span><br><span class="line">&#123;</span><br><span class="line">CThreadPool &amp;threadpool = *(CThreadPool *)arg;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">threadpool.promote_leader();</span><br><span class="line">IThreadHandle *threadhandle = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> ret = threadpool.m_taskqueue.pop(threadhandle);</span><br><span class="line">threadpool.join_follwer();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">0</span> &amp;&amp; threadhandle)</span><br><span class="line">threadhandle-&gt;threadhandle();<span class="comment">//IThreadHandle 接口存在threadhandle处理函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>领导者/跟随者</p><ul><li><p>[两种高效的并发模式]: <a href="https://blog.csdn.net/ZYZMZM_/article/details/98055416#LeaderFollowers_41" target="_blank" rel="noopener">https://blog.csdn.net/ZYZMZM_/article/details/98055416#LeaderFollowers_41</a></p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CThreadPool::promote_leader()</span><br><span class="line">&#123;</span><br><span class="line">Pthread::<span class="function">CGuard <span class="title">guard</span><span class="params">(m_identify_mutex)</span></span>;<span class="comment">//m_identify_mutex 加锁，析构时，释放锁</span></span><br><span class="line"><span class="keyword">while</span>(m_hasleader)&#123;<span class="comment">// more than one thread can return</span></span><br><span class="line">m_befollower_cond.wait(m_identify_mutex);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果m_hasleader =true,直接返回，表示当前已存在领导者</span></span><br><span class="line"><span class="comment">否则，m_befollower_cond条件变量释放m_identify_mutex锁，但是阻塞并等待被唤醒，之后在join_follwer中可以获得锁继续执行，设置m_hasleader=false，并唤醒m_befollower_cond，释放锁m_identify_mutex，之后promote_leader中m_befollower_cond.wait(m_identify_mutex);被唤醒并加锁m_identify_mutex，由于m_hasleader为false，跳出循环</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line">m_hasleader = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> CThreadPool::join_follwer()</span><br><span class="line">&#123;</span><br><span class="line">Pthread::<span class="function">CGuard <span class="title">guard</span><span class="params">(m_identify_mutex)</span></span>;</span><br><span class="line">m_hasleader = <span class="literal">false</span>;</span><br><span class="line">m_befollower_cond.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关于pthread_cond_signal即可以放在pthread_mutex_lock和pthread_mutex_unlock之间，也可以放在pthread_mutex_lock和pthread_mutex_unlock之后，但是各有有缺点。</p></li></ul><p>  [再谈互斥锁与条件变量！]: <a href="https://blog.csdn.net/brian12f/article/details/73882166?utm_source=copy" target="_blank" rel="noopener">https://blog.csdn.net/brian12f/article/details/73882166?utm_source=copy</a></p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock</span><br><span class="line">    xxxxxxx</span><br><span class="line">pthread_cond_signal</span><br><span class="line">pthread_mutex_unlock</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">缺点：在某下线程的实现中，会造成等待线程从内核中唤醒（由于cond_signal)然后又回到内核空间（因为cond_wait返回后会有原子加锁的 行为），所以一来一回会有性能的问题。但是在LinuxThreads或者NPTL里面，就不会有这个问题，因为在Linux 线程中，有两个队列，分别是cond_wait队列和mutex_lock队列， cond_signal只是让线程从cond_wait队列移到mutex_lock队列，而不用返回到用户空间，不会有性能的损耗。</span></span><br><span class="line"><span class="comment">所以在Linux中推荐使用这种模式。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">pthread_mutex_lock</span><br><span class="line">    xxxxxxx</span><br><span class="line">pthread_mutex_unlock</span><br><span class="line">pthread_cond_signal</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">优点：不会出现之前说的那个潜在的性能损耗，因为在signal之前就已经释放锁了</span></span><br><span class="line"><span class="comment">缺点：如果unlock和signal之前，有个低优先级的线程正在mutex上等待的话，那么这个低优先级的线程就会抢占高优先级的线程（cond_wait的线程)，而这在上面的放中间的模式下是不会出现的。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>epoll异步框架</p><ul><li><p>在CEvent的构造函数中创建一个eventwait_thread 等待线程。</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(pthread_create(&amp;tid, <span class="literal">NULL</span>, eventwait_thread, (<span class="keyword">void</span> *)<span class="keyword">this</span>) == <span class="number">0</span>)</span><br><span class="line">m_detectionthread = tid;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在eventwait_thread 线程中调用epoll_wait函数，并根据监控结果，将文件描述符，事件类型，封装成任务CEvent *,push到线程池的任务的队列中。CEvent继承至IThreadHandle，有重写的threadhandle的函数</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *CEvent::eventwait_thread(<span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">CEvent &amp;cevent = *(CEvent *)(arg);<span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span>(INVALID_FD(cevent.m_epollfd))&#123;</span><br><span class="line">seterrno(EINVAL);</span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line"><span class="keyword">int</span> nevent = epoll_wait(cevent.m_epollfd, &amp;cevent.m_eventbuff[<span class="number">0</span>], EventBuffLen, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(nevent &lt; <span class="number">0</span> &amp;&amp; errno != EINTR)&#123;</span><br><span class="line">errsys(<span class="string">"epoll wait error\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nevent; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> fd = cevent.m_eventbuff[i].data.fd;</span><br><span class="line">EventType events = <span class="keyword">static_cast</span>&lt;EventType&gt;(cevent.m_eventbuff[i].events);</span><br><span class="line"><span class="keyword">if</span>(cevent.pushtask(fd, events) == <span class="number">0x00</span>)&#123;</span><br><span class="line">cevent.m_ithreadpool-&gt;pushtask(&amp;cevent);<span class="comment">//将CEvent* 对象push到任务队列中，有重写thread_handle函数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> CEvent::threadhandle()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> fd = <span class="number">0x00</span>;</span><br><span class="line">EventType events;</span><br><span class="line"><span class="keyword">if</span>(poptask(fd, events) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">CNetObserver *observer = get_observer(fd);</span><br><span class="line"><span class="keyword">if</span>(observer == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 关闭时递减引用计数。在对象的所有回调处理完时真正释放</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span>(events &amp; ECLOSE)&#123;</span><br><span class="line">cleartask(fd);</span><br><span class="line">observer-&gt;subref();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(events &amp; EERR)&#123;</span><br><span class="line">observer-&gt;handle_error(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(events &amp; EIN)&#123;</span><br><span class="line">observer-&gt;handle_in(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(events &amp; EOUT)&#123;</span><br><span class="line">observer-&gt;handle_out(fd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* unregister_event 执行后于handle_close将会出现当前套接字关闭后</span></span><br><span class="line"><span class="comment">* 在仍未执行完unregister_event时新的连接过来，得到一样的描述符</span></span><br><span class="line"><span class="comment">* 新的连接调用register_event却未注册进入epoll。同时han_close中</span></span><br><span class="line"><span class="comment">* 关闭了套接字，unregister_event中epoll删除关闭的套接字报错</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span>(observer-&gt;subref_and_test())&#123;</span><br><span class="line">unregister_event(fd);</span><br><span class="line">observer-&gt;handle_close(fd);</span><br><span class="line">observer-&gt;selfrelease();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>CEvent中threadhandle，调用的是和每个fd所绑定的CNetObserver*的处理函数</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, CNetObserver *&gt; EventMap_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, EventType&gt; EventTask_t;</span><br><span class="line">EventMap_t m_eventreg;</span><br><span class="line">EventTask_t m_events;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>CNetObserver 继承至INetObserver，一方面负责fd的事件处理函数，另一方面负责相应的fd和事件处理函数的同步，为了确保CNetObserver * 的正确销毁时机，用了引用计数功能。</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> CEvent::record(<span class="keyword">int</span> fd, EventType type, IEventHandle *handle)</span><br><span class="line">&#123;</span><br><span class="line">CNetObserver *newobserver = <span class="keyword">new</span> CNetObserver(*handle, type);</span><br><span class="line">assert(newobserver != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">Pthread::<span class="function">CGuard <span class="title">guard</span><span class="params">(m_eventreg_mutex)</span></span>;</span><br><span class="line">m_eventreg[fd] = newobserver;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNetObserver</span>:</span> <span class="keyword">public</span> INetObserver</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">CEvent</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CNetObserver(INetObserver &amp;, EventType);</span><br><span class="line">~CNetObserver();</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addref</span><span class="params">()</span></span>;<span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">subref</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">subref_and_test</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">selfrelease</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> EventType <span class="title">get_regevent</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> INetObserver *<span class="title">get_handle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>: <span class="comment">//负责fd的事件处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_in</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_out</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_close</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_error</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">EventType m_regevent;</span><br><span class="line">INetObserver &amp;m_obj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int32_t</span> m_refcount;</span><br><span class="line">Pthread::CMutex m_refcount_mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>在CEvent中负责事件的处理函数，负责向线程池的任务队列Push_task，一个单例的CEventProxy 进一步封装CEvent</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CEventProxy</span>:</span> <span class="keyword">public</span> IEvent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> CEventProxy *<span class="title">instance</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_event</span><span class="params">(<span class="keyword">int</span>, IEventHandle *,EventType)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_event</span><span class="params">(Socket::ISocket &amp;, IEventHandle *,EventType)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown_event</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown_event</span><span class="params">(Socket::ISocket &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">CEventProxy(<span class="keyword">size_t</span> neventmax);</span><br><span class="line">~CEventProxy();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">IEvent *m_event;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>为了确保在INetObserver中可以注册事件，关闭事件，在IEventHandle相应接口中调用CEventProxy中的CEvent实现相应接口</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IEventHandle</span>:</span> <span class="keyword">public</span> INetObserver</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// desc: 注册进入事件中心</span></span><br><span class="line"><span class="comment">// param: fd/套接字描述符 type/事件类型</span></span><br><span class="line"><span class="comment">// return: 0/成功 -1/失败</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_event</span><span class="params">(<span class="keyword">int</span> fd, EventType type = EDEFULT)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// desc: 注册进入事件中心</span></span><br><span class="line"><span class="comment">// param: socket/套接字对象 type/事件类型</span></span><br><span class="line"><span class="comment">// return: 0/成功 -1/失败</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_event</span><span class="params">(Socket::ISocket &amp;socket, EventType type = EDEFULT)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// desc: 关闭事件</span></span><br><span class="line"><span class="comment">// param: fd/套接字描述符</span></span><br><span class="line"><span class="comment">// return: 0/成功 -1/失败</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown_event</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// desc: 关闭事件</span></span><br><span class="line"><span class="comment">// param: socket/套接字对象</span></span><br><span class="line"><span class="comment">// return: 0/成功 -1/失败</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown_event</span><span class="params">(Socket::ISocket &amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> IEventHandle::register_event(<span class="keyword">int</span> fd, EventType type)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> CEventProxy::instance()-&gt;register_event(fd, <span class="keyword">this</span>, type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>HTTP</p><p>* </p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> TCP-IP </tag>
            
            <tag> linux </tag>
            
            <tag> network-program </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp11-singleton</title>
      <link href="/2019/08/27/cpp11-singleton/"/>
      <url>/2019/08/27/cpp11-singleton/</url>
      
        <content type="html"><![CDATA[<ul><li>c++11 下的单例模式</li><li><a href="https://blog.csdn.net/q_l_s/article/details/52369065" target="_blank" rel="noopener">https://blog.csdn.net/q_l_s/article/details/52369065</a></li><li><a href="https://blog.csdn.net/Hackbuteer1/article/details/7460019" target="_blank" rel="noopener">https://blog.csdn.net/Hackbuteer1/article/details/7460019</a></li><li><a href="https://blog.csdn.net/janeqi1987/article/details/74295920" target="_blank" rel="noopener">https://blog.csdn.net/janeqi1987/article/details/74295920</a></li><li><a href="https://blog.csdn.net/qiuchenl/article/details/8658567" target="_blank" rel="noopener">https://blog.csdn.net/qiuchenl/article/details/8658567</a></li></ul><a id="more"></a><ul><li><p>懒汉式</p><ul><li><p>用的时候才初始化</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">CSingleton</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line"><span class="function"><span class="keyword">static</span> CSingleton* <span class="title">GetInstance</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">     <span class="keyword">if</span> ( m_pInstance == <span class="literal">NULL</span> ) <span class="comment">//非线程安全   </span></span><br><span class="line">         m_pInstance = <span class="keyword">new</span> CSingleton();  </span><br><span class="line">     <span class="keyword">return</span> m_pInstance;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    CSingleton()&#123;&#125;;  </span><br><span class="line">    <span class="keyword">static</span> CSingleton * m_pInstance;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>懒汉式，内存泄漏的改进</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">CSingleton</span>    </span></span><br><span class="line"><span class="class">    &#123;</span>    </span><br><span class="line">    <span class="keyword">private</span>:    </span><br><span class="line">        CSingleton()    </span><br><span class="line">        &#123;    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">static</span> CSingleton *m_pInstance;    </span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">CGarbo</span>     </span></span><br><span class="line"><span class="class">        &#123;</span>    </span><br><span class="line">        <span class="keyword">public</span>:    </span><br><span class="line">            ~CGarbo()    </span><br><span class="line">            &#123;    </span><br><span class="line">                <span class="keyword">if</span>(CSingleton::m_pInstance)    </span><br><span class="line">                    <span class="keyword">delete</span> CSingleton::m_pInstance;    </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;;    </span><br><span class="line">        <span class="keyword">static</span> CGarbo Garbo;<span class="comment">//定义一个静态成员变量，程序结束时，系统会自动调用它的析构函数   </span></span><br><span class="line">    <span class="keyword">public</span>:    </span><br><span class="line">        <span class="function"><span class="keyword">static</span> CSingleton * <span class="title">GetInstance</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function">        </span>&#123;    </span><br><span class="line">            <span class="keyword">if</span>(m_pInstance == <span class="literal">NULL</span>)    </span><br><span class="line">                m_pInstance = <span class="keyword">new</span> CSingleton();    </span><br><span class="line">            <span class="keyword">return</span> m_pInstance;    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;;   </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.在单例类内部定义专有的嵌套类。</span></span><br><span class="line"><span class="comment">2.在单例类内定义私有的专门用于释放的静态成员。</span></span><br><span class="line"><span class="comment">3.利用程序在结束时析构全局变量的特性，选择最终的释放时机。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>懒汉式，线程安全的改进，加锁</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class CSingleton</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    CSingleton() //构造函数是私有的</span><br><span class="line">    &#123;</span><br><span class="line">   &#125;</span><br><span class="line">    static CSingleton *m_pInstance;</span><br><span class="line">    mutex mtx;</span><br><span class="line">public:</span><br><span class="line">    static CSingleton * GetInstance()</span><br><span class="line">    &#123;</span><br><span class="line">        mtx.lock();//加锁</span><br><span class="line">        if (m_pInstance == NULL) //判断是否第一次调用</span><br><span class="line">            m_pInstance = new CSingleton();</span><br><span class="line">        mtx.unlock();//释放锁</span><br><span class="line">        return m_pInstance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>饿汉式</p><ul><li><p>饿汉式线程安全</p></li><li></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">CSingleton</span>    </span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">    CSingleton()      </span><br><span class="line">    &#123;    </span><br><span class="line">    &#125;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> CSingleton * <span class="title">GetInstance</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function">    </span>&#123;    </span><br><span class="line">        <span class="keyword">static</span> CSingleton instance;     </span><br><span class="line">        <span class="keyword">return</span> &amp;instance;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>关于单例模式中的拷贝构造函数</p><ul><li><p>尽量加，否则可以调用编译器的默认拷贝构造生成另一个对象</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">B() &#123;&#125;</span><br><span class="line"><span class="comment">//B(const B&amp;) &#123;&#125;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> B&amp; <span class="title">get_instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> B b;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"B::func"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">B::get_instance().func();</span><br><span class="line">B b1 = B::get_instance();</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;b1 %p\n"</span>,&amp;b1);</span><br><span class="line"><span class="function">B <span class="title">b2</span><span class="params">(b1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;b2 %p\n"</span>, &amp;b2);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">B::func</span></span><br><span class="line"><span class="comment">&amp;b1 0000007E4ABCFB04</span></span><br><span class="line"><span class="comment">&amp;b2 0000007E4ABCFB24</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> singleton </tag>
            
            <tag> cpp11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>object-model3</title>
      <link href="/2019/08/22/object-model3/"/>
      <url>/2019/08/22/object-model3/</url>
      
        <content type="html"><![CDATA[<ul><li>C++对象模型系列之3</li></ul><a id="more"></a><h2 id="39-继承体系下的对象构造"><a href="#39-继承体系下的对象构造" class="headerlink" title="39 继承体系下的对象构造"></a>39 继承体系下的对象构造</h2><ul><li><p>对象的构造顺序</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  A()</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"A this= %p \n"</span>, <span class="keyword">this</span>);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"A::A()"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~A()</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"A::~A()"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  B()</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"B this= %p \n"</span>, <span class="keyword">this</span>);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"B::B()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~B()</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"B::~B()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span><span class="keyword">public</span> B &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NUMS= <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">int</span> scores[NUMS];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">enum</span> &#123;NUMS2=<span class="number">10</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> scores2[NUMS2];</span><br><span class="line">  </span><br><span class="line">  C() &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"C this= %p \n"</span>,<span class="keyword">this</span>);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"C::C()"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~C()</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"C::~C()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  C cobj;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A this= 0073F6A0</span></span><br><span class="line"><span class="comment">A::A()</span></span><br><span class="line"><span class="comment">B this= 0073F6A0</span></span><br><span class="line"><span class="comment">B::B()</span></span><br><span class="line"><span class="comment">C this= 0073F6A0</span></span><br><span class="line"><span class="comment">C::C()</span></span><br><span class="line"><span class="comment">C::~C()</span></span><br><span class="line"><span class="comment">B::~B()</span></span><br><span class="line"><span class="comment">A::~A()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>先构造内部父类，在构造外部子类，</p></li><li><p>先析构外部子类，再析构内部父类</p></li><li><p>初始化列表在父类构造完毕后，再执行</p></li></ul></li><li><p>虚函数的特性</p><ul><li><p>A B C 三者首地址相同</p></li><li><p>在A的构造函数中，给C的虚函数表指针赋值A的虚函数表地址</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00401F</span>03  mov         eax,dword ptr [<span class="keyword">this</span>]  </span><br><span class="line"><span class="number">00401F</span>06  mov         dword ptr [eax],offset ns1::A::`vftable' (<span class="number">0409B</span>34h)  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"A this= %p \n"</span>, <span class="keyword">this</span>);</span><br><span class="line"><span class="number">00401F</span>0C  mov         eax,dword ptr [<span class="keyword">this</span>]  </span><br><span class="line"><span class="number">00401F</span>0F  push        eax  </span><br><span class="line"><span class="number">00401F</span>10  push        offset <span class="built_in">string</span> <span class="string">"A this= %p \n"</span> (<span class="number">0409</span>C40h)  </span><br><span class="line"><span class="number">00401F</span>15  call        _printf (<span class="number">0401447</span>h)  </span><br><span class="line"><span class="number">00401F</span>1A  add         esp,<span class="number">8</span>  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A this= 00D6F9F4</span></span><br><span class="line"><span class="comment">0x00D6F9F4  34 9b 40 00// A 首地址 四个字节 为A::vftable 表首地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="number">00401F</span>B2  mov         ecx,dword ptr [<span class="keyword">this</span>]  </span><br><span class="line"><span class="number">00401F</span>B5  call        ns1::A::A (<span class="number">04013</span>EDh)  </span><br><span class="line"><span class="number">00401F</span>BA  mov         dword ptr [ebp<span class="number">-4</span>],<span class="number">0</span>  </span><br><span class="line"><span class="number">00401F</span>C1  mov         eax,dword ptr [<span class="keyword">this</span>]  </span><br><span class="line"><span class="number">00401F</span>C4  mov         dword ptr [eax],offset ns1::B::`vftable' (<span class="number">0409B</span>60h)  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"B this= %p \n"</span>, <span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//B中构造函数 继续讲 B：：vftable 赋值 B的头四个字节</span></span><br><span class="line"><span class="comment">//0x00D6F9F4  60 9b 40 00</span></span><br><span class="line"></span><br><span class="line"><span class="number">004020</span>A4  mov         dword ptr [eax],offset ns1::C::`vftable' (<span class="number">0409B</span>88h)  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"C this= %p \n"</span>,<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//C中构造函数 继续将 C：：vftable 赋值 C的头四个字节</span></span><br><span class="line"><span class="comment">//0x00D6F9F4  88 9b 40 00</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>构造函数对虚函数的调用</p><ul><li><p>某类构造函数调用虚函数，不走虚函数表，直接通过虚函数表静态调用，当前类有则C，否则依次往上找B，找A</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">C() &#123;</span><br><span class="line">myvirfunc();<span class="comment">//执行时，C还没构造出来 直接调用C虚函数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"C this= %p \n"</span>,<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"C::C()"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~C()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"C::~C()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">myvirfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">myvirfunc2();<span class="comment">//在一个虚函数中调虚函数，第二个间接调虚函数走虚函数表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">myvirfunc2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">myvirfunc();//执行时，C还没构造出来 直接调用C虚函数</span></span><br><span class="line"><span class="comment">00FF223A  mov         ecx,dword ptr [this]  </span></span><br><span class="line"><span class="comment">00FF223D  call        ns1::C::myvirfunc (0FF128Ah)  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">myvirfunc2()</span></span><br><span class="line"><span class="comment">00FD2F33  mov         eax,dword ptr [this]  </span></span><br><span class="line"><span class="comment">00FD2F36  mov         edx,dword ptr [eax]  </span></span><br><span class="line"><span class="comment">00FD2F38  mov         esi,esp  </span></span><br><span class="line"><span class="comment">00FD2F3A  mov         ecx,dword ptr [this]  </span></span><br><span class="line"><span class="comment">00FD2F3D  mov         eax,dword ptr [edx+8]  </span></span><br><span class="line"><span class="comment">00FD2F40  call        eax  </span></span><br><span class="line"><span class="comment">00FD2F42  cmp         esi,esp  </span></span><br><span class="line"><span class="comment">00FD2F44  call        __RTC_CheckEsp (0FD11C7h)  </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="40-对象复制、析构函数语义学"><a href="#40-对象复制、析构函数语义学" class="headerlink" title="40 对象复制、析构函数语义学"></a>40 对象复制、析构函数语义学</h2><ul><li><p>对象的默认复制</p><ul><li>如果不写自己的拷贝构造，拷贝赋值，编译器也会有默认的对象拷贝，对象赋值（值拷贝！！！）</li></ul></li><li><p>拷贝赋值运算符、拷贝构造函数</p><ul><li>当定义 任何一个构造函数后，编译器就不提供缺省构造函数</li></ul></li><li><p>禁止对象的拷贝构造和赋值</p><ul><li>拷贝构造和拷贝赋值 private，只声明不定义</li></ul></li><li><p>析构函数语义</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dumpbin /all main.obj &gt; main.txt</span><br></pre></td></tr></table></figure></li><li><p>析构函数合成</p><ul><li><p>如果继承一个基类，并且基类中带析构函数，编译器就合成默认析构函数</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~AA()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"AA::~AA()"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span><span class="keyword">public</span> AA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> COMDAT; sym= "public: virtual __thiscall ns2::A::~A(void)" (??1A@ns2@@UAE@XZ)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>如果类成员变量为类类型成员，该类成员变量有析构函数</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~AA()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"AA::~AA()"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span><span class="keyword">public</span> AA&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">60501020 flags</span></span><br><span class="line"><span class="comment">         Code</span></span><br><span class="line"><span class="comment">         COMDAT; sym= "public: virtual __thiscall ns2::A::~A(void)" (??1A@ns2@@UAE@XZ)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>析构函数扩展—-当有自己的析构函数时，编译器扩展</p><ul><li>如果类成员为类类型成员，且带析构函数。先执行外部A的析构函数，再执行内部AA的析构函数</li><li>基类带析构函数，子类的析构函数被扩展以调用基类的析构函数</li></ul></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> object-model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>muduo_note</title>
      <link href="/2019/08/21/muduo-note/"/>
      <url>/2019/08/21/muduo-note/</url>
      
        <content type="html"><![CDATA[<ul><li>muduo 源代码</li></ul><a id="more"></a><h2 id="1-双缓冲异步日志"><a href="#1-双缓冲异步日志" class="headerlink" title="1 双缓冲异步日志"></a>1 双缓冲异步日志</h2><ul><li>一个背景线程负责收集消息，其余线程往这个日志线程发送日志消息。分为前端和后端。<ul><li>前端有AB两个缓冲，一个作为当前缓冲，一个作为预备缓冲，后端有CD缓冲<br>首先加锁保护后续读写。判断当前缓冲是否满，消息入缓冲。满，缓冲入传送队列。将判断预备缓冲是否存在，预备缓冲作为当前缓冲，否则新建缓冲E<br>通知条件变量。</li><li>后端<br>加锁，判断条件变量并设置超时时间。当前缓冲入队列。当前缓冲设置为C缓冲区。传送队列清空到待写队列。B缓冲设置为D缓冲，待写队列写入到磁盘<br>C D缓冲设置为待写队列中的最后两个</li></ul></li></ul><h2 id="2-类的关系UML图"><a href="#2-类的关系UML图" class="headerlink" title="2  类的关系UML图"></a>2  类的关系UML图</h2><ul><li>复合关系<ul><li>has a</li><li><img src="muduo-note/1566383725642.png" alt="1566383725642"></li><li><img src="muduo-note/1566383830105.png" alt="1566383830105"></li></ul></li><li>委托关系<ul><li><img src="muduo-note/1566383953338.png" alt="1566383953338"></li></ul></li><li>继承<ul><li><img src="muduo-note/1566384037058.png" alt="1566384037058"></li><li><img src="muduo-note/1566384081389.png" alt="1566384081389"></li></ul></li></ul><h2 id="3-muduo-UML-类图"><a href="#3-muduo-UML-类图" class="headerlink" title="3 muduo UML 类图"></a>3 muduo UML 类图</h2><ul><li></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> muduo </tag>
            
            <tag> 多线程服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS</title>
      <link href="/2019/08/14/OS/"/>
      <url>/2019/08/14/OS/</url>
      
        <content type="html"><![CDATA[<ul><li>操作系统补全计划</li></ul><a id="more"></a><h1 id="1-多进程图像引出"><a href="#1-多进程图像引出" class="headerlink" title="1.多进程图像引出"></a>1.多进程图像引出</h1><h2 id="1-1-CPU管理"><a href="#1-1-CPU管理" class="headerlink" title="1.1 CPU管理"></a>1.1 CPU管理</h2><ul><li><p>CPU执行方式 取指执行</p></li><li><p><strong>CPU工作，只需要设定PC初值，CPU之后会依次取指执行</strong></p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *fp,sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000000000000</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    sum=sum+i;</span><br><span class="line">    <span class="comment">//fpritf(fp,"%d",sum);//IO指令特别慢</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>IO指令时，不加fprintf0.015,加fprintf0.859</p></li><li><p>在等待IO时，切换任务</p></li><li><p>多个程序在内存中–多道程序，交替执行</p></li><li><p>适当时候PC进行切换</p><ul><li>修改PC寄存器</li><li>记录信息，每个程序有一个存放信息的结构PCB</li></ul></li><li><p>运行的程序（进行中的程序–进程）VS静态的程序</p><ul><li>进程为进行中的程序</li></ul><hr><p>为了使用CPU，需要设置PC的初值，效率低，多道程序交替执行，切换时，需要记录一些信息，进程</p><p>启动一个进程，CPU就可以工作，启动多个进程，CPU高效运行</p><h2 id="1-2多进程图像"><a href="#1-2多进程图像" class="headerlink" title="1.2多进程图像"></a>1.2多进程图像</h2></li><li><p>启动了的程序就是进程，多个进程推进</p><ul><li>操作系统将这些进程记录号，按照合理的次序</li><li>main中fork()创建了第一个进程，<ul><li>init中执行了shell（桌面）</li><li>shell 再启动其他进程</li></ul></li><li><img src="OS/1565866335701.png" alt="1565866335701"></li><li><img src="OS/1565866370830.png" alt="1565866370830"></li></ul></li><li><p>多进程如何组织</p><ul><li>PCB process control block记录进程信息的数据块</li><li>操作系统感知 操作进程全靠PCB</li><li>基于PCB的一些数据结构</li><li><img src="OS/1565866777674.png" alt="1565866777674"></li><li>把进程根据状态区分开<ul><li><strong>PCB+状态+队列</strong></li><li><img src="OS/1565866925029.png" alt="1565866925029"></li></ul></li></ul></li><li><p>多进程如何交替</p><ul><li>pCur   pNew 均为PCB</li><li>getNext 调度算法</li><li>switch 切换算法</li><li><img src="OS/1565867058012.png" alt="1565867058012"></li><li>交替三个部分 队列操作+调度+切换<ul><li>调度<ul><li>FIFO</li><li>Priority</li></ul></li><li>切换 精细控制 汇编<ul><li><img src="OS/1565867555149.png" alt="1565867555149"></li></ul></li></ul></li><li>多进程相互影响<ul><li><img src="OS/1565867856939.png" alt="1565867856939"></li><li>每个进程有一个映射表<ul><li>多进程在内存中共存</li><li><img src="OS/1565867914593.png" alt="1565867914593"></li></ul></li><li>多进程合作<ul><li><img src="OS/1565868011092.png" alt="1565868011092"></li><li><img src="OS/1565868109153.png" alt="1565868109153"></li><li>counter ++ –非原子操作</li><li>进程同步，合理的推进顺序</li><li><img src="OS/1565868363151.png" alt="1565868363151"></li></ul></li></ul></li></ul></li><li><p>读写PCB，</p></li><li><p>操作寄存器完成切换</p></li><li><p>调度程序</p></li><li><p>进程同步与合作</p></li><li><p>地址映射</p></li></ul><h1 id="2-线程的引出和实现"><a href="#2-线程的引出和实现" class="headerlink" title="2 线程的引出和实现"></a>2 线程的引出和实现</h1><p>进程切换</p><h2 id="2-1用户级线程"><a href="#2-1用户级线程" class="headerlink" title="2.1用户级线程"></a>2.1用户级线程</h2><ul><li><p>一个进程就是执行一堆指令</p></li><li><p><img src="OS/1565958543201.png" alt="1565958543201"></p></li><li><p>只切指令不切映射表（内存），速度快</p></li><li><p><img src="OS/1565958580926.png" alt="1565958580926"></p></li><li><p><strong>线程保留了并发的特点，又避免了进程切换的代价</strong></p></li><li><p><strong>线程切换实质就是映射表不变，PC指针变</strong></p></li><li><p><img src="OS/1565959094794.png" alt="1565959094794"></p></li><li><p><img src="OS/1565959345501.png" alt="1565959345501"></p></li><li><p><img src="OS/1565959558732.png" alt="1565959558732"></p></li><li><p><img src="OS/1565959803214.png" alt="1565959803214"></p><ul><li>B执行完之后404出栈，跳转到D执行出错，一个栈不够用</li></ul></li><li><p><img src="OS/1565960709561.png" alt="1565960709561"></p><ul><li>TCB thread control block</li><li>TCB和栈</li><li>不需要jmp 204，yield下一句为204；</li><li><strong>yield只需要切换栈即可</strong></li></ul></li><li><p><img src="OS/1565960955892.png" alt="1565960955892"></p><ul><li>把起始地址放在栈中，把tcb和栈进行关联</li></ul></li><li><p><img src="OS/1565961151494.png" alt="1565961151494"></p></li><li><p>用户级线程在用户态切来切去，操作系统感知不到</p><ul><li><img src="OS/1565961336997.png" alt="1565961336997"></li><li>在内核中阻塞时，操作系统感知不到用户线程，切换不到show线程</li></ul></li><li><p><img src="OS/1565961472640.png" alt="1565961472640"></p><ul><li>内核级线程并发性好</li></ul></li></ul><h2 id="2-2-内核级线程"><a href="#2-2-内核级线程" class="headerlink" title="2.2 内核级线程"></a>2.2 内核级线程</h2><p>用户级线程切换的核心就<strong>是一个栈变为两个栈，每个线程有自己的栈和TCB</strong>，在切换的时候，首先切换TCB，再切换栈。创建的时候将要切换的PC指针放到自己的栈中，再创建好TCB,将来切换的时候，首先通过TCB切换到相应的栈，从栈中弹出PC执行</p><ul><li><strong>没有用户级进程，进程必须在内核中，进程需要分配资源，必要到内核态才能访问这些资源</strong>，切换进程真正是切换内核级线程</li><li>多核处理器 –核心级线程</li><li>MMU 内存映射，多核用的一个MMU,一个映射，多线程在核里，才能充分应用CPU</li><li>核是由操作系统控制，操作系统看不到用户级线程，不能分配核</li><li><strong>多进程，用户级线程都不能充分发挥多核价值</strong></li><li><img src="OS/1566037574800.png" alt="1566037574800"></li><li>核心级线程需要进入内核态，在用户态执行的时候用户栈，在内核态跑用内核栈</li><li>一个TCB关联两套栈，根据TCB切换两套栈，用户栈和内核栈都要切</li><li><img src="OS/1566037947219.png" alt="1566037947219"></li><li>进入内核的唯一方法就是中断</li><li><img src="OS/1566038414169.png" alt="1566038414169"></li><li><img src="OS/1566038572573.png" alt="1566038572573"></li><li>cur next 为TCB</li><li><img src="OS/1566038726005.png" alt="1566038726005"></li><li>中断进入内核，找到TCB,完成TCB切换，并根据TCB切换内核栈，IRET，切换到用户栈</li><li><img src="OS/1566039074863.png" alt="1566039074863"></li><li><img src="OS/1566039402092.png" alt="1566039402092"></li><li><img src="OS/1566039614637.png" alt="1566039614637"></li><li><img src="OS/1566039789986.png" alt="1566039789986"></li></ul><h2 id="2-3-内核级线程的实现"><a href="#2-3-内核级线程的实现" class="headerlink" title="2.3 内核级线程的实现"></a>2.3 内核级线程的实现</h2><ul><li><img src="OS/1566115924486.png" alt="1566115924486"></li><li>每取一条指令PC自动+1</li><li><img src="OS/1566116698043.png" alt="1566116698043"></li><li>state 非零 意味着阻塞</li><li><img src="OS/1566117197837.png" alt="1566117197837"></li><li><img src="OS/1566117305134.png" alt="1566117305134"></li><li><img src="OS/1566117749363.png" alt="1566117749363"></li><li></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++对象模型探索-2</title>
      <link href="/2019/08/01/object-model2/"/>
      <url>/2019/08/01/object-model2/</url>
      
        <content type="html"><![CDATA[<ul><li>C++对象模型探索2</li><li>补充C++对象模型探索1</li></ul><p>​    <a id="more"></a></p><h2 id="25-两层结构时虚基类表内容分析"><a href="#25-两层结构时虚基类表内容分析" class="headerlink" title="25 两层结构时虚基类表内容分析"></a>25 两层结构时虚基类表内容分析</h2><ul><li><img src="object-model2/1564645591473.png" alt="1564645591473"></li></ul><ul><li><p>虚基类表内容之5-8字节内容分析</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grand</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_grand;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span> :</span><span class="keyword">public</span> <span class="keyword">virtual</span> Grand &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_a1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> :</span><span class="keyword">public</span> <span class="keyword">virtual</span> Grand &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_a2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span> :</span><span class="keyword">public</span> A1, <span class="keyword">public</span> A2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_c1;</span><br><span class="line">&#125;;</span><br><span class="line">A1 a1;<span class="comment">//+&amp;a10x0095fb5c &#123;m_a1=-858993460 &#125;A1 *</span></span><br><span class="line"></span><br><span class="line">a1.m_grand = <span class="number">2</span>;</span><br><span class="line">a1.m_a1 = <span class="number">3</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sizeof(Grand) 4</span></span><br><span class="line"><span class="comment">sizeof(A1) 12</span></span><br><span class="line"><span class="comment">sizeof(A2) 12</span></span><br><span class="line"><span class="comment">sizeof(C1) 24</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">A1 前四个字节为vbptr &amp;a1=0x0095fb5c</span></span><br><span class="line"><span class="comment"> 0x0095FB5C 30 8b 98 00 cc cc cc cc 02 00 00 00</span></span><br><span class="line"><span class="comment"> 虚函数表地址为0x00988b30</span></span><br><span class="line"><span class="comment"> 0x00988B30  00 00 00 00 08 00 00 00</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">a1.m_grand = 2;</span></span><br><span class="line"><span class="comment">009825C2  mov         eax,dword ptr [a1]  //把a1 地址赋值给EAX</span></span><br><span class="line"><span class="comment">009825C5  mov         ecx,dword ptr [eax+4]  把虚基类表中后4个字节=8 赋值给ECX</span></span><br><span class="line"><span class="comment">009825C8  mov         dword ptr a1[ecx],2  2赋值给 a1+8</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>一般虚基类表8字节，四个字节为一个单位，每多一个虚基类Grand，虚基类表多加4个字节</p></li><li><p>虚基类，编译器为A1 A2提供默认构造函数，增加代码，给vbptr赋值</p></li><li><p>虚基类表指针即为成员变量的首地址+这个偏移量=虚基类对象首地址。跳过这个偏移量，访问虚基类对象</p></li><li><p><strong>虚基类表中5-8字节存储的是A1访问虚基类对象Grand的成员变量的偏移量</strong></p></li><li><p>虚基类表编译时生成，多次运行相同，虚基类表指针相同</p></li></ul></li><li><p>各种形色继承</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grand</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_grand;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grand2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_grand2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span> :</span><span class="keyword">public</span> <span class="keyword">virtual</span> Grand , <span class="keyword">public</span> Grand2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_a1;</span><br><span class="line">&#125;;</span><br><span class="line">A1 a1;</span><br><span class="line">a1.m_grand = <span class="number">2</span>;<span class="comment">//13-16</span></span><br><span class="line">a1.m_a1 = <span class="number">3</span>;<span class="comment">//9-12</span></span><br><span class="line">a1.m_grand2 = <span class="number">4</span>;<span class="comment">//1-4</span></span><br><span class="line"><span class="comment">//虚基类表指针5-8 </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sizeof(Grand) 4</span></span><br><span class="line"><span class="comment">sizeof(A1) 16</span></span><br><span class="line"><span class="comment">sizeof(A2) 12</span></span><br><span class="line"><span class="comment">0x00BCFCB0  04 00 00 00 30 8b e8 00 03 00 00 00 02 00 00 00</span></span><br><span class="line"><span class="comment">0x00E88B30  fc ff ff ff 08 00 00 00 //虚函数表前四个字节为-4，后四个字节为8</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><img src="object-model2/1564647268839.png" alt="1564647268839"></p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grand</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_grand;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grand2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_grand2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span> :</span><span class="keyword">public</span>  Grand ,<span class="keyword">virtual</span> <span class="keyword">public</span> Grand2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_a1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A1 a1;</span><br><span class="line">a1.m_grand = <span class="number">2</span>;<span class="comment">//1-4</span></span><br><span class="line">a1.m_a1 = <span class="number">3</span>;<span class="comment">//9-12</span></span><br><span class="line">a1.m_grand2 = <span class="number">4</span>;<span class="comment">//13-16</span></span><br><span class="line"><span class="comment">//虚基类表指针5-8 </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0x012FFD58  02 00 00 00 30 8b d7 00 03 00 00 00 04 00 00 00 </span></span><br><span class="line"><span class="comment">0x00D78B30  fc ff ff ff 08 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><img src="object-model2/1564647899087.png" alt="1564647899087"></p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grand</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_grand;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grand2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_grand2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span> :</span><span class="keyword">virtual</span> <span class="keyword">public</span>  Grand ,<span class="keyword">virtual</span> <span class="keyword">public</span> Grand2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_a1;</span><br><span class="line">&#125;;</span><br><span class="line">A1 a1;</span><br><span class="line"></span><br><span class="line">a1.m_grand = <span class="number">2</span>;</span><br><span class="line">a1.m_a1 = <span class="number">3</span>;</span><br><span class="line">a1.m_grand2 = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//0x0098F8D8  30 8b 87 00 03 00 00 00 02 00 00 00 04 00 00 00</span></span><br><span class="line"><span class="comment">//虚基类表</span></span><br><span class="line"><span class="comment">//0x00878B30  00 00 00 00 08 00 00 00 0c 00 00 00 //8 为 m_grand偏移量 m_grand2=12 为m_grand2偏移量，相对于虚基类表头部的偏移量</span></span><br></pre></td></tr></table></figure></li><li><p><img src="object-model2/1564648316374.png" alt="1564648316374"></p></li><li><p><strong>实继承的 成员会在最上面，虚继承的在最下面，两个都虚继承的话，只有一个虚基类表指针（同虚函数不同），按照继承顺序，先继承的倒数第二，后继承的倒数第一</strong></p></li><li><p>虚基类表3项 +4 +8，通过取得虚基类表中偏移值来赋值</p></li><li><p>虚基类表中偏移量，按照继承顺序存放</p></li><li><p><strong>虚基类子对象一直放在最下面，按照继承顺序</strong></p></li><li><p>实继承成员+虚继承的虚基类表指针+本身的成员+虚基类的成员</p></li></ul><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grand</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_grand;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grand2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_grand2;</span><br><span class="line"><span class="keyword">int</span> m_grand2_1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span> :</span><span class="keyword">virtual</span> <span class="keyword">public</span>  Grand ,<span class="keyword">virtual</span> <span class="keyword">public</span> Grand2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_a1;</span><br><span class="line">&#125;;</span><br><span class="line">A1 a1;</span><br><span class="line"></span><br><span class="line">a1.m_grand = <span class="number">2</span>;</span><br><span class="line">a1.m_a1 = <span class="number">3</span>;</span><br><span class="line">a1.m_grand2 = <span class="number">4</span>;</span><br><span class="line">a1.m_grand2_1 = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a1.m_grand2 = 4;</span></span><br><span class="line"><span class="comment">009B259E  mov         ecx,dword ptr [eax+8]  </span></span><br><span class="line"><span class="comment">009B25A1  mov         dword ptr a1[ecx],4  </span></span><br><span class="line"><span class="comment">a1.m_grand2_1 = 5;</span></span><br><span class="line"><span class="comment">009B25A9  mov         eax,dword ptr [a1]  </span></span><br><span class="line"><span class="comment">009B25AC  mov         ecx,dword ptr [eax+8]  </span></span><br><span class="line"><span class="comment">009B25AF  mov         dword ptr [ebp+ecx-18h],5  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">0x00CFF9E0  30 8b 9b 00 03 00 00 00 02 00 00 00 04 00 00 00 05 00 00 00 </span></span><br><span class="line"><span class="comment">0x009B8B30  00 00 00 00 08 00 00 00 0c 00 00 00</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><strong>虚基类表存放着 虚基类对象的首地址相对于虚基类表指针的偏移量，对象地址+虚基类表中虚基类对象相对于虚基类表指针的偏移量=虚基类对象的首地址</strong></p></li></ul></li></ul><ul><li><p>虚基类表内容之1-4字节内容分析</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grand</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_grand;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grand2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_grand2;</span><br><span class="line"><span class="keyword">int</span> m_grand2_1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span> :</span> <span class="keyword">public</span>  Grand ,<span class="keyword">virtual</span> <span class="keyword">public</span> Grand2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_a1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A1 a1;</span><br><span class="line"></span><br><span class="line">a1.m_grand = <span class="number">2</span>;</span><br><span class="line">a1.m_a1 = <span class="number">3</span>;</span><br><span class="line">a1.m_grand2 = <span class="number">4</span>;</span><br><span class="line">a1.m_grand2_1 = <span class="number">5</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0x012FFD58  02 00 00 00 30 8b d7 00 03 00 00 00 04 00 00 00 05 00 00 00</span></span><br><span class="line"><span class="comment">0x00D78B30  fc ff ff ff 08 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>虚基类表指针成员变量的首地址，和<strong>本对象A1首地址之间的偏移量</strong>也就是虚基类表指针的首地址-A1对象的首地址=-4</p></li><li><p>只有对虚基类成员进行处理，才会用到虚基类表表，取其中的偏移进行计算</p></li></ul></li></ul><h2 id="26-三层结构时虚基类表内容分析"><a href="#26-三层结构时虚基类表内容分析" class="headerlink" title="26 三层结构时虚基类表内容分析"></a>26 三层结构时虚基类表内容分析</h2><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grand</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_grand;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span>  Grand &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_a1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> :</span><span class="keyword">public</span> <span class="keyword">virtual</span> Grand &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_a2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span> :</span><span class="keyword">public</span> A1, <span class="keyword">public</span> A2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_c1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(Grand) "</span> &lt;&lt; <span class="keyword">sizeof</span>(Grand) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(A1) "</span> &lt;&lt; <span class="keyword">sizeof</span>(A1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(A2) "</span> &lt;&lt; <span class="keyword">sizeof</span>(A2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; "sizeof(C1) " &lt;&lt; sizeof(C1) &lt;&lt; endl;//8 两份grand</span></span><br><span class="line"></span><br><span class="line">C1 c1;</span><br><span class="line">c1.m_c1 = <span class="number">1</span>;<span class="comment">//17-20</span></span><br><span class="line">c1.m_a1 = <span class="number">2</span>;<span class="comment">//5-8</span></span><br><span class="line">c1.m_a2 = <span class="number">3</span>;<span class="comment">//13-16</span></span><br><span class="line">c1.m_grand = <span class="number">4</span>;<span class="comment">//</span></span><br><span class="line"><span class="comment">//vptr1  1-4</span></span><br><span class="line"><span class="comment">//vptr2 9-12</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sizeof(Grand) 4</span></span><br><span class="line"><span class="comment">sizeof(A1) 12</span></span><br><span class="line"><span class="comment">sizeof(A2) 12</span></span><br><span class="line"><span class="comment">sizeof(C1) 24</span></span><br><span class="line"><span class="comment">&amp;c1=0x00BDFDA0  50 8b 79 00 02 00 00 00 60 8b 79 00 03 00 00 00 01 00 00 00 04 00 00 00</span></span><br><span class="line"><span class="comment">0x00798B50  00 00 00 00 14 00 00 00 </span></span><br><span class="line"><span class="comment">0x00798B60  00 00 00 00 0c 00 00 00</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">C1 c1;</span></span><br><span class="line"><span class="comment">00795DF8  push        1  </span></span><br><span class="line"><span class="comment">00795DFA  lea         ecx,[c1]  </span></span><br><span class="line"><span class="comment">00795DFD  call        C1::C1 (07913E3h)  </span></span><br><span class="line"><span class="comment">c1.m_c1 = 1;</span></span><br><span class="line"><span class="comment">00795E02  mov         dword ptr [ebp-10h],1  </span></span><br><span class="line"><span class="comment">c1.m_a1 = 2;</span></span><br><span class="line"><span class="comment">00795E09  mov         dword ptr [ebp-1Ch],2  </span></span><br><span class="line"><span class="comment">c1.m_a2 = 3;</span></span><br><span class="line"><span class="comment">00795E10  mov         dword ptr [ebp-14h],3  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">c1.m_grand = 4;</span></span><br><span class="line"><span class="comment">00795E17  mov         eax,dword ptr [c1]  //c1首地址为虚基类表指针</span></span><br><span class="line"><span class="comment">00795E1A  mov         ecx,dword ptr [eax+4]  十六进制14 为10进制20</span></span><br><span class="line"><span class="comment">00795E1D  mov         dword ptr c1[ecx],4  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">c1.m_grand2 = 5;</span></span><br><span class="line"><span class="comment">00A95E25  mov         eax,dword ptr [c1]  </span></span><br><span class="line"><span class="comment">00A95E28  mov         ecx,dword ptr [eax+4]  </span></span><br><span class="line"><span class="comment">00A95E2B  mov         dword ptr [ebp+ecx-20h],5  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><img src="object-model2/1565854078004.png" alt="1565854078004"></p></li><li><p>没有用到VBPTR2，只保留了一份grand</p></li><li><p><strong>访问虚基类的成员变量比其他成员变量慢。</strong></p></li></ul><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">A2 *pa2 = &amp;c1;<span class="comment">//pa2 = 0x0133fe20 &#123;m_a2=7 &#125;</span></span><br><span class="line">pa2-&gt;m_grand = <span class="number">6</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&amp;c1=0x0133FE18</span></span><br><span class="line"><span class="comment">0x0133FE20  60 8b 12 00 </span></span><br><span class="line"><span class="comment">0x00128B60  00 00 00 00 0c 00 00 00</span></span><br><span class="line"><span class="comment">pa2-&gt;m_grand = 6;</span></span><br><span class="line"><span class="comment">00125E5B  mov         eax,dword ptr [pa2]  pa2指向的内容给eax</span></span><br><span class="line"><span class="comment">00125E5E  mov         ecx,dword ptr [eax]  </span></span><br><span class="line"><span class="comment">00125E60  mov         edx,dword ptr [ecx+4]  </span></span><br><span class="line"><span class="comment">00125E63  mov         eax,dword ptr [pa2]  </span></span><br><span class="line"><span class="comment">00125E66  mov         dword ptr [eax+edx],6  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="27-成员变量地址、偏移、指针重申"><a href="#27-成员变量地址、偏移、指针重申" class="headerlink" title="27 成员变量地址、偏移、指针重申"></a>27 成员变量地址、偏移、指针重申</h2><ul><li><p>对象成员变量内存地址及其指针</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MYACLS</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_i;</span><br><span class="line"><span class="keyword">int</span> m_j;</span><br><span class="line"><span class="keyword">int</span> m_k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MYACLS myobj;</span><br><span class="line">myobj.m_i = <span class="number">1</span>;</span><br><span class="line">myobj.m_j = <span class="number">2</span>;</span><br><span class="line">myobj.m_k = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"myobj.m_i= %p \n"</span>, &amp;myobj.m_i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"myobj.m_j= %p \n"</span>, &amp;myobj.m_j);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"myobj.m_k= %p \n"</span>, &amp;myobj.m_k);</span><br><span class="line"></span><br><span class="line">MYACLS *pmyobj = <span class="keyword">new</span> MYACLS();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pmyobj.m_i= %p \n"</span>, &amp;pmyobj-&gt;m_i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pmyobj.m_j= %p \n"</span>, &amp;pmyobj-&gt;m_j);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pmyobj.m_k= %p \n"</span>, &amp;pmyobj-&gt;m_k);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p1 = &amp;myobj.m_i;</span><br><span class="line"><span class="keyword">int</span> *p2 = &amp;pmyobj-&gt;m_i;</span><br><span class="line">*p1 = <span class="number">1</span>;</span><br><span class="line">*p2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"p1= %p  *p1=%d\n"</span>, p1,*p1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"p2= %p  *p2=%d\n"</span>, p2, *p2);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">myobj.m_i= 012FFA98</span></span><br><span class="line"><span class="comment">myobj.m_j= 012FFA9C</span></span><br><span class="line"><span class="comment">myobj.m_k= 012FFAA0</span></span><br><span class="line"><span class="comment">pmyobj.m_i= 01606DF0</span></span><br><span class="line"><span class="comment">pmyobj.m_j= 01606DF4</span></span><br><span class="line"><span class="comment">pmyobj.m_k= 01606DF8</span></span><br><span class="line"><span class="comment">p1= 012FFA98  *p1=1</span></span><br><span class="line"><span class="comment">p2= 01606DF0  *p2=2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>成员变量的偏移值及其指针</p><ul><li><p>和具体对象没关系</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"myobj.m_i offset = %p \n"</span>, &amp;MYACLS::m_i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"myobj.m_j offset = %p \n"</span>, &amp;MYACLS::m_j);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"myobj.m_k offset = %p \n"</span>, &amp;MYACLS::m_k);</span><br><span class="line"><span class="keyword">int</span> MYACLS::*mypoint = &amp;MYACLS::m_i;<span class="comment">//定义时，加个类名，使用时，直接使用</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;MYACLS::m_i = %p \n"</span>, mypoint);</span><br><span class="line">mypoint = &amp;MYACLS::m_j;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;MYACLS::m_j = %p \n"</span>, mypoint);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">myobj.m_i offset = 00000000</span></span><br><span class="line"><span class="comment">myobj.m_j offset = 00000004</span></span><br><span class="line"><span class="comment">myobj.m_k offset = 00000008</span></span><br><span class="line"><span class="comment">&amp;MYACLS::m_i = 00000000</span></span><br><span class="line"><span class="comment">&amp;MYACLS::m_j = 00000004</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><strong>成员变量指针，实际保存的是偏移值</strong>，相对于类开头的地址</p></li></ul></li><li><p>没有指向任何数据成员变量的指针</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//成员变量指针 可以作为参数传</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">(<span class="keyword">int</span> MYACLS::*mempoint, MYACLS &amp;obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">obj.*mempoint = <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MYACLS::*mypoint = &amp;MYACLS::m_i;<span class="comment">//成员变量指针定义时，加个类名，使用时，直接使用</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;MYACLS::m_i = %p \n"</span>, mypoint);<span class="comment">//mypoint=0 成员变量指针=0，但是有意义，表示指向第一个成员变量的偏移量为0</span></span><br><span class="line">mypoint = &amp;MYACLS::m_j;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;MYACLS::m_j = %p \n"</span>, mypoint);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过一个对象名/对象指针 跟成员变量指针 访问成员变量</span></span><br><span class="line">myobj.m_i = <span class="number">13</span>;</span><br><span class="line">myobj.*mypoint = <span class="number">14</span>;</span><br><span class="line"></span><br><span class="line">pmyobj-&gt;*mypoint = <span class="number">19</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myfunc(mypoint,myobj);</span><br><span class="line">myfunc(mypoint, myobj);</span><br><span class="line"></span><br><span class="line">    mypoint = <span class="number">0</span>;<span class="comment">//直接给成员变量指针为 0时，为-1mypoint = 0xffffffff &#123;???&#125;-1</span></span><br><span class="line">mypoint = <span class="literal">nullptr</span>;<span class="comment">//成员变量指针为 nullptr时，为-1 mypoint = 0xffffffff &#123;???&#125; -1</span></span><br></pre></td></tr></table></figure></li><li><p><strong>没有指向任意有效的成员变量的成员变量指针为 -1</strong></p></li></ul></li></ul><h2 id="28-普通成员函数的调用方式"><a href="#28-普通成员函数的调用方式" class="headerlink" title="28 普通成员函数的调用方式"></a>28 普通成员函数的调用方式</h2><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MYACLS</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_i;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">(<span class="keyword">int</span> abc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_i += abc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gmyfunc</span><span class="params">(MYACLS* ptmp, <span class="keyword">int</span> abc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ptmp-&gt;m_i += abc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">(MYACLS *<span class="keyword">const</span> <span class="keyword">this</span>，<span class="keyword">int</span> abc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_i+=abc;</span><br><span class="line">&#125;</span><br><span class="line">MYACLS myobj;</span><br><span class="line">myobj.myfunc(<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">gmyfunc(&amp;myobj,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"MYACLS myfunc 地址= %p \n"</span>,&amp;MYACLS::myfunc);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//linux 下，通过nm 5_1 查看 函数地址</span></span><br></pre></td></tr></table></figure></li><li><p>C++要求对普通成员函数调用不应该比全局函数慢，基于这种情况，编译器内部实际将成员函数的调用转换为对全局函数的调用</p></li><li><p><strong>成员函数跟着类走，有独立的内存地址，且地址在编译时就确定了</strong></p><ul><li>编译器对成员函数额外增加this形参，指向生成的对象</li><li>对于常规成员变量的存取，都通过this形参来进行访问</li></ul></li></ul><h2 id="29-虚函数、静态成员函数调用方式"><a href="#29-虚函数、静态成员函数调用方式" class="headerlink" title="29 虚函数、静态成员函数调用方式"></a>29 虚函数、静态成员函数调用方式</h2><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MYACLS</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_i;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">(<span class="keyword">int</span> abc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_i += abc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">myvirfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"myvirfunc called this= %p\n"</span>,<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MYACLS myobj;</span><br><span class="line"><span class="comment">//myobj.myfunc(18);</span></span><br><span class="line"><span class="comment">//gmyfunc(&amp;myobj,18);</span></span><br><span class="line"></span><br><span class="line">myobj.myvirfunc();</span><br><span class="line"></span><br><span class="line">MYACLS * pmyacls = <span class="keyword">new</span> MYACLS();</span><br><span class="line">pmyacls-&gt;myvirfunc();</span><br><span class="line"></span><br><span class="line"><span class="comment">//(*pmyacls-&gt;vptr[0])(pmyacls)</span></span><br><span class="line"><span class="comment">// vptr 虚函数表指针，</span></span><br><span class="line"><span class="comment">//vptr[0] 虚函数表中第一项</span></span><br><span class="line"><span class="comment">//pmyacls this指针，传递一个参数</span></span><br><span class="line"><span class="comment">//* 就得到了虚函数的地址</span></span><br><span class="line"><span class="keyword">delete</span> pmyacls;</span><br></pre></td></tr></table></figure></li><li><p><strong>通过对象调用虚函数，同普通成员函数一样，不需要通过虚函数表</strong></p></li><li><p><strong>通过指针调用虚函数，需要通过虚函数表找到虚函数的地址</strong></p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MYACLS</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_i;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">(<span class="keyword">int</span> abc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_i += abc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">myvirfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"myvirfunc called this= %p\n"</span>,<span class="keyword">this</span>);</span><br><span class="line">myvirfunc2();<span class="comment">//通过虚函数表指针调用</span></span><br><span class="line">MYACLS::myvirfunc2();<span class="comment">// 直接调用，效率更高，压制了虚拟机制，不通过查询虚函数表来调用</span></span><br><span class="line">        <span class="comment">//通过类名调用虚函数方式，等价于直接调用一个普通函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">myvirfunc2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"myvirfunc2 called this= %p\n"</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">MYACLS myobj;</span><br><span class="line"><span class="comment">//myobj.myfunc(18);</span></span><br><span class="line"><span class="comment">//gmyfunc(&amp;myobj,18);</span></span><br><span class="line"></span><br><span class="line">myobj.myvirfunc();</span><br></pre></td></tr></table></figure></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MYACLS</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_i;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">(<span class="keyword">int</span> abc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_i += abc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">myvirfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"myvirfunc called this= %p\n"</span>,<span class="keyword">this</span>);</span><br><span class="line">myvirfunc2();<span class="comment">//通过虚函数表指针调用</span></span><br><span class="line">MYACLS::myvirfunc2();<span class="comment">// 直接调用，效率更高，压制了虚拟机制，不通过查询虚函数表来调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">myvirfunc2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"myvirfunc2 called this= %p\n"</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mystfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"static member funciton called"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MYACLS myobj;</span><br><span class="line">myobj.mystfunc();</span><br><span class="line">MYACLS::mystfunc();</span><br><span class="line"></span><br><span class="line">MYACLS *pmyacls = <span class="keyword">new</span> MYACLS();</span><br><span class="line">pmyacls-&gt;mystfunc();</span><br><span class="line">((MYACLS*)<span class="number">0</span>)-&gt;mystfunc();<span class="comment">// 仅仅 静态成员函数，编译器没有this参数，this参数为空</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"MYACLS::mystfunc 静态函数地址=%p\n"</span>, &amp;MYACLS::mystfunc);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">((MYACLS*)0)-&gt;mystfunc();// 仅仅 静态成员函数，编译器没有this参数，this参数为空</span></span><br><span class="line"><span class="comment">0100293B  call        MYACLS::mystfunc (01001221h)  </span></span><br><span class="line"><span class="comment">((MYACLS*)0)-&gt;myfunc(12); // 异常this 是 nullptr。</span></span><br><span class="line"><span class="comment">//但是 如果在myfunc中不使用this指针，也不报异常！！！！！！！！！！！！</span></span><br><span class="line"><span class="comment">//因为 有其自己的地址，在编译时就已经确定了</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>静态成员函数不需要this指针</p></li><li><p><strong>指向0的指针调用成员函数。有些成员函数支持独立于类对象之外的存取操作！！！！！</strong></p></li><li><p>静态成员函数特性</p><ul><li>静态成员函数没有this指针</li><li>无法直接存取类中普通非静态成员变量</li><li><strong>静态成员函数不能在后使用const，也不能virtual</strong></li><li>可以用类对象来调用，不非一定要用类调用</li><li>静态成员函数等同于非成员函数，有的需要提供回调函数的场合可以将静态成员函数作为回调函数</li><li>静态成员函数也有其地址</li></ul></li></ul><h2 id="30-虚成员函数地址问题的vcall引入"><a href="#30-虚成员函数地址问题的vcall引入" class="headerlink" title="30 虚成员函数地址问题的vcall引入"></a>30 虚成员函数地址问题的vcall引入</h2><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MYACLS</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">myvirfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">myvirfunc2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" MYACLS myvirfunc =%p\n"</span>, &amp;MYACLS::myvirfunc);<span class="comment">//00B81145 为vcall函数地址，不是真正的虚函数地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" MYACLS myvirfunc2 =%p\n"</span>, &amp;MYACLS::myvirfunc2);<span class="comment">//00B81064</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(MYACLS)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">MYACLS *pmyobj = <span class="keyword">new</span> MYACLS(); <span class="comment">//pmyobj = 0x00d40578 &#123;...&#125;</span></span><br><span class="line"><span class="comment">//__vfptr = 0x00b87b34 &#123;class31_virtual_member_function.exe!const MYACLS::`vftable'&#125; &#123;0x00b811c7 &#123;class31_virtual_member_function.exe!MYACLS::myvirfunc(void)&#125;, ...&#125;</span></span><br><span class="line"><span class="comment">//[0] = 0x00b811c7 &#123;class31_virtual_member_function.exe!MYACLS::myvirfunc(void)&#125;</span></span><br><span class="line"><span class="comment">//[1] = 0x00b81127 &#123;class31_virtual_member_function.exe!MYACLS::myvirfunc2(void)&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0x00b811c7 !=00B81145</span></span><br><span class="line"><span class="comment">0x00b81127!=00B81064</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">MYACLS::`vcall'&#123;0&#125;':</span></span><br><span class="line"><span class="comment">00B81145  jmp         MYACLS::`vcall'&#123;0&#125;' (0B81988h)  </span></span><br><span class="line"><span class="comment">MYACLS::`vcall'&#123;4&#125;':</span></span><br><span class="line"><span class="comment">00B81064  jmp         MYACLS::`vcall'&#123;4&#125;' (0B81983h)  </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>vcall think–多重继承中</p><ul><li>调整this指针</li><li>跳转到真正的虚函数中</li></ul></li></ul><h2 id="31-静态动态类型、绑定"><a href="#31-静态动态类型、绑定" class="headerlink" title="31 静态动态类型、绑定"></a>31 静态动态类型、绑定</h2><ul><li><p>静态类型/动态类型</p><ul><li><p>静态类型，对象定义时类型，编译期间就确定好的</p></li><li><p>动态类型，对象目前所指向的类型（运行时才决定的类型）–指针+引用，一般指父类指针、引用指向子类</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive2</span> :</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line">Base base;</span><br><span class="line">Derive derive;<span class="comment">//derive 静态类型为Derive ，没有动态类型</span></span><br><span class="line">Base* pbase;<span class="comment">//pbase 静态类型为Base* ，目前没有任何动态类型，没有指向任何对象</span></span><br><span class="line">Base* pbase2 = <span class="keyword">new</span> Derive();<span class="comment">// pbase2 的静态类型为Base*，动态类型为Derive</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pbase = pbase2;<span class="comment">//pbase的动态类型变为Derive</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>静态绑定/动态绑定</p><ul><li>静态绑定：绑定的静态类型，所对应的函数或者属性依赖于对象的静态类型，发生在编译期间</li><li>动态绑定：绑定动态类型，所对应的函数或者属性依赖于对象的动态类型，发生在运行期间<ul><li><strong>普通成员函数静态绑定，虚函数动态绑定</strong></li><li>缺省参数一般静态绑定</li></ul></li></ul></li><li><p>继承的非虚函数</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Derive derive;</span><br><span class="line">  Derive *pderive = &amp;derive;</span><br><span class="line">  pderive-&gt;myfunc();<span class="comment">//pderive 静态类型为Derive*</span></span><br><span class="line">  </span><br><span class="line">  Base* pbase = &amp;derive;</span><br><span class="line">  pbase-&gt;myfunc();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Derive myfunc</span></span><br><span class="line"><span class="comment">Base myfunc</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><strong>普通成员函数静态绑定，myfunc静态绑定，取决于调用者的静态类型</strong></p></li><li><p><strong>不应该在子类中重新定义一个继承来的非虚函数</strong></p></li></ul></li><li><p>虚函数的动态绑定</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base myfunc"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">virfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base virfunc"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive myfunc"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">virfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive virfunc"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Base* pbase = &amp;derive;</span><br><span class="line">pbase-&gt;myfunc();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">string</span>(<span class="number">10</span>,<span class="string">'-'</span>)&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Base base;</span><br><span class="line">pderive-&gt;virfunc();<span class="comment">//动态类型为 Derive *</span></span><br><span class="line">pbase-&gt;virfunc();<span class="comment">//动态类型为 Derive *,虚函数动态绑定，参照动态类型</span></span><br><span class="line"></span><br><span class="line">pbase = &amp;base;<span class="comment">//动态类型为 Base *</span></span><br><span class="line">pbase-&gt;virfunc();<span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Base myfunc</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line"><span class="comment">Derive virfunc</span></span><br><span class="line"><span class="comment">Derive virfunc</span></span><br><span class="line"><span class="comment">Base virfunc</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>虚函数动态绑定，取决于调用对象的动态类型</p></li></ul></li><li><p>重新定义虚函数的缺省参数</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base myfunc"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">virfunc</span><span class="params">(<span class="keyword">int</span> val=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base virfunc val="</span>&lt;&lt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive myfunc"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">virfunc</span><span class="params">(<span class="keyword">int</span> val=<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive virfunc val="</span>&lt;&lt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Base* pbase = &amp;derive;</span><br><span class="line">pbase-&gt;myfunc();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">string</span>(<span class="number">10</span>,<span class="string">'-'</span>)&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Base base;</span><br><span class="line">pderive-&gt;virfunc();<span class="comment">//动态类型为 Derive *</span></span><br><span class="line">pbase-&gt;virfunc();<span class="comment">//动态类型为 Derive *,虚函数动态绑定，参照动态类型,缺省参数一般静态绑定</span></span><br><span class="line"></span><br><span class="line">pbase = &amp;base;<span class="comment">//动态类型为 Base *</span></span><br><span class="line">pbase-&gt;virfunc();<span class="comment">//</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Base myfunc</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line"><span class="comment">Derive virfunc val=2</span></span><br><span class="line"><span class="comment">Derive virfunc val=1</span></span><br><span class="line"><span class="comment">Base virfunc val=1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><strong>缺省参数一般静态绑定</strong></p></li><li><p><strong>不要重新定义虚函数的缺省参数值</strong></p></li></ul></li><li><p>c++中多态体现</p><ul><li><p>多态必须存在虚函数</p></li><li><p>代码实现上</p><ul><li><p>通过查询虚函数表找到虚函数入口地址，如果是这个路径，则是多态，否则不是多态</p></li><li><p>通过对象直接调用虚函数，不走虚函数表非多态</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">myvirfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"A myvirfunc"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">A*pa = <span class="keyword">new</span> A();</span><br><span class="line">pa-&gt;myvirfunc();</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line">a.myvirfunc();<span class="comment">//非多态</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pa-&gt;myvirfunc();</span></span><br><span class="line"><span class="comment">00572091  mov         eax,dword ptr [pa]  </span></span><br><span class="line"><span class="comment">00572094  mov         edx,dword ptr [eax]  </span></span><br><span class="line"><span class="comment">00572096  mov         esi,esp  </span></span><br><span class="line"><span class="comment">00572098  mov         ecx,dword ptr [pa]  </span></span><br><span class="line"><span class="comment">0057209B  mov         eax,dword ptr [edx]  </span></span><br><span class="line"><span class="comment">0057209D  call        eax  </span></span><br><span class="line"><span class="comment">0057209F  cmp         esi,esp  </span></span><br><span class="line"><span class="comment">005720A1  call        __RTC_CheckEsp (0571267h)  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">A a;</span></span><br><span class="line"><span class="comment">005720A6  lea         ecx,[a]  </span></span><br><span class="line"><span class="comment">005720A9  call        A::A (0571672h)  </span></span><br><span class="line"><span class="comment">a.myvirfunc();//非多态</span></span><br><span class="line"><span class="comment">005720AE  lea         ecx,[a]  </span></span><br><span class="line"><span class="comment">a.myvirfunc();//非多态</span></span><br><span class="line"><span class="comment">005720B1  call        A::myvirfunc (0571677h)  </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>表现形式</p><ul><li>有继承关系，有父类，有子类，父类有虚函数，子类一定有虚函数，子类重写父类虚函数</li><li>父类指针或引用指向子类对象</li><li>当以父类指针或引用调用子类重写了的虚函数时</li></ul></li></ul></li></ul><h2 id="32-单继承虚函数回顾"><a href="#32-单继承虚函数回顾" class="headerlink" title="32 单继承虚函数回顾"></a>32 单继承虚函数回顾</h2><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::f"</span>&lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::g"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::h"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//virtual void i() &#123; cout &lt;&lt; "Derive::i" &lt;&lt; endl; &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt;<span class="string">"Derive::g"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myselffunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><img src="object-model/1563259723100.png" alt="1563259723100"></p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::f"</span>&lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::g"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::h"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">i</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::i"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt;<span class="string">"Derive::g"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myselffunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pmyderive-&gt;h();</span></span><br><span class="line"><span class="comment">00A72841  mov         eax,dword ptr [pmyderive]  </span></span><br><span class="line"><span class="comment">00A72844  mov         edx,dword ptr [eax]  </span></span><br><span class="line"><span class="comment">00A72846  mov         esi,esp  </span></span><br><span class="line"><span class="comment">00A72848  mov         ecx,dword ptr [pmyderive]  </span></span><br><span class="line"><span class="comment">00A7284B  mov         eax,dword ptr [edx+8]  </span></span><br><span class="line"><span class="comment">00A7284E  call        eax  </span></span><br><span class="line"><span class="comment">00A72850  cmp         esi,esp  </span></span><br><span class="line"><span class="comment">00A72852  call        __RTC_CheckEsp (0A7117Ch)  </span></span><br><span class="line"><span class="comment">pmyderive-&gt;i();</span></span><br><span class="line"><span class="comment">00A72857  mov         eax,dword ptr [pmyderive]  </span></span><br><span class="line"><span class="comment">00A7285A  mov         edx,dword ptr [eax]  </span></span><br><span class="line"><span class="comment">00A7285C  mov         esi,esp  </span></span><br><span class="line"><span class="comment">00A7285E  mov         ecx,dword ptr [pmyderive]  </span></span><br><span class="line"><span class="comment">00A72861  mov         eax,dword ptr [edx+0Ch]  </span></span><br><span class="line"><span class="comment">00A72864  call        eax  </span></span><br><span class="line"><span class="comment">00A72866  cmp         esi,esp  </span></span><br><span class="line"><span class="comment">00A72868  call        __RTC_CheckEsp (0A7117Ch)  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Base *pb = new Derive();</span></span><br><span class="line"><span class="comment">pb-&gt;g();</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(*pb-&gt;vptr[1])(pb) //虚函数this指针 执行时确定的是哪个虚函数表，</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li><li><p><img src="object-model2/1566109393978.png" alt="1566109393978"></p></li><li><p>子类中的虚函数表顺序和父类中虚函数表顺序一致，之后才是自己重新定义的虚函数表地址</p></li><li><p>虚函数地址编译时已经确定，且在可执行文件中，运行时确定哪个虚函数表</p></li><li><p>vptr在编译期间产生，在构造函数中插入给vptr赋值代码，创建对象时，调用构造函数，vptr被赋值</p></li><li><p>每个类对象有自己的虚函数表指针，有相同的虚函数表</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Derive a1;</span><br><span class="line">Derive a2;</span><br><span class="line"></span><br><span class="line">Derive *pa3 = <span class="keyword">new</span> Derive();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0x00B3F718 </span></span><br><span class="line"><span class="comment">0x00B3F718  7c 9b 3b 00</span></span><br><span class="line"><span class="comment">0x00B3F70C  7c 9b 3b 00</span></span><br><span class="line"><span class="comment">0x00D3E0F8  7c 9b 3b 00</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>即便子类不重写任何虚函数，虚函数表指针同父类也不同</p></li></ul><h2 id="33-多继承虚函数深度解释、第二基类、虚析构必加"><a href="#33-多继承虚函数深度解释、第二基类、虚析构必加" class="headerlink" title="33 多继承虚函数深度解释、第二基类、虚析构必加"></a>33 多继承虚函数深度解释、第二基类、虚析构必加</h2><ul><li><p>多继承下的虚函数</p><ul><li><p>多重继承复杂性体现在第二个基类</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::f"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::g"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::h"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">k</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::k"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::h2"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span><span class="keyword">public</span> Base,<span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">i</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::i"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::g"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myselffunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">Base2* pb2 = <span class="keyword">new</span> Derive();<span class="comment">//pb2 地址为this调整过的地址</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Derive * temp=new Derive();</span></span><br><span class="line"><span class="comment">Base2 *pb2=temp+sizeof(Base);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Base2 *pb2=(Base2*) ((char*)temp+sizeof(Base));</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pb2;<span class="comment">// 报异常</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li></li></ul></li><li><p>如何删除用第二基类指针new出来的继承类对象</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base2* pb2 = <span class="keyword">new</span> Derive();<span class="comment">//pb2 地址为this调整过的地址</span></span><br></pre></td></tr></table></figure></li><li><p>实际上要删除的是Derive对象</p></li><li><p>确保Derive的析构函数被调用</p></li><li><p>编译器调用静态类型的析构函数</p></li><li><p>执行delete pb2时</p><ul><li><p>如果Base2中没有析构函数，编译器直接删除pb2开始的内存，异常，释放的内存不是new起始的内存</p></li><li><p>如果Base2中存在析构函数，但非虚析构函数，delete pb2时，非虚析构函数被调用，直接删除pb2开始的内存,依然异常，析构函数不是虚函数，编译器实施静态绑定，delete pb2时，删除内存的开始地址即pb2的当前位置</p></li><li><p>如果Base2中存在析构函数，为虚析构函数,delete pb2时正确释放内存</p><ul><li><p>在Derive的虚析构函数中调用Base2中虚析构函数</p></li><li><p>Base2存在虚析构函数，Derive没有虚析构函数，编译器生成Derive的虚析构函数</p></li><li><p>只要Base2中析构函数为虚的，Derive中析构函数不管是否加virtual，都是虚函数</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">开发人员提示符 </span></span><br><span class="line"><span class="comment">dumpbin /all project100.obj &gt; my.txt</span></span><br><span class="line"><span class="comment">查看 虚析构函数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>涉及继承所有类，不管子类，父类，虚析构函数</strong>，空也行</p></li></ul></li><li><p>为什么加虚析构函数</p><ul><li>当定义第二个基类指针指向子类时，删除此指针指向的内存。由于内存布局影响，此指针指向的内存为子类内存的一部分。删除时，无法完全删除。普通成员函数静态绑定，delete时，调用的是第二个基类的析构函数。而声明为虚析构函数后，由于虚函数动态绑定，调用析构函数时，会先调用子类的虚析构函数，之后调用基类的虚析构函数。</li></ul></li></ul><h2 id="34-多继承第二基类虚函数支持、虚继承带虚函数"><a href="#34-多继承第二基类虚函数支持、虚继承带虚函数" class="headerlink" title="34 多继承第二基类虚函数支持、虚继承带虚函数"></a>34 多继承第二基类虚函数支持、虚继承带虚函数</h2><ul><li><p>多重继承第二基类对虚函数的影响</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::f"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::g"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::h"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">k</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::k"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Base * <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Base();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::h2"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">virtual</span> ~Base2()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Base2 * <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Base2();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span><span class="keyword">public</span> Base,<span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">i</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::i"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::g"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myselffunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Derive * <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Derive();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>子类继承几个父类，子类就有几个虚函数表</p></li><li><p>多重继承下，存在情况，第二个基类或者后续的基类对虚函数的支持产生影响，this指针调整</p><ul><li><p>this指针目的让对象指针正确的指向对象首地址，从而正确的调用对象的成员函数或者说正确确定数据成员的存储位置</p></li><li><p>通过指向第二个基类的指针调用子类的虚函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base2 *pb2=<span class="keyword">new</span> Derive();</span><br><span class="line"><span class="keyword">delete</span> pb2;</span><br></pre></td></tr></table></figure></li><li><p>指向派生类的指针调用第二个基类中的虚函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Derive * pd2=<span class="keyword">new</span> Derive();</span><br><span class="line">pd2-&gt;h2();</span><br></pre></td></tr></table></figure></li><li><p>允许虚函数的返回值类型有所变化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base2* pb1 = <span class="keyword">new</span> Derive();</span><br><span class="line">Base2* pb2 = pb1-&gt;clone();<span class="comment">//执行Derive的克隆 Derive::clone()</span></span><br><span class="line"><span class="comment">//pb1 调整指向Derive中，Base2地址，执行pb1-&gt;clone()时pb1调整到Derive对象的首地址，调用 Derive::clone()</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>虚继承下的虚函数</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::f"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~Base()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m_basei;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span><span class="keyword">virtual</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~Derive()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m_derivei;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"sizeof(Derive): "</span> &lt;&lt;<span class="keyword">sizeof</span>(Derive)&lt;&lt; <span class="built_in">endl</span>;<span class="comment">//m_derivei+m_basei+vtbl+vbtbl</span></span><br><span class="line"></span><br><span class="line">Derive dobj;</span><br><span class="line">dobj.m_basei = <span class="number">2</span>;<span class="comment">//13-16</span></span><br><span class="line">dobj.m_derivei = <span class="number">5</span>;<span class="comment">//5-8</span></span><br><span class="line"></span><br><span class="line">Derive* pdobj = <span class="keyword">new</span> Derive();<span class="comment">//pdobj = 0x009f8d30 &#123;m_derivei=0 &#125;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Base = &#123; m_basei = 0 &#125;</span></span><br><span class="line"><span class="comment">__vfptr = 0x00899b50 &#123;class35_multi_inherit_second_base_virtual_func.exe!const Derive::`vftable'&#125; &#123;0x0089108c &#123;class35_multi_inherit_second_base_virtual_func.exe!Base::f(void)&#125;, ...&#125;</span></span><br><span class="line"><span class="comment">[0] = 0x0089108c &#123;class35_multi_inherit_second_base_virtual_func.exe!Base::f(void)&#125;</span></span><br><span class="line"><span class="comment">[1] = 0x0089145b &#123;class35_multi_inherit_second_base_virtual_func.exe!Derive::`vector deleting destructor'(unsigned int)&#125;</span></span><br><span class="line"><span class="comment">m_basei = 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">pdobj-&gt;f();</span><br><span class="line"> <span class="comment">//虚函数表指针9-12</span></span><br><span class="line"><span class="comment">//虚基类表指针1-5</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&amp;dobj=0x006FFD64</span></span><br><span class="line"><span class="comment">0x006FFD64  5c 9b 89 00 05 00 00 00 50 9b 89 00 02 00 00 00</span></span><br><span class="line"><span class="comment">0x00899B50  8c 10 89 00 5b 14 89 00 00 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><img src="object-model2/1566212440996.png" alt="1566212440996"></p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Derive *pderive = <span class="keyword">new</span> Derive();<span class="comment">//pderive = 0x012ee538 &#123;m_derivei=0 &#125;</span></span><br><span class="line">Base *pbase2 = (Base*)pderive;<span class="comment">//pbase2 = 0x012ee540 &#123;m_derivei=0 &#125;</span></span><br><span class="line">pbase2-&gt;m_basei = <span class="number">7</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0x012EE538  5c 9b dc 00 00 00 00 00 50 9b dc 00 07 00 00 00</span></span><br><span class="line"><span class="comment">0x012EE540  50 9b dc 00 07 00 00 00</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>繁杂，不深究！！！！！！！！！！！！！</p><h2 id="35-RTTI运行时类型识别与存储位置"><a href="#35-RTTI运行时类型识别与存储位置" class="headerlink" title="35 RTTI运行时类型识别与存储位置"></a>35 RTTI运行时类型识别与存储位置</h2></li><li><p>RTTI</p><ul><li><p>C++运行时类型识别，要求父类中至少有一个虚函数</p></li><li><p>RTTI能力靠typeid和dynamic_cast运算符体现</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Base* pb = <span class="keyword">new</span> Derive();</span><br><span class="line">pb-&gt;g();</span><br><span class="line"></span><br><span class="line">Derive myderive;</span><br><span class="line">Base&amp; yb = myderive;</span><br><span class="line">yb.g();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"typeid(*pb).name "</span>&lt;&lt;<span class="keyword">typeid</span>(*pb).name()&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"typeid(yb).name "</span>&lt;&lt;<span class="keyword">typeid</span>(yb).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Derive *pderive = <span class="keyword">dynamic_cast</span>&lt;Derive*&gt;(pb);</span><br><span class="line"><span class="keyword">if</span> (pderive != <span class="literal">nullptr</span>)<span class="comment">//成功转换，pderive为Derive对象</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"pb is Derive"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">pderive-&gt;myselffunc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Derive::g</span></span><br><span class="line"><span class="comment">Derive::g</span></span><br><span class="line"><span class="comment">typeid(*pb).name class Derive</span></span><br><span class="line"><span class="comment">typeid(yb).name class Derive</span></span><br><span class="line"><span class="comment">pb is Derive</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>RTTI实现原理</p><ul><li><p>typeid返回的常量对象引用，常量对象类型一般为type_info（类）</p></li><li><p>父类没有虚函数，typeid_name错误，显示基类</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::type_info &amp; tp = <span class="keyword">typeid</span>(*pb); <span class="comment">//type_info 不可拷贝构造，赋值</span></span><br><span class="line"> Base *pb2 = <span class="keyword">new</span> Derive();</span><br><span class="line"> <span class="keyword">const</span> <span class="built_in">std</span>::type_info &amp;tp2 = <span class="keyword">typeid</span>(*pb2);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span>(tp==tp2)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"all Derive"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//静态类型，给什么 出什么</span></span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt;<span class="string">"typeid(int).name() "</span>&lt;&lt;<span class="keyword">typeid</span>(<span class="keyword">int</span>).name() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基类没有虚函数时</span></span><br><span class="line">Base * pb = <span class="keyword">new</span> Derive();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"typeid(pb).name() "</span>&lt;&lt;<span class="keyword">typeid</span>(pb).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">typeid(pb).name() class Base *</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><img src="object-model2/1566216183403.png" alt="1566216183403"></li></ul></li><li><p>vptr，vtbl，rtti的type_info信息构造时机</p><ul><li>rtti的info信息编译时完成</li></ul></li></ul></li></ul><h2 id="36-函数调用、继承关系性能"><a href="#36-函数调用、继承关系性能" class="headerlink" title="36 函数调用、继承关系性能"></a>36 函数调用、继承关系性能</h2><ul><li><p>函数调用中编译器的循环代码优化</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span>  ns1&#123;</span><br><span class="line">__<span class="function">int64 <span class="title">mytest</span><span class="params">(<span class="keyword">int</span> mv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">__int64 icount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">icount += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 优化为 icount+=和值</span></span><br><span class="line"><span class="keyword">return</span> icount;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">clock_t</span> start, end;</span><br><span class="line">start = clock();</span><br><span class="line">__int64 mycount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">mycount += mytest(<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 优化为 mycount+=和值</span></span><br><span class="line">end = clock();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"cost times "</span>&lt;&lt;end-start&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"mycount "</span> &lt;&lt; mycount &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Dubug: 1546 Release: 1</p></li><li><p>优化循环，把循环优化为1条语句</p></li><li><p>在编译期间，编译器具有运算能力</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">clock_t</span> start, end;</span><br><span class="line">start = clock();</span><br><span class="line">__int64 mycount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">mycount += mytest(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化为 mycount+=和值</span></span><br><span class="line">end = clock();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"cost times "</span>&lt;&lt;end-start&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"mycount "</span> &lt;&lt; mycount &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Release 279ms</p></li><li><p>给固定表达式，编译器将这种参数固定的函数调用，视为不变的表达式，尝试做优化</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">__<span class="function">int64 <span class="title">mytest</span><span class="params">(<span class="keyword">int</span> mv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">__int64 icount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">icount += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> ((i == <span class="number">10000</span>) &amp;&amp; (mv == <span class="number">999</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化为 icount+=和值</span></span><br><span class="line"><span class="keyword">return</span> icount;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Release 633ms</p></li></ul></li><li><p>继承关系深度增加，开销一般也增加</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ns2 &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: A()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"A::A()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span><span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">C()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"C::C()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">C cobj;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>C构造调B构造，B构造调A构造</p><ul><li>当A有构造时，编译器会生成B构造，C调B，B调A 耗时增加</li><li>当A没有构造时，不会生成B构造，耗时不大</li></ul></li><li><p>多重继承导致开销增加</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ns2 &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: A()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"A::A()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: A1()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"A1::A1()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A,<span class="keyword">public</span> A1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span><span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">C()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"C::C()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">C cobj;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>继承关系深度增加，虚函数导致的开销增加</p><ul><li>每多一次继承，在构造函数中增加 虚函数表指针 赋值的代码</li><li>父类有虚函数，子类会生成默认构造函数</li></ul></li></ul><h2 id="37-指向成员函数的指针及VCALL"><a href="#37-指向成员函数的指针及VCALL" class="headerlink" title="37 指向成员函数的指针及VCALL"></a>37 指向成员函数的指针及VCALL</h2><ul><li><p>指向成员函数的指针</p><ul><li><p>成员函数地址，编译时已确定，调用成员函数，需要通过对象this指针实现</p></li><li><p>所有常规非静态成员函数，都需要一个对象来调用</p></li><li><p>成员函数第一个参数 this指针</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ns1 &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc1</span><span class="params">(<span class="keyword">int</span> val1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" myfunc1 "</span>&lt;&lt;val1&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc2</span><span class="params">(<span class="keyword">int</span> val1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" myfunc2 "</span> &lt;&lt; val1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mysfunc</span><span class="params">(<span class="keyword">int</span> val1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" mysfunc "</span> &lt;&lt; val1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A obja;</span><br><span class="line"><span class="keyword">void</span> (A::* p)(<span class="keyword">int</span> val) = &amp;A::myfunc1;<span class="comment">//定义一个成员函数指针</span></span><br><span class="line">p = &amp;A::myfunc2;</span><br><span class="line"></span><br><span class="line">(obja.*p)(<span class="number">15</span>);<span class="comment">// 通过成员函数指针调用成员函数，借用对象</span></span><br><span class="line"><span class="comment">//p(&amp;obja,15);</span></span><br><span class="line">A* pobj=<span class="keyword">new</span> A();</span><br><span class="line">(pobj-&gt;*p)(<span class="number">20</span>);<span class="comment">//通过成员函数指针调用成员函数，借用对象指针</span></span><br><span class="line"><span class="comment">//p(pobj,20);</span></span><br><span class="line"><span class="keyword">void</span>(*ps)(<span class="keyword">int</span> val1) = &amp;A::mysfunc;<span class="comment">// 普通函数指针</span></span><br><span class="line">ps(<span class="number">80</span>);</span><br><span class="line"><span class="comment">//通过成员函数指针对常规的成员函数调用的成本 ，和通过普通的函数指针调用静态成员函数，成本上差不多</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>指向虚成员函数的指针及VCALL</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ns2 &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc1</span><span class="params">(<span class="keyword">int</span> val1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" myfunc1 "</span> &lt;&lt; val1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc2</span><span class="params">(<span class="keyword">int</span> val1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" myfunc2 "</span> &lt;&lt; val1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mysfunc</span><span class="params">(<span class="keyword">int</span> val1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" mysfunc "</span> &lt;&lt; val1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">myvirtualprev</span><span class="params">(<span class="keyword">int</span> val1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" myvirtualprev "</span> &lt;&lt; val1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">myvirtual</span><span class="params">(<span class="keyword">int</span> val1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" myvitual "</span> &lt;&lt; val1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> (A::* pvritual)(<span class="keyword">int</span> val) = &amp;A::myvirtual;</span><br><span class="line">A* pvobj = <span class="keyword">new</span> A();</span><br><span class="line">pvobj-&gt;myvirtual(<span class="number">100</span>);<span class="comment">// 走虚函数表</span></span><br><span class="line"></span><br><span class="line">(pvobj-&gt;*pvritual)(<span class="number">200</span>);<span class="comment">//通过成员函数指针调用虚函数表，也走虚函数表</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" %p\n"</span>,&amp;A::myvirtual);<span class="comment">//不是虚函数真正地址，为vcall[4]地址</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0040276A  push        offset ns2::A::`vcall'&#123;4&#125;' (04014A6h)  </span></span><br><span class="line"><span class="comment">0040276F  push        offset string " %p\n" (0409B70h)  </span></span><br><span class="line"><span class="comment">00402774  call        _printf (04014BAh)  </span></span><br><span class="line"><span class="comment">00402779  add         esp,8  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">delete</span> pvobj;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>vcall (vcall chunk)=virtual call 虚调用</p></li><li><p>代表一段要执行的代码的地址，这段代码引导去执行正确的虚函数</p></li><li><p>或者vcall虚函数表，vcall[0]即虚函数表里的第一个函数，vcall[4]第二个虚函数，一个指针4字节</p></li><li><p>&amp;A::myvirtual 地址，地址中有一段代码，记录的是该虚函数在虚函数表中偏移值，有了偏移值，再加上具体的对象指针，就可以确定调用的是哪个虚函数表中的哪个虚函数</p></li></ul><p>成员函数指针，保存的可能是一个vcall地址（虚函数），要么可能是一个真正的函数地址</p><p>vcall 引导编译器从虚函数表中找到实际的虚函数地址</p></li><li><p>vcall 在继承关系中的体现</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ns3 &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc1</span><span class="params">(<span class="keyword">int</span> val1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" myfunc1 "</span> &lt;&lt; val1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc2</span><span class="params">(<span class="keyword">int</span> val1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" myfunc2 "</span> &lt;&lt; val1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mysfunc</span><span class="params">(<span class="keyword">int</span> val1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" mysfunc "</span> &lt;&lt; val1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">myvirtualprev</span><span class="params">(<span class="keyword">int</span> val1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"A  myvirtualprev "</span> &lt;&lt; val1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">myvirtual</span><span class="params">(<span class="keyword">int</span> val1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" A myvitual "</span> &lt;&lt; val1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~A() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">myvirtual</span><span class="params">(<span class="keyword">int</span> val1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" B myvitual "</span> &lt;&lt; val1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~B() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">B *p = <span class="keyword">new</span> B();<span class="comment">// 对象指针</span></span><br><span class="line"><span class="keyword">void</span> (B::*pvirtual)(<span class="keyword">int</span> val) = &amp;A::myvirtual;</span><br><span class="line"><span class="comment">//pvirtual 偏移量 ，父类和子类的 虚函数 偏移量都为0</span></span><br><span class="line">(p-&gt;*pvirtual)(<span class="number">120</span>);<span class="comment">//父类成员函数指针  最终调B的成员函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">004B1EDE  mov         esi,esp  </span></span><br><span class="line"><span class="comment">004B1EE0  push        0Ah  </span></span><br><span class="line"><span class="comment">004B1EE2  mov         ecx,dword ptr [p]  </span></span><br><span class="line"><span class="comment">004B1EE5  call        dword ptr [pvirtual]  </span></span><br><span class="line"><span class="comment">004B1EE8  cmp         esi,esp  </span></span><br><span class="line"><span class="comment">004B1EEA  call        __RTC_CheckEsp (04B11B3h)  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" &amp;A::myvirtual  %p \n"</span>, &amp;A::myvirtual);<span class="comment">// vcall 地址不一样</span></span><br><span class="line"><span class="comment">//A::myvirtual = 0x008d3090 &#123;class38_pointer_to_member_function.exe!ns3::A::myvirtual(int)&#125;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" &amp;B::myvirtual  %p \n"</span>, &amp;B::myvirtual);</span><br><span class="line"><span class="comment">//B::myvirtual = 0x008d3130 &#123;class38_pointer_to_member_function.exe!ns3::B::myvirtual(int)&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于虚成员函数的调用，对象决定调用哪个类的虚函数表，vcall决定了偏移，所以对于虚函数myvirfunc()不管是A中vcall还是B中vcall都是相同的偏移，而这里的成员函数指针，传入的对象是B,偏移是vcall{0}，所以最终调用的是B的虚函数myvirfunc()，同时这里不管是赋值给A的myvirfunc()的vcall还是B的myvirfunc()的vcall，都是调用的是B的虚函数myvirfunc()</p></li></ul></li></ul><h2 id="38-inline-函数"><a href="#38-inline-函数" class="headerlink" title="38 inline 函数"></a>38 inline 函数</h2><ul><li><p>inline函数</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ns1 &#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myfunc</span><span class="params">(<span class="keyword">int</span> testv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> testv*(<span class="number">5</span> + <span class="number">4</span>)*testv;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = myfunc(<span class="number">12</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"i "</span>&lt;&lt;i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int i = myfunc(12);</span></span><br><span class="line"><span class="comment">000F24AE  push        0Ch  </span></span><br><span class="line"><span class="comment">000F24B0  call        ns1::myfunc (0F102Dh)  </span></span><br><span class="line"><span class="comment">000F24B5  add         esp,4  </span></span><br><span class="line"><span class="comment">000F24B8  mov         dword ptr [i],eax </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//VS内联函数扩展 Ob1</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int i = myfunc(12);</span></span><br><span class="line"><span class="comment">00511CFE  mov         eax,0Ch  </span></span><br><span class="line"><span class="comment">00511D03  imul        ecx,eax,9  </span></span><br><span class="line"><span class="comment">00511D06  imul        edx,ecx,0Ch  </span></span><br><span class="line"><span class="comment">00511D09  mov         dword ptr [i],edx  </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>优点，快，缺点代码膨胀</p></li><li><p>编译器估计内联函数的复杂度，inline只是建议编译器</p></li></ul></li><li><p>inline扩展</p><ul><li><p>形参被对应实参代替</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = myfunc(<span class="number">12</span>+<span class="number">15</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"i "</span>&lt;&lt;i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int i = myfunc(12+15);</span></span><br><span class="line"><span class="comment">00681CFE  mov         eax,1Bh  </span></span><br><span class="line"><span class="comment">00681D03  imul        ecx,eax,9  </span></span><br><span class="line"><span class="comment">00681D06  imul        edx,ecx,1Bh  </span></span><br><span class="line"><span class="comment">00681D09  mov         dword ptr [i],edx  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">80</span>;</span><br><span class="line"><span class="keyword">int</span> i = myfunc(a + <span class="number">15</span>);<span class="comment">// 先计算 和值 在替换形参</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int i = myfunc(a + 15);// 先计算 和值 在替换形参</span></span><br><span class="line"><span class="comment">00382415  mov         eax,dword ptr [a]  </span></span><br><span class="line"><span class="comment">00382418  add         eax,0Fh  </span></span><br><span class="line"><span class="comment">0038241B  mov         dword ptr [ebp-20h],eax  </span></span><br><span class="line"><span class="comment">0038241E  imul        ecx,dword ptr [ebp-20h],9  </span></span><br><span class="line"><span class="comment">00382422  imul        ecx,dword ptr [ebp-20h]  </span></span><br><span class="line"><span class="comment">00382426  mov         dword ptr [i],ecx  </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>编译器先求值，用实参替换形参</p></li></ul></li><li><p>局部变量的引入</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">myfunc</span><span class="params">(<span class="keyword">int</span> testv)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="comment">//return testv*(5 + 4)*testv;</span></span><br><span class="line">  <span class="keyword">int</span> temp;</span><br><span class="line">  temp= testv*(<span class="number">5</span> + <span class="number">4</span>)*testv;</span><br><span class="line">  <span class="keyword">return</span> temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> i = myfunc(<span class="number">12</span>+ <span class="number">15</span>);<span class="comment">// 先计算 和值 在替换形参</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt;<span class="string">"i "</span>&lt;&lt;i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int i = myfunc(12+ 15);// 先计算 和值 在替换形参</span></span><br><span class="line"><span class="comment">004E240E  mov         eax,1Bh  </span></span><br><span class="line"><span class="comment">004E2413  imul        ecx,eax,9  </span></span><br><span class="line"><span class="comment">004E2416  imul        edx,ecx,1Bh  </span></span><br><span class="line"><span class="comment">004E2419  mov         dword ptr [ebp-14h],edx  </span></span><br><span class="line"><span class="comment">004E241C  mov         eax,dword ptr [ebp-14h]    //多了两条指令</span></span><br><span class="line"><span class="comment">004E241F  mov         dword ptr [i],eax  </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>局部变量尽量少用</p></li></ul></li><li><p>inline失败</p><ul><li>简单的递归函数</li></ul></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> object model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp_trivial</title>
      <link href="/2019/07/30/cpp-trivial/"/>
      <url>/2019/07/30/cpp-trivial/</url>
      
        <content type="html"><![CDATA[<ul><li>C++中的零碎</li><li>比较有意思的</li></ul><a id="more"></a><h2 id="1-字符串"><a href="#1-字符串" class="headerlink" title="1.字符串"></a>1.字符串</h2><ul><li><p>stof 第一个float型的字符串转为float</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">"1.23_*_2.34_*"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; stof(str)&lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1.23</span></span><br></pre></td></tr></table></figure></li><li><p>stoi 第一个int型的字符串转为int</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">"1.23_*_2.34_*"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; stoi(str)&lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1</span></span><br></pre></td></tr></table></figure></li><li><p>stringstream 仅能处理空格</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;//!!!!!!!!!!!!</span></span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"1.23 2.34"</span>;</span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line"><span class="keyword">float</span> num;</span><br><span class="line"><span class="keyword">while</span> (ss &gt;&gt; num)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;num &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1.23 2.34//仅能处理空格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">"1.23_2.34"</span>;</span><br><span class="line"><span class="comment">// cout &lt;&lt; stoi(str)&lt;&lt; endl;//1</span></span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line"><span class="keyword">float</span> num;</span><br><span class="line"><span class="keyword">while</span> (ss &gt;&gt; num)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;num &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1.23</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>strtok</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strtok</span><span class="params">( <span class="keyword">char</span>* str, <span class="keyword">const</span> <span class="keyword">char</span>* delim )</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分解字符串为一组字符串。s为要分解的字符，delim为分隔符字符（如果传入字符串，则传入的字符串中每个字符均为分割符）。首次调用时，s指向要分解的字符串，之后再次调用要把s设成NULL。</span></span><br><span class="line"><span class="comment">第一次分割之后，原字符串str是分割完成之后的第一个字符串，剩余的字符串存储在一个静态变量中，因此多线程同时访问该静态变量时，则会出现错误。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="keyword">char</span> input[<span class="number">100</span>] = <span class="string">"A bird came down the walk"</span>;</span><br><span class="line">    <span class="keyword">char</span> *token = <span class="built_in">std</span>::strtok(input, <span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">while</span> (token != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; token &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        token = <span class="built_in">std</span>::strtok(<span class="literal">NULL</span>, <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A</span></span><br><span class="line"><span class="comment">bird</span></span><br><span class="line"><span class="comment">came</span></span><br><span class="line"><span class="comment">down</span></span><br><span class="line"><span class="comment">the</span></span><br><span class="line"><span class="comment">walk</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="2-常用函数"><a href="#2-常用函数" class="headerlink" title="2.常用函数"></a>2.常用函数</h2><ul><li><p>fastpow</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">mypow3</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> positive = n&gt;<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> nn = n;</span><br><span class="line">nn = <span class="built_in">abs</span>(nn);</span><br><span class="line"><span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> ret = x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i = nn; i&gt;<span class="number">0</span>; i /= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((i % <span class="number">2</span>) == <span class="number">1</span>)<span class="comment">// 在最初为奇数 以及最后为奇数时 生效</span></span><br><span class="line">ans = ans*ret;</span><br><span class="line">ret = ret*ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!positive)</span><br><span class="line">ans = <span class="number">1</span> / ans;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> nn=n;</span><br><span class="line">        nn=<span class="built_in">abs</span>(nn);</span><br><span class="line">        <span class="keyword">bool</span> positive=n&gt;<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">double</span> ret=  fastpow(x,nn);</span><br><span class="line">        <span class="keyword">if</span>(!positive)</span><br><span class="line">            ret=<span class="number">1</span>/ret;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">fastpow</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> ret=fastpow(x,n/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            ret=ret*ret;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ret=ret*ret*x;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-成员初始化"><a href="#3-成员初始化" class="headerlink" title="3.成员初始化"></a>3.成员初始化</h2><ul><li><p>静态常量成员</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NUM = <span class="number">5</span>;<span class="comment">// 静态int常量成员初始化,仅仅为声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> B::NUM;<span class="comment">//类外定义！！！！</span></span><br><span class="line">nt bb = B::NUM;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NUM ;<span class="comment">// 静态int常量成员初始化</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> B::NUM=<span class="number">5</span>;<span class="comment">//类外定义</span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">float</span> NUM = <span class="number">5</span>;<span class="comment">// 静态float常量成员初始化失败！！！！！！！</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">float</span> NUM ;<span class="comment">// 静态float常量成员初始化失败！！！！！！！</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> B::NUM=<span class="number">5</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="4-操作符重载"><a href="#4-操作符重载" class="headerlink" title="4. 操作符重载"></a>4. 操作符重载</h2><ul><li><p>运算符重载是针对C++原有运算符进行的，不可能通过重载创造出新的运算符 </p><p>除了 </p><p>.             （成员访问运算符）</p><p> .*            （成员指针访问运算符）  </p><p> ::             （域运算符）  </p><p> sizeof    （长度运算符）  </p><p>?:            （条件运算符）这5个运算符外，其他运算符都可以重载</p></li></ul><h2 id="5-取余操作"><a href="#5-取余操作" class="headerlink" title="5. 取余操作"></a>5. 取余操作</h2><ul><li>除号的正负取舍和一般的算数一样，符号相同为正，相异为负<br> 求余符号的正负取舍和被除数符号相同<br> -3/16=0     16/-3=-5     -3%16=-3      16%-3=1</li></ul><h2 id="6-函数重载"><a href="#6-函数重载" class="headerlink" title="6 函数重载"></a>6 函数重载</h2><ul><li><p>原则是 函数名称，参数个数，参数类型</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff</span><span class="params">(<span class="keyword">int</span> a)</span><span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* p)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff</span><span class="params">( <span class="keyword">int</span>* <span class="keyword">const</span> p)</span> </span>&#123;&#125; <span class="comment">// void ff(int*  p) &#123;&#125;// 冲突</span></span><br><span class="line"><span class="comment">//void ff(int*  p) &#123;&#125;// error</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff</span><span class="params">(<span class="keyword">int</span> a)</span><span class="keyword">const</span> </span>&#123;&#125; <span class="comment">//修饰this指针</span></span><br><span class="line"><span class="comment">//this 原型Type * const this; </span></span><br><span class="line"><span class="comment">//修饰后 const Type * const this; </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C++规定</span></span><br><span class="line"><span class="comment">重载函数的指针形参</span></span><br><span class="line"><span class="comment">如果要以const进行区分</span></span><br><span class="line"><span class="comment">只有当修饰的const为底层const</span></span><br><span class="line"><span class="comment">而非顶层const时才可以区分</span></span><br><span class="line"><span class="comment">也就是说 const必须修饰指针指向的对象而非指针本身 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++11，trivial </tag>
            
            <tag> 零碎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构补全计划</title>
      <link href="/2019/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/"/>
      <url>/2019/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<ul><li>数据结构补全计划</li></ul><a id="more"></a><h1 id="1-二叉树"><a href="#1-二叉树" class="headerlink" title="1 二叉树"></a>1 二叉树</h1><ul><li><p>非递归式遍历</p></li><li><p><a href="https://www.jianshu.com/p/49c8cfd07410" target="_blank" rel="noopener">https://www.jianshu.com/p/49c8cfd07410</a></p></li><li><p>前序遍历</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="built_in">stack</span>&lt;pair&lt;TreeNode*,<span class="keyword">bool</span>&gt;&gt; mystack;</span><br><span class="line">        mystack.push(&#123;root,<span class="literal">false</span>&#125;);<span class="comment">//</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> visited;</span><br><span class="line">        <span class="keyword">while</span>(!mystack.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            root=mystack.top().first;</span><br><span class="line">            visited=mystack.top().second;</span><br><span class="line">            mystack.pop();</span><br><span class="line">            <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(visited)</span><br><span class="line">            &#123;</span><br><span class="line">                ret.push_back(root-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;<span class="comment">// 中 左 右</span></span><br><span class="line">                mystack.push(&#123;root-&gt;right,<span class="literal">false</span>&#125;);</span><br><span class="line">                mystack.push(&#123;root-&gt;left,<span class="literal">false</span>&#125;);</span><br><span class="line">                mystack.push(&#123;root,<span class="literal">true</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>中序遍历</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">         <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">         <span class="built_in">stack</span>&lt; pair&lt;TreeNode *, <span class="keyword">bool</span>&gt; &gt; s;</span><br><span class="line">        s.push(make_pair(root, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">bool</span> visited;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            root = s.top().first;</span><br><span class="line">            visited = s.top().second;</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(visited)</span><br><span class="line">            &#123;</span><br><span class="line">                path.push_back(root-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                s.push(make_pair(root-&gt;right, <span class="literal">false</span>));<span class="comment">// 变换三个的 true false 实现 前序 中序 后序 遍历</span></span><br><span class="line">                s.push(make_pair(root, <span class="literal">true</span>));</span><br><span class="line">                s.push(make_pair(root-&gt;left, <span class="literal">false</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>后序遍历</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="built_in">stack</span>&lt;pair&lt;TreeNode*,<span class="keyword">bool</span>&gt;&gt; mystack;</span><br><span class="line">        mystack.push(&#123;root,<span class="literal">false</span>&#125;);</span><br><span class="line">        <span class="keyword">bool</span> visited;</span><br><span class="line">        <span class="keyword">while</span>(!mystack.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            root=mystack.top().first;</span><br><span class="line">            visited=mystack.top().second;</span><br><span class="line">            mystack.pop();</span><br><span class="line">            <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(visited)</span><br><span class="line">            &#123;</span><br><span class="line">                ret.push_back(root-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//左 右 中</span></span><br><span class="line">            &#123;</span><br><span class="line">                mystack.push(&#123;root,<span class="literal">true</span>&#125;);</span><br><span class="line">                mystack.push(&#123;root-&gt;right,<span class="literal">false</span>&#125;);</span><br><span class="line">                mystack.push(&#123;root-&gt;left,<span class="literal">false</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>中序遍历添加null</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric_error</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">       dfs(root,ret);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sz=ret.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz/<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ret[i]!=ret[sz<span class="number">-1</span>-i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ret)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//if(root==nullptr)</span></span><br><span class="line">        <span class="comment">//   return;</span></span><br><span class="line">       <span class="keyword">if</span> (root != <span class="literal">nullptr</span> &amp;&amp; !(root-&gt;left==<span class="literal">nullptr</span> &amp;&amp; root-&gt;right==<span class="literal">nullptr</span>))<span class="comment">// 能够继续往下迭代 传递nullptr的只有 左右节点不同时为Nullptr的节点</span></span><br><span class="line">    dfs(root-&gt;left, ret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>)</span><br><span class="line">            ret.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ret.push_back(INT_MAX);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span> &amp;&amp; !(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>))</span><br><span class="line">            dfs(root-&gt;right, ret);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">比如输入 1 2 3 4 nullptr 5 nullptr</span></span><br><span class="line"><span class="comment">输出 4 2 nullptr 1 5 3 nullptr</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">K层二叉树为满二叉树时最多，此时</span><br><span class="line">共有 <span class="number">2</span>^k<span class="number">-1</span>个节点</span><br><span class="line">第i层有<span class="number">2</span>^(i<span class="number">-1</span>)个节点</span><br><span class="line">叶子节点数为<span class="number">2</span>^(K<span class="number">-1</span>)</span><br><span class="line">如果为完全二叉树，此时一般会考叶子节点数</span><br><span class="line">一般设度为零的节点为n0、度为<span class="number">1</span>的节点为n1、度为<span class="number">2</span>的节点为n2，那么有</span><br><span class="line">n0+n1+n2 = 节点总数N</span><br><span class="line">n0 = n2+<span class="number">1</span></span><br><span class="line">n1 + <span class="number">2</span>*n2 = n<span class="number">-1</span></span><br></pre></td></tr></table></figure></li><li></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> data structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++对象模型探索-1</title>
      <link href="/2019/07/13/object-model/"/>
      <url>/2019/07/13/object-model/</url>
      
        <content type="html"><![CDATA[<ul><li>底层实现</li><li>深度探索C++对象模型<a id="more"></a><h1 id="C-对象模型探索"><a href="#C-对象模型探索" class="headerlink" title="C++对象模型探索"></a>C++对象模型探索</h1></li></ul><h2 id="1-类对象占用的空间"><a href="#1-类对象占用的空间" class="headerlink" title="1. 类对象占用的空间"></a>1. 类对象占用的空间</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line">A a;</span><br><span class="line"><span class="comment">//sizeof(A)=sizeof(a)=1;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">A a;</span><br><span class="line"><span class="keyword">sizeof</span>(A)=<span class="keyword">sizeof</span>(a)=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//sizeof(a)=1; 1 为char num的内存空间</span></span><br><span class="line"><span class="comment">//&amp;a=&amp;a.num</span></span><br><span class="line"><span class="comment">//a地址中的数为q</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//sizeof(a)=4; 4 为int num的内存空间</span></span><br></pre></td></tr></table></figure><ul><li>类成员函数不占用类对象的内存空间</li><li>空类大小为1个字节,空类存在首地址</li><li>成员变量包含在每个对象中，占用类对象的内存空间</li><li>成员函数 跟着类走，不是类对象，不管类产生了多少个类对象</li></ul><h2 id="2-对象结构的发展和演化"><a href="#2-对象结构的发展和演化" class="headerlink" title="2. 对象结构的发展和演化"></a>2. 对象结构的发展和演化</h2><ul><li>非静态的成员变量（普通成员变量）跟着类对象走（存在类对象内部），每个类对象都有自己的成员变量</li><li>静态成员变量和对象没关系，不会保存在类对象内部，保存在对象外面</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sa;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">sizeof</span>(A)=<span class="number">4</span>=<span class="keyword">sizeof</span>(a.num)</span><br></pre></td></tr></table></figure><ul><li>成员函数无论静态函数非静态保存在类对象外部，都不占用类对象</li><li><strong>存在虚函数，类对象多占4个字节</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sa;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sb;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">sizeof</span>(a)=<span class="number">4</span>+<span class="number">4</span>=<span class="number">8</span>;</span><br></pre></td></tr></table></figure><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><ul><li>类里只要有一个虚函数，这个类A产生一个指向虚函数表的指针，四个字节</li><li>一个虚函数对应一个指针，这些指针放到虚函数表里 virtual table VTBL</li><li>虚函数表基于类，而不是类对象</li><li>类对象。虚函数存在，系统在类对象中添加了一个 指针VPTR，指向虚函数表</li><li>VPTR由编译器适当时机添加（比如 构造函数）</li></ul><hr><ul><li>静态数据成员不计算在类对象的sizeof中</li><li>普通成员函数和静态成员函数不计算在类对象的sizeof中</li><li>虚函数不计算在类对象的sizeof中，但是虚函数会让类对象sizeof增加4个字节，容纳虚函数表指针。</li><li>VTBL基于类，和对象没有关系，不是基于对象的</li><li>如果有多个数据成员，为了提高访问速度，某些编译器可能将数据成员之间的内存占用比例进行调整，存在内存字节对齐问题。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">int</span> integer;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">sizeof</span>(a)=<span class="number">8</span>;<span class="comment">//4个字节对齐</span></span><br></pre></td></tr></table></figure><ul><li><strong>不管什么类型指针，这个指针的占用内存固定 比如4个字节</strong><ul><li>非静态成员变量和内存对齐</li><li>虚函数表指针</li></ul></li></ul><h2 id="3-This指针调整"><a href="#3-This指针调整" class="headerlink" title="3. This指针调整"></a>3. This指针调整</h2><ul><li>存在多重继承</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">A() &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;A= %p \n"</span>,<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;A= %p \n"</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> sa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">B() &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;B= %p \n"</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;B= %p \n"</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span><span class="keyword">public</span> A,<span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">C()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;C= %p \n"</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;C= %p \n"</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">C myc;</span><br><span class="line">myc.funcA();<span class="comment">//</span></span><br><span class="line">myc.funcB();<span class="comment">//</span></span><br><span class="line">myc.funcC();<span class="comment">//</span></span><br><span class="line"><span class="comment">//&amp;A= 006FFC44</span></span><br><span class="line"><span class="comment">//&amp;B= 006FFC48</span></span><br><span class="line"><span class="comment">//&amp;C= 006FFC44</span></span><br><span class="line"><span class="comment">//&amp;A= 006FFC44</span></span><br><span class="line"><span class="comment">//&amp;B= 006FFC48</span></span><br><span class="line"><span class="comment">//&amp;C= 006FFC44</span></span><br><span class="line"><span class="comment">//&amp;C=&amp;A</span></span><br></pre></td></tr></table></figure><ul><li><p>派生类对象是包含基类子对象的</p></li><li><p>如果派生类只从一个类派生的，派生类对象地址和基类子对象的地址相同</p></li><li><p>如果继承多个，第一个基类子对象的开始地址和派生类对象开始地址相同，后续这类基类子对象的开始地址和派生类对象的开始地址相差多少</p><ul><li>把第一个<strong>基类子对象</strong>所占用的地址</li></ul></li><li><p>如果C类覆盖B中方法，C中调用B中方法时，this指针不变</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">A() &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;A= %p \n"</span>,<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;A= %p \n"</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">B() &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;B= %p \n"</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;B= %p \n"</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span><span class="keyword">public</span> A,<span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">C()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;C= %p \n"</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;C= %p \n"</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;C B= %p \n"</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">C myc;</span><br><span class="line">myc.funcA();</span><br><span class="line">myc.funcB();</span><br><span class="line">myc.B::funcB();</span><br><span class="line">myc.funcC();</span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">//0</span></span><br></pre></td></tr></table></figure><hr><ul><li>调用哪个子类的成员函数，这个this指针就会被调整到对象子类的开始地址</li></ul><h2 id="4-分析obj-构造函数语义"><a href="#4-分析obj-构造函数语义" class="headerlink" title="4. 分析obj,构造函数语义"></a>4. 分析obj,构造函数语义</h2><ul><li>默认构造函数，没有参数的构造函数</li><li>如果没有定义任何构造函数，编译器就会隐式提供默认构造函数，即合成的默认构造函数</li><li><strong>合成的默认构造函数，只有在必要的时候，编译器才会为我们提供，而不是必然</strong></li></ul><ul><li>每个CPP编译生成一个.obj(.o)文件 linux -c，最终把很多obj文件链接到一起生成exe文件</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MATXP</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MBTX</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"MBTXTEST"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>VS2015 开发人员命令 dumpbin /all main.obj &gt; main.txt</li><li>main.txt COFF格式，通用对象文件格式</li><li>main.txt没有MBTX::MBTX 默认构造函数</li></ul><hr><ul><li>合成构造函数</li><li><strong>Condition1:</strong><ul><li>*<em>该MBTX类没有任何构造函数，但包含一个类对象成员，而该对象所属的类有一个缺省的构造函数，为了调用MATX的默认构造函数，为MBTX生成一个合成默认构造函数 *</em></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MATX</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MATX() &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"MATX"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MBTX</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">MATX ma;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"MBTXTEST"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                                               Symbol    Symbol</span><br><span class="line">Offset    Type              Applied To         Index     Name</span><br><span class="line">--------  ----------------  -----------------  --------  ------</span><br><span class="line"><span class="number">0000002</span>A  REL32                      <span class="number">00000000</span>        <span class="number">8</span>D  ??<span class="number">0</span>MATX@@QAE@XZ (<span class="keyword">public</span>: __thiscall MATX::MATX(<span class="keyword">void</span>))</span><br><span class="line"><span class="number">00000035</span>  REL32                      <span class="number">00000000</span>        <span class="number">90</span>  ??<span class="number">0</span>M0TX@@QAE@XZ (<span class="keyword">public</span>: __thiscall M0TX::M0TX(<span class="keyword">void</span>))</span><br><span class="line"><span class="number">00000048</span>  REL32                      <span class="number">00000000</span>        <span class="number">9</span>A  __RTC_CheckEsp</span><br></pre></td></tr></table></figure><ul><li><p>先定义MATX，先调用MATX构造函数</p></li><li><p><strong>Condition2</strong></p><ul><li><strong>一个父类带缺省构造函数，子类没有任何构造函数，这个缺省的构造函数要被调用，编译器会为这个子类合成出一个默认构造函数，合成目的，为了调用父类的构造函数</strong></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MTX_BASE</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MTX_BASE()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"MTX_BASE"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MTX_CHILD</span> :</span><span class="keyword">public</span> MTX_BASE&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_i;</span><br><span class="line"><span class="keyword">int</span> m_j;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">60501020</span> flags</span><br><span class="line">         Code</span><br><span class="line">         COMDAT; sym= <span class="string">"public: __thiscall MTX_CHILD::MTX_CHILD(void)"</span> (??<span class="number">0</span>MTX_CHILD@@QAE@XZ)</span><br><span class="line">         <span class="number">16</span> byte align</span><br><span class="line">         Execute Read</span><br></pre></td></tr></table></figure><ul><li>Condition3:<ul><li>如果一个类有虚函数，没有构造函数时</li><li>虚函数存在，编译器生成虚函数表VTBL，在合成构造函数里，把类的虚函数表地址，赋值给类对象的虚函数表指针。（赋值语句）</li><li>MTX_CHILD2有父类，有缺省构造函数<ul><li>生成MTX_CHILD2的虚函数表vftable</li><li>调用父类的构造函数</li><li>将MTX_CHILD2类的虚函数表地址赋值给MTX_CHILD2类对象的虚函数表指针</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MTX_CHILD2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>  <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"MTX_CHILD2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">60501020</span> flags</span><br><span class="line">         Code</span><br><span class="line">         COMDAT; sym= <span class="string">"public: __thiscall MTX_CHILD2::MTX_CHILD2(void)"</span> (??<span class="number">0</span>MTX_CHILD2@@QAE@XZ)</span><br><span class="line">         <span class="number">16</span> byte align</span><br><span class="line">         Execute Read</span><br><span class="line"></span><br><span class="line">RAW DATA #<span class="number">9</span></span><br><span class="line">  <span class="number">00000000</span>: <span class="number">55</span> <span class="number">8B</span> EC <span class="number">81</span> EC CC <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">53</span> <span class="number">56</span> <span class="number">57</span> <span class="number">51</span> <span class="number">8</span>D BD <span class="number">34</span>  U.¨¬.¨¬¨¬...SVWQ.?<span class="number">4</span></span><br><span class="line">  <span class="number">00000010</span>: FF FF FF B9 <span class="number">33</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> B8 CC CC CC CC F3 AB <span class="number">59</span>  ???<span class="number">13.</span>..?¨¬¨¬¨¬¨¬¨®?Y</span><br><span class="line">  <span class="number">00000020</span>: <span class="number">89</span> <span class="number">4</span>D F8 <span class="number">8B</span> <span class="number">45</span> F8 C7 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">8B</span> <span class="number">45</span> F8 <span class="number">5F</span>  .M?.E??......E?_</span><br><span class="line">  <span class="number">00000030</span>: <span class="number">5</span>E <span class="number">5B</span> <span class="number">8B</span> E5 <span class="number">5</span>D C3                                ^[.?]?</span><br><span class="line"></span><br><span class="line">RELOCATIONS #<span class="number">9</span></span><br><span class="line">                                                Symbol    Symbol</span><br><span class="line"> Offset    Type              Applied To         Index     Name</span><br><span class="line"> --------  ----------------  -----------------  --------  ------</span><br><span class="line"> <span class="number">00000028</span>  DIR32                      <span class="number">00000000</span>        C2  ??_7MTX_CHILD2@@<span class="number">6B</span>@ (<span class="keyword">const</span> MTX_CHILD2::`vftable')<span class="comment">//赋值</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MTX_CHILD2</span>:</span><span class="keyword">public</span> MTX_BASE &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_i;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>  <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"MTX_CHILD2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">MTX_CHILD2()</span><br><span class="line">&#123;</span><br><span class="line">m_i = <span class="number">15</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Offset    Type              Applied To         Index     Name</span><br><span class="line">--------  ----------------  -----------------  --------  ------</span><br><span class="line"><span class="number">0000002</span>A  REL32                      <span class="number">00000000</span>        <span class="number">8</span>E  ??<span class="number">0</span>MTX_BASE@@QAE@XZ (<span class="keyword">public</span>: __thiscall MTX_BASE::MTX_BASE(<span class="keyword">void</span>))</span><br><span class="line"><span class="number">00000033</span>  DIR32                      <span class="number">00000000</span>        CD  ??_7MTX_CHILD2@@<span class="number">6B</span>@ (<span class="keyword">const</span> MTX_CHILD2::`vftable')</span><br><span class="line"><span class="number">00000050</span>  REL32                      <span class="number">00000000</span>        <span class="number">9B</span>  __RTC_CheckEsp</span><br></pre></td></tr></table></figure><ul><li><strong>Condition4</strong><ul><li>一个类带有虚基类，编译器也会合成默认构造函数</li><li>虚基类，通过两个直接基类继承同一个间接基类。</li><li>vbtable 虚基类表 vftable虚函数表</li><li></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GRAND</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PARENT1</span> :</span><span class="keyword">virtual</span> <span class="keyword">public</span> GRAND &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PARENT2</span> :</span><span class="keyword">virtual</span> <span class="keyword">public</span> GRAND &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CHILD</span> :</span><span class="keyword">public</span> PARENT1, <span class="keyword">public</span> PARENT2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">60501020</span> flags</span><br><span class="line">         Code</span><br><span class="line">         COMDAT; sym= <span class="string">"public: __thiscall CHILD::CHILD(void)"</span> (??<span class="number">0</span>CHILD@@QAE@XZ)</span><br><span class="line">         <span class="number">16</span> byte align</span><br><span class="line">         Execute Read</span><br><span class="line"> Offset    Type              Applied To         Index     Name</span><br><span class="line"> --------  ----------------  -----------------  --------  ------</span><br><span class="line"> <span class="number">0000002</span>E  DIR32                      <span class="number">00000000</span>        <span class="number">49</span>  ??_8CHILD@@<span class="number">7B</span>PARENT1@@@ (<span class="keyword">const</span> CHILD::`vbtable'&#123;<span class="keyword">for</span> `PARENT1'&#125;)</span><br><span class="line"> <span class="number">00000038</span>  DIR32                      <span class="number">00000000</span>        <span class="number">4</span>D  ??_8CHILD@@<span class="number">7B</span>PARENT2@@@ (<span class="keyword">const</span> CHILD::`vbtable'&#123;<span class="keyword">for</span> `PARENT2'&#125;)</span><br><span class="line"> <span class="number">00000042</span>  REL32                      <span class="number">00000000</span>        <span class="number">32</span>  ??<span class="number">0</span>PARENT1@@QAE@XZ (<span class="keyword">public</span>: __thiscall PARENT1::PARENT1(<span class="keyword">void</span>))</span><br><span class="line"> <span class="number">0000004F</span>  REL32                      <span class="number">00000000</span>        <span class="number">33</span>  ??<span class="number">0</span>PARENT2@@QAE@XZ (<span class="keyword">public</span>: __thiscall PARENT2::PARENT2(<span class="keyword">void</span>))</span><br><span class="line"> <span class="number">00000062</span>  REL32                      <span class="number">00000000</span>        <span class="number">38</span>  __RTC_CheckEsp</span><br></pre></td></tr></table></figure><h2 id="7-拷贝构造函数语义"><a href="#7-拷贝构造函数语义" class="headerlink" title="7. 拷贝构造函数语义"></a>7. 拷贝构造函数语义</h2><ul><li>传统上，没有定义一个拷贝构造，编译器会在必要时，提供合成的拷贝构造函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_num;</span><br><span class="line">&#125;;</span><br><span class="line">A mya1;</span><br><span class="line">mya1.m_num = <span class="number">13</span>;</span><br><span class="line">A mya2 = mya1;</span><br></pre></td></tr></table></figure><ul><li>上述没有合成拷贝构造函数，编译器内部成员变量初始化，直接按值拷贝</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> mb_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B b;</span><br><span class="line"><span class="keyword">int</span> ma_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A mya1;</span><br><span class="line">mya1.ma_num = <span class="number">13</span>;</span><br><span class="line">mya1.b.mb_num = <span class="number">7</span>;</span><br><span class="line">A mya2 = mya1;</span><br></pre></td></tr></table></figure><ul><li>上述没有合成拷贝构造函数</li><li>A mya2 = mya1; 拷贝构造一个对象，编译器直接拷贝数据，如果A中有类对象类型变量，类似递归式拷贝类B中成员变量。</li></ul><p>编译器合成拷贝构造函数，什么时候，干什么</p><ul><li><strong>Condition1</strong><ul><li>类A没有拷贝构造，含有一个类对象类型的成员变量，其有拷贝构造函数，当代码有涉及A的拷贝构造时</li><li>B也需要默认构造</li><li>编译器合成的拷贝构造只干一些特殊的事，如果只是类似成员变量拷贝，编译器不合成拷贝构造</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> mb_num;</span><br><span class="line">B(<span class="keyword">const</span> B&amp; B_)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"B copy construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">B()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B b;</span><br><span class="line"><span class="keyword">int</span> ma_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A mya1;</span><br><span class="line">mya1.ma_num = <span class="number">13</span>;</span><br><span class="line">mya1.b.mb_num = <span class="number">7</span>;</span><br><span class="line">A mya2 = mya1;<span class="comment">//去掉就没有 合成拷贝构造</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">60501020</span> flags</span><br><span class="line">         Code</span><br><span class="line">         COMDAT; sym= <span class="string">"public: __thiscall A::A(class A const &amp;)"</span> (??<span class="number">0</span>A@@QAE@ABV0@@Z)</span><br><span class="line">         <span class="number">16</span> byte align</span><br><span class="line">         Execute Read</span><br></pre></td></tr></table></figure><ul><li>Condition2<ul><li>如果一个类没有拷贝构造，父类有拷贝构造，当代码中又涉及到类的拷贝构造时，编译器合成拷贝构造函数</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> mb_num;</span><br><span class="line">B(<span class="keyword">const</span> B&amp; B_)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"B copy construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">B()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B_SON</span>:</span><span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">B_SON b;</span><br><span class="line">b.mb_num = <span class="number">1</span>;</span><br><span class="line">B_SON b2 = b;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">60501020</span> flags</span><br><span class="line">         Code</span><br><span class="line">         COMDAT; sym= <span class="string">"public: __thiscall B_SON::B_SON(class B_SON const &amp;)"</span> (??<span class="number">0B</span>_SON@@QAE@ABV0@@Z)</span><br><span class="line">         <span class="number">16</span> byte align</span><br><span class="line">         Execute Read</span><br></pre></td></tr></table></figure><ul><li>Condition3<ul><li>类B没有拷贝构造，继承或声明了虚函数，当代码中又涉及到类的拷贝构造时</li><li>在拷贝构造函数里，将类虚函数表地址 赋值给类对象虚函数表指针</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class B_SON</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void  func()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt;&quot;B_SON&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">60501020</span> flags</span><br><span class="line">         Code</span><br><span class="line">         COMDAT; sym= <span class="string">"public: __thiscall B_SON::B_SON(class B_SON const &amp;)"</span> (??<span class="number">0B</span>_SON@@QAE@ABV0@@Z)</span><br><span class="line">         <span class="number">16</span> byte align</span><br><span class="line">         Execute Read</span><br><span class="line">         </span><br><span class="line">RELOCATIONS #<span class="number">9</span></span><br><span class="line">                                                Symbol    Symbol</span><br><span class="line"> Offset    Type              Applied To         Index     Name</span><br><span class="line"> --------  ----------------  -----------------  --------  ------</span><br><span class="line"> <span class="number">00000028</span>  DIR32                      <span class="number">00000000</span>        CA  ??_7B_SON@@<span class="number">6B</span>@ (<span class="keyword">const</span> B_SON::`vftable')</span><br></pre></td></tr></table></figure><ul><li>Condition4<ul><li>没有拷贝构造，该类有虚基类，涉及到类对象的拷贝构造时</li><li>GRAND没有合成拷贝构造，PARENT1,PARENT2 CHILD合成拷贝构造</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GRAND</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PARENT1</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> GRAND &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PARENT2</span> :</span><span class="keyword">virtual</span> <span class="keyword">public</span> GRAND &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CHILD</span> :</span> <span class="keyword">public</span> PARENT1,<span class="keyword">public</span> PARENT2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RELOCATIONS #<span class="number">4</span></span><br><span class="line">                                                Symbol    Symbol</span><br><span class="line"> Offset    Type              Applied To         Index     Name</span><br><span class="line"> --------  ----------------  -----------------  --------  ------</span><br><span class="line"> <span class="number">0000002</span>E  DIR32                      <span class="number">00000000</span>        <span class="number">5F</span>  ??_8CHILD@@<span class="number">7B</span>PARENT1@@@ (<span class="keyword">const</span> CHILD::`vbtable'&#123;<span class="keyword">for</span> `PARENT1'&#125;)</span><br><span class="line"> <span class="number">00000038</span>  DIR32                      <span class="number">00000000</span>        <span class="number">63</span>  ??_8CHILD@@<span class="number">7B</span>PARENT2@@@ (<span class="keyword">const</span> CHILD::`vbtable'&#123;<span class="keyword">for</span> `PARENT2'&#125;)</span><br><span class="line"> <span class="number">00000069</span>  REL32                      <span class="number">00000000</span>        <span class="number">45</span>  ??<span class="number">0</span>PARENT1@@QAE@ABV0@@Z (<span class="keyword">public</span>: __thiscall PARENT1::PARENT1(class PARENT1 <span class="keyword">const</span> &amp;))</span><br><span class="line"> <span class="number">0000009B</span>  REL32                      <span class="number">00000000</span>        <span class="number">47</span>  ??<span class="number">0</span>PARENT2@@QAE@ABV0@@Z (<span class="keyword">public</span>: __thiscall PARENT2::PARENT2(class PARENT2 <span class="keyword">const</span> &amp;))</span><br></pre></td></tr></table></figure><h2 id="8-程序转换语义"><a href="#8-程序转换语义" class="headerlink" title="8. 程序转换语义"></a>8. 程序转换语义</h2><ul><li>代码会被编译器拆分，编译器更容易理解和实现</li></ul><ol><li>定义时初始化</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_i;</span><br><span class="line">X()</span><br><span class="line">&#123;</span><br><span class="line">m_i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">X(<span class="keyword">const</span> X&amp; X_)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"copy construct"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">X x0;</span><br><span class="line">x0.m_i = <span class="number">2</span>;</span><br><span class="line">X x1 = x0;</span><br><span class="line"><span class="function">X <span class="title">x2</span><span class="params">(x0)</span></span>;</span><br><span class="line">X x3=(x0);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">X x100=(x0); 编译器拆分两部</span></span><br><span class="line"><span class="comment">X x100;                1.定义对象，分配内存，没有调用构造函数</span></span><br><span class="line"><span class="comment">x100::X::X(x0);        2. 调用对象拷贝构造</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>参数初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_i;</span><br><span class="line">X()</span><br><span class="line">&#123;</span><br><span class="line">m_i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">X(<span class="keyword">const</span> X&amp; X_)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"copy construct"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~X()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deconstruct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(X x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">X x0;</span><br><span class="line">func(x0);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">construct</span></span><br><span class="line"><span class="comment">copy construct</span></span><br><span class="line"><span class="comment">deconstruct</span></span><br><span class="line"><span class="comment">deconstruct</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">老编译器</span></span><br><span class="line"><span class="comment">X tempobj；//     1.一个临时对象</span></span><br><span class="line"><span class="comment">tempobj.X::X(x0); 2. 临时对象拷贝构造</span></span><br><span class="line"><span class="comment">func(tempobj)     3.</span></span><br><span class="line"><span class="comment">func(X&amp; temoobj)  4. 参数变为引用</span></span><br><span class="line"><span class="comment">tempobj.X::~X()   5. 析构</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>返回值初始化</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">X x0;</span><br><span class="line"><span class="keyword">return</span> x0;</span><br><span class="line">&#125;</span><br><span class="line">X my=func();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">construct</span></span><br><span class="line"><span class="comment">copy construct</span></span><br><span class="line"><span class="comment">deconstruct</span></span><br><span class="line"><span class="comment">deconstruct</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">编译器</span></span><br><span class="line"><span class="comment">X my; //1 生成对象，不调用构造函数</span></span><br><span class="line"><span class="comment">func2(my);</span></span><br><span class="line"><span class="comment">void func2(X&amp; my)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">X x0;// 不调用构造函数</span></span><br><span class="line"><span class="comment">my.X::X(x0);// 拷贝构造</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func2().func_test();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">编译器</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">X my;  //1 生成对象，不调用构造函数</span></span><br><span class="line"><span class="comment">func2(my);</span></span><br><span class="line"><span class="comment">void func2(x&amp; my)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    X x0;// 不调用构造函数</span></span><br><span class="line"><span class="comment">my.X::X(x0);// 拷贝构造</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">(func2(my),my).func_test()//逗号表达式，</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">X (*pf) ();<span class="comment">//函数指针</span></span><br><span class="line">pf ()= func2();</span><br><span class="line">pf().func_test();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">X my;</span></span><br><span class="line"><span class="comment">void (*pf)(X&amp;);// 多一个引用参数</span></span><br><span class="line"><span class="comment">pf=func2;</span></span><br><span class="line"><span class="comment">pf(my);</span></span><br><span class="line"><span class="comment">my.functest();</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="9-程序的优化"><a href="#9-程序的优化" class="headerlink" title="9. 程序的优化"></a>9. 程序的优化</h2><ul><li>开发者VS 编译器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTempValue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> val1;</span><br><span class="line"><span class="keyword">int</span> val2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CTempValue(<span class="keyword">int</span> v1 = <span class="number">0</span>, <span class="keyword">int</span> v2 = <span class="number">0</span>)</span><br><span class="line">:val1(v1), val2(v2) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">CTempValue(<span class="keyword">const</span> CTempValue&amp; t)</span><br><span class="line">:val1(t.val1), val2(t.val2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"copy construct"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~CTempValue()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deconstruct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">CTempValue <span class="title">Double</span><span class="params">(CTempValue &amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CTempValue tempm;<span class="comment">//一个构造 一个析构</span></span><br><span class="line">tempm.val1 = t.val1;</span><br><span class="line">tempm.val2 = t.val2;</span><br><span class="line"><span class="keyword">return</span> tempm;<span class="comment">//一个临时对象， 拷贝构造 返回临时对象，一个析构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CTempValue <span class="title">ts1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">Double(ts1);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">construct</span></span><br><span class="line"><span class="comment">construct</span></span><br><span class="line"><span class="comment">copy construct</span></span><br><span class="line"><span class="comment">deconstruct</span></span><br><span class="line"><span class="comment">deconstruct</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="开发者优化"><a href="#开发者优化" class="headerlink" title="开发者优化"></a>开发者优化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CTempValue <span class="title">Double</span><span class="params">(CTempValue &amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//CTempValue tempm;//一个构造 一个析构</span></span><br><span class="line"><span class="comment">//tempm.val1 = t.val1*2;</span></span><br><span class="line"><span class="comment">//tempm.val2 = t.val2*2;</span></span><br><span class="line"><span class="comment">//return tempm;//一个临时对象， 拷贝构造 返回临时对象，一个析构</span></span><br><span class="line"><span class="keyword">return</span> CTempValue(t.val1*<span class="number">2</span>,t.val2*<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">CTempValue <span class="title">ts1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">Double(ts1);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">construct</span></span><br><span class="line"><span class="comment">construct//构造对象</span></span><br><span class="line"><span class="comment">deconstruct// -----------这个析构 因为Double返回的对象没有人接</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">编译器</span></span><br><span class="line"><span class="comment">void Double(CTempValue&amp; temp,CTempValue&amp; ts1)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">temp.CTempValue::CTempValue(ts1.val1,ts1.val2);</span></span><br><span class="line"><span class="comment">return ;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">CTempValue ts1;</span></span><br><span class="line"><span class="comment">ts1.CTempValue::CTempValue(10,20);</span></span><br><span class="line"><span class="comment">CTempValue tempobj;</span></span><br><span class="line"><span class="comment">Double(tempboj,ts1);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h4><ul><li><p>GCC 编译器优化 针对于返回临时对象NRV 优化 named return value</p></li><li>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -fno-elide-constructors <span class="number">2</span>_8.cpp -o <span class="number">2</span>_8<span class="comment">//禁止优化</span></span><br></pre></td></tr></table></figure></li><li><p>编译器是否优化，需要测试</p></li><li><p>编译器优化 有可能出错</p></li></ul><h2 id="10-程序优化续"><a href="#10-程序优化续" class="headerlink" title="10. 程序优化续"></a>10. 程序优化续</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_i;</span><br><span class="line">X(<span class="keyword">int</span> value)</span><br><span class="line">:m_i(value)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"construct(value)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">X()</span><br><span class="line">&#123;</span><br><span class="line">m_i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">X(<span class="keyword">const</span> X&amp; t)</span><br><span class="line">:m_i(t.m_i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"copy construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~X()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deconstruct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">X <span class="title">x10</span><span class="params">(<span class="number">1000</span>)</span></span>;<span class="comment">//编译器不优化时 最优</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">string</span>(<span class="number">20</span>,<span class="string">'-'</span>)&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">X x11=<span class="number">1000</span>;<span class="comment">///转换函数</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">string</span>(<span class="number">20</span>, <span class="string">'-'</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">X x12=X(<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">string</span>(<span class="number">20</span>, <span class="string">'-'</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">X x13 = (X)<span class="number">1000</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">string</span>(<span class="number">20</span>, <span class="string">'-'</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">construct(value)</span></span><br><span class="line"><span class="comment">--------------------</span></span><br><span class="line"><span class="comment">construct(value)</span></span><br><span class="line"><span class="comment">--------------------</span></span><br><span class="line"><span class="comment">construct(value)</span></span><br><span class="line"><span class="comment">--------------------</span></span><br><span class="line"><span class="comment">construct(value)</span></span><br><span class="line"><span class="comment">--------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">编译器 不优化</span></span><br><span class="line"><span class="comment">X x10;</span></span><br><span class="line"><span class="comment">x10.X::X(1000);//最优</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">X temp;</span></span><br><span class="line"><span class="comment">temp.X::X(1000)// 一个参数的构造函数</span></span><br><span class="line"><span class="comment">X X12；</span></span><br><span class="line"><span class="comment">x12.X::X(temp)//拷贝构造函数调用</span></span><br><span class="line"><span class="comment">temp.X::`X() //析构函数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>编译器面临用一个类对象作为另一个类对初值的情况，各个编译器表现不同，没办法确定编译器一定调用拷贝构造</li><li>拷贝构造不一定必须有，视情况而定</li><li>简单成员变量类型，int，double，不需要拷贝构造，编译器内部本身支持成员变量的bitwise（按位拷贝）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//X的拷贝构造 注释掉</span></span><br><span class="line"></span><br><span class="line">X x0;</span><br><span class="line">x0.m_i = <span class="number">150</span>;</span><br><span class="line"><span class="function">X <span class="title">x1</span><span class="params">(x0)</span></span>;<span class="comment">//调用拷贝构造</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;x1.m_i &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//编译器支持bitwise拷贝</span></span><br></pre></td></tr></table></figure><ul><li>当需要处理复杂的成员变量类型时候，指针成员</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">X(<span class="keyword">const</span> X&amp; t)</span><br><span class="line">    <span class="comment">//:m_i(t.m_i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// m_i = t.m_i;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"copy construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">X x0;</span><br><span class="line">x0.m_i = <span class="number">150</span>;</span><br><span class="line"><span class="function">X <span class="title">x1</span><span class="params">(x0)</span></span>;<span class="comment">//调用拷贝构造</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;x1.m_i &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//编译器支持bitwise拷贝    =====0</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当增加了自己的拷贝构造时，编译器的bitwise拷贝 失效，需要自己对成员变量的初始化负责；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="11-成员初始化列表"><a href="#11-成员初始化列表" class="headerlink" title="11 成员初始化列表"></a>11 成员初始化列表</h2><ul><li><p>何时必须用初始化列表</p><ul><li>如果这个成员是引用变量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_x;</span><br><span class="line"><span class="keyword">int</span> m_y;</span><br><span class="line"><span class="keyword">int</span> &amp;m_yy;</span><br><span class="line">A(<span class="keyword">int</span> &amp; tempvalue)</span><br><span class="line">:m_x(<span class="number">0</span>),m_y(<span class="number">0</span>),m_yy(tempvalue)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>如果类成员是const类型</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_x;</span><br><span class="line"><span class="keyword">int</span> m_y;</span><br><span class="line"><span class="keyword">int</span> &amp;m_yy;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> m_c;</span><br><span class="line">A(<span class="keyword">int</span> &amp; tempvalue)</span><br><span class="line">:m_x(<span class="number">0</span>),m_y(<span class="number">0</span>),m_yy(tempvalue),m_c(tempvalue)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>基类有构造函数，而且基类构造函数有参数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> ba;</span><br><span class="line"><span class="keyword">int</span> bb;</span><br><span class="line">B(<span class="keyword">int</span> tmpa, <span class="keyword">int</span> tmpb)</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span><span class="keyword">public</span> B </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_x;</span><br><span class="line"><span class="keyword">int</span> m_y;</span><br><span class="line"><span class="keyword">int</span> &amp;m_yy;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> m_c;</span><br><span class="line">A(<span class="keyword">int</span> &amp; tempvalue)</span><br><span class="line">:m_x(<span class="number">0</span>),m_y(<span class="number">0</span>),m_yy(tempvalue),m_c(tempvalue),B(tempvalue,tempvalue)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>成员变量类型为类类型，而类的构造函数有参数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Sub(<span class="keyword">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span><span class="keyword">public</span> B </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_x;</span><br><span class="line"><span class="keyword">int</span> m_y;</span><br><span class="line"><span class="keyword">int</span> &amp;m_yy;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> m_c;</span><br><span class="line">Sub sub;</span><br><span class="line">A(<span class="keyword">int</span> &amp; tempvalue)</span><br><span class="line">:m_x(<span class="number">0</span>),m_y(<span class="number">0</span>),m_yy(tempvalue),m_c(tempvalue),B(tempvalue,tempvalue),sub(tempvalue)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>使用初始化列表的优势</p><ul><li>提高程序运行效率</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_i;</span><br><span class="line">X(<span class="keyword">int</span> val = <span class="number">0</span>)<span class="comment">//类型转换构造函数</span></span><br><span class="line">:m_i(val)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"this =%p \n"</span>,<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"X(INT ) construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">X(<span class="keyword">const</span> X&amp; t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"this =%p \n"</span>, <span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"copy construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">X&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> X&amp; t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"this =%p \n"</span>, <span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"copy operator="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">~X()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"this =%p \n"</span>, <span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deconstruct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">X obj;</span><br><span class="line"><span class="keyword">int</span> m_test;</span><br><span class="line">A(<span class="keyword">int</span> temp)<span class="comment">// 构造 X obj  耗费了一次调用构造函数的机会</span></span><br><span class="line">        <span class="comment">// 编译器 X obj; obj.X::X();</span></span><br><span class="line">&#123;</span><br><span class="line">obj = <span class="number">1000</span>;<span class="comment">// 临时对象构造 拷贝构造 析构</span></span><br><span class="line">m_test = <span class="number">500</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">       编译器</span></span><br><span class="line"><span class="comment">        X temp;</span></span><br><span class="line"><span class="comment">        temp.X::X(1000) //构造函数</span></span><br><span class="line"><span class="comment">        obj.X::operator=(temp) //赋值运算</span></span><br><span class="line"><span class="comment">        temp.X::~X()//析构</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">this =004FFB1C X(int ) construct</span></span><br><span class="line"><span class="comment">this =004FF960 X(int ) construct</span></span><br><span class="line"><span class="comment">this =004FFB1C copy operator=</span></span><br><span class="line"><span class="comment">this =004FF960 deconstruct</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">X obj;</span><br><span class="line"><span class="keyword">int</span> m_test;</span><br><span class="line">A(<span class="keyword">int</span> temp)<span class="comment">// 构造 X</span></span><br><span class="line">:obj(<span class="number">1000</span>)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        X obj;</span></span><br><span class="line"><span class="comment">        obj.X::X(1000);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//obj = 1000;// 临时对象构造 拷贝构造 析构</span></span><br><span class="line">m_test = <span class="number">500</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">this =00CFFD3C X(int ) construct</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>将初始化列表看作函数体中一部分</li><li>对于类对象成员放到初始化成员列表中，效果明显</li></ul><ul><li><p>细节探究</p><ul><li>初始化列表中代码，可以看作是被编译器安插到构造函数体中</li><li>初始化列表中代码 在任何用户自己的构造函数体之前执行的</li><li>变量的初始化顺序是定义顺序，不是初始化列表中的调用顺序</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_i;</span><br><span class="line"><span class="keyword">int</span> m_i2;</span><br><span class="line">X(<span class="keyword">int</span> val = <span class="number">0</span>)<span class="comment">//类型转换构造函数</span></span><br><span class="line">:m_i2(val),m_i(m_i2)  <span class="comment">//出错m_i 先执行</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"this =%p "</span>,<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"X(int ) construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>不建议 初始化列表中成员变量的赋值</li></ul><h2 id="12-虚函数表指针位置分析"><a href="#12-虚函数表指针位置分析" class="headerlink" title="12 虚函数表指针位置分析"></a>12 虚函数表指针位置分析</h2><ul><li>类中有虚函数，该类会产生一个虚函数表，类对象有一个虚函数表指针VPTR，类似成员变量，占4个字节，指向虚函数表的开始地址</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> s_i;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">testfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(a);</span><br><span class="line"><span class="keyword">char</span> *p1 = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt; (&amp;a);</span><br><span class="line"><span class="keyword">char</span> *p2= <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt; (&amp;(a.i));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p1 == p2)<span class="comment">// a.i 和 a 地址相同， i在 虚函数表指针的上面</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p1&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>虚函数表指针 位于对象内存的头部</strong></li></ul><h2 id="13-继承关系下的虚函数的手工调用"><a href="#13-继承关系下的虚函数的手工调用" class="headerlink" title="13 继承关系下的虚函数的手工调用"></a>13 继承关系下的虚函数的手工调用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"base f"</span>&lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"base g"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"base h"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive  g"</span>&lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(Base)&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(Derive) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Derive *d = <span class="keyword">new</span> Derive();</span><br><span class="line"><span class="keyword">long</span> *pvptr = (<span class="keyword">long</span>*)d;<span class="comment">//指向对象的指针d   0x00d45dd0</span></span><br><span class="line"><span class="keyword">long</span> * vptr = (<span class="keyword">long</span>*)(*pvptr);<span class="comment">//(*pvptr)表示pvptr指向的对象 Derive对象本身 四个字节，代表虚函数表指针首地址</span></span><br><span class="line"><span class="comment">//(*pvptr)=0x002B9B60</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"vptr[%d]=0x:%p \n"</span>,i,vptr[i]);<span class="comment">// 肯定越界</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Func)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">Func f = (Func)vptr[<span class="number">0</span>];</span><br><span class="line">Func g = (Func)vptr[<span class="number">1</span>];</span><br><span class="line">Func h = (Func)vptr[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">f();</span><br><span class="line">g();</span><br><span class="line">h();</span><br><span class="line"></span><br><span class="line">Base *b = <span class="keyword">new</span> Base();</span><br><span class="line"><span class="keyword">long</span> *pvptr2 = (<span class="keyword">long</span>*)b;</span><br><span class="line"><span class="keyword">long</span> *vptr2 = (<span class="keyword">long</span>*)(*pvptr2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"vptr2[%d]=0x:%p \n"</span>, i, vptr2[i]);<span class="comment">// 肯定越界</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func f2 = (Func)vptr2[<span class="number">0</span>];</span><br><span class="line">Func g2 = (Func)vptr2[<span class="number">1</span>];</span><br><span class="line">Func h2= (Func)vptr2[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">f2();</span><br><span class="line">g2();</span><br><span class="line">h2();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">vptr= 00499B60</span></span><br><span class="line"><span class="comment">vptr[0]=0x:0049108C</span></span><br><span class="line"><span class="comment">vptr[1]=0x:00491091</span></span><br><span class="line"><span class="comment">vptr[2]=0x:004910E1</span></span><br><span class="line"><span class="comment">vptr[3]=0x:00000000</span></span><br><span class="line"><span class="comment">vptr[4]=0x:69726544</span></span><br><span class="line"><span class="comment">base f</span></span><br><span class="line"><span class="comment">Derive  g</span></span><br><span class="line"><span class="comment">base h</span></span><br><span class="line"><span class="comment">vptr2= 00499B34</span></span><br><span class="line"><span class="comment">vptr2[0]=0x:0049108C</span></span><br><span class="line"><span class="comment">vptr2[1]=0x:00491249</span></span><br><span class="line"><span class="comment">vptr2[2]=0x:004910E1</span></span><br><span class="line"><span class="comment">vptr2[3]=0x:00000000</span></span><br><span class="line"><span class="comment">vptr2[4]=0x:65736162</span></span><br><span class="line"><span class="comment">base f</span></span><br><span class="line"><span class="comment">base g</span></span><br><span class="line"><span class="comment">base h</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="14-虚函数表分析"><a href="#14-虚函数表分析" class="headerlink" title="14 虚函数表分析"></a>14 虚函数表分析</h2><p><img src="object-model/1563259723100.png" alt="1563259723100"></p><ul><li>一个类只有包含虚函数才会存在虚函数表，同属于一个类的对象共享虚函数表，但是有各自的vptr（虚函数表指针），当然所指向的地址（虚函数表首地址）相同。</li><li>父类中有虚函数，等于子类中有虚函数。父类中有虚函数表，子类中也有虚函数表，如果在子类中把父类中的虚函数去掉virtual，子类中仍然是虚函数。</li><li>但不管是子类还是父类，都只会有一个虚函数表，不能认为子类中有一个虚函数表+父类中有一个虚函数表，不能认为子类中有两个虚函数表</li><li>如果子类中没有新的虚函数，可以认为子类和父类的虚函数表内容相同，仅仅内容相同，在内存中处于不同位置，是内容相同的两张表，虚函数表中每一项保存着一个虚函数的首地址，但如果子类的虚函数表表项和父类的虚函数表某项代表同一个函数（表示子类没有覆盖父类的虚函数，则该表项指向的该函数地址相同）</li><li>超出虚函数表部分不可知</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Func)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">Derive derive;</span><br><span class="line"><span class="keyword">long</span> *pvptr_derive = (<span class="keyword">long</span>*)(&amp;derive);<span class="comment">//pvptr_derive = 0x001efbec &#123;0x00c69b60&#125;</span></span><br><span class="line"><span class="keyword">long</span> * vptrderive = (<span class="keyword">long</span>*)(*pvptr_derive);<span class="comment">//vptrderive = 0x00c69b60 &#123;class13_virtual_call_with_inherit.exe!const Derive::`vftable'&#125; &#123;0x00c6108c&#125;</span></span><br><span class="line">Func f1 = (Func)vptrderive[<span class="number">0</span>];<span class="comment">//f1 = 0x00c6108c &#123;class13_virtual_call_with_inherit.exe!Base::f(void)&#125;</span></span><br><span class="line">Func g1=(Func)vptrderive[<span class="number">1</span>];<span class="comment">//g1 = 0x00c61091 &#123;class13_virtual_call_with_inherit.exe!Derive::g(void)&#125;</span></span><br><span class="line">Func h1 = (Func)vptrderive[<span class="number">2</span>];</span><br><span class="line">Func i1 = (Func)vptrderive[<span class="number">3</span>];</span><br><span class="line">Func j1 = (Func)vptrderive[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">Derive derive2 = derive;</span><br><span class="line"><span class="keyword">long</span> *pvptr_derive2 = (<span class="keyword">long</span>*)(&amp;derive2);</span><br><span class="line"><span class="keyword">long</span> * vptr_derive2 = (<span class="keyword">long</span>*)(*pvptr_derive2);</span><br><span class="line"></span><br><span class="line">Base base = derive;<span class="comment">//子类赋值给父类，子类中属于父类的内容会被编译器自动区分（切割）出来，并拷贝给父类对象</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">生成base对象，并用derive对象初始化base对象，derive的虚函数表指针并没有覆盖base对象的虚函数表指针值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> *pvptr_base = (<span class="keyword">long</span>*)(&amp;base);<span class="comment">//pvptr_base = 0x001efb68 &#123;0x00c69b34&#125;</span></span><br><span class="line"><span class="keyword">long</span> * vptr_base = (<span class="keyword">long</span>*)(*pvptr_base);<span class="comment">//vptr_base = 0x00c69b34 &#123;class13_virtual_call_with_inherit.exe!const Base::`vftable'&#125; &#123;0x00c6108c&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Func bf1 = (Func)vptr_base[<span class="number">0</span>];<span class="comment">//bf1 = 0x00c6108c &#123;class13_virtual_call_with_inherit.exe!Base::f(void)&#125;</span></span><br><span class="line">Func bg1 = (Func)vptr_base[<span class="number">1</span>];<span class="comment">//bg1 = 0x00c61249 &#123;class13_virtual_call_with_inherit.exe!Base::g(void)&#125;</span></span><br><span class="line">Func bh1 = (Func)vptr_base[<span class="number">2</span>];<span class="comment">//bh1 = 0x00c610e1 &#123;class13_virtual_call_with_inherit.exe!Base::h(void)&#125;</span></span><br><span class="line">Func bi1 = (Func)vptr_base[<span class="number">3</span>];</span><br><span class="line">Func bj1 = (Func)vptr_base[<span class="number">4</span>];</span><br></pre></td></tr></table></figure><ul><li>OO面向对象，OB基于对象</li><li>C++通过类的指针和引用来实现多态，这就是面向对象</li><li>OB，也叫ADT，抽象数据模型，不支持多态。执行速度快，因为函数调用的解析不需要运行时决定，编译期间就已经完成，空间更紧凑</li><li>C++既支持OO，又支持OB</li></ul><h2 id="15-多重继承的虚函数表分析"><a href="#15-多重继承的虚函数表分析" class="headerlink" title="15 多重继承的虚函数表分析"></a>15 多重继承的虚函数表分析</h2><ul><li>多重继承的虚函数表</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"base1::f()"</span>&lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"base1::g()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"base2::h()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">i</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"base2::i()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base1,<span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::f()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">i</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::i()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mh</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::mh()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mi</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::mi()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mj</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::mj()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"base1: "</span> &lt;&lt; <span class="keyword">sizeof</span>(Base1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"base2: "</span> &lt;&lt; <span class="keyword">sizeof</span>(Base2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived: "</span> &lt;&lt; <span class="keyword">sizeof</span>(Derived) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//两个 虚函数表指针</span></span><br><span class="line"></span><br><span class="line">Derived ins;</span><br><span class="line">Base1 &amp;b1 = ins;</span><br><span class="line">Base2 &amp;b2 = ins;</span><br><span class="line">Derived&amp; d = ins;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Func)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">long</span> * pderived1 = (<span class="keyword">long</span>*)(&amp;ins);<span class="comment">//pderived1 = 0x00b4f9f4 &#123;0x00a39b94&#125;</span></span><br><span class="line"><span class="keyword">long</span> *vptr1 = (<span class="keyword">long</span>*)(*pderived1); <span class="comment">//第一个虚函数表指针vptr1 = 0x00a39b94 &#123;class14_multi_inherit.exe!const Derived::`vftable'&#123;for `Base1'&#125;&#125; &#123;0x00a31271&#125;</span></span><br><span class="line"><span class="keyword">long</span> * pderived2 = pderived1 + <span class="number">1</span>;<span class="comment">//pderived2 = 0x00b4f9f8 &#123;0x00a39bb0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> *vptr2 = (<span class="keyword">long</span>*)(*pderived2);<span class="comment">//vptr2 = 0x00a39bb0 &#123;class14_multi_inherit.exe!const Derived::`vftable'&#123;for `Base2'&#125;&#125; &#123;0x00a313e3&#125;</span></span><br><span class="line"></span><br><span class="line">Func f1 = (Func)vptr1[<span class="number">0</span>];<span class="comment">//f1 = 0x00a31271 &#123;class14_multi_inherit.exe!Derived::f(void)&#125;</span></span><br><span class="line">Func f2 = (Func)vptr1[<span class="number">1</span>];<span class="comment">//f2 = 0x00a3125d &#123;class14_multi_inherit.exe!Base1::g(void)&#125;</span></span><br><span class="line">Func f3 = (Func)vptr1[<span class="number">2</span>];<span class="comment">//f3 = 0x00a311bd &#123;class14_multi_inherit.exe!Derived::mh(void)&#125;</span></span><br><span class="line">Func f4 = (Func)vptr1[<span class="number">3</span>];<span class="comment">//f4 = 0x00a312ee &#123;class14_multi_inherit.exe!Derived::mi(void)&#125;</span></span><br><span class="line">Func f5 = (Func)vptr1[<span class="number">4</span>];<span class="comment">//f5 = 0x00a3112c &#123;class14_multi_inherit.exe!Derived::mj(void)&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Func f11 = (Func)vptr2[<span class="number">0</span>];<span class="comment">//f11 = 0x00a313e3 &#123;class14_multi_inherit.exe!Base2::h(void)&#125;</span></span><br><span class="line">Func f21= (Func)vptr2[<span class="number">1</span>];<span class="comment">//f21 = 0x00a311f9 &#123;class14_multi_inherit.exe!Derived::i(void)&#125;</span></span><br><span class="line">Func f31 = (Func)vptr2[<span class="number">2</span>];<span class="comment">//f31 = 0x00000000</span></span><br><span class="line">Func f41 = (Func)vptr2[<span class="number">3</span>];</span><br><span class="line">Func f51 = (Func)vptr2[<span class="number">4</span>];</span><br></pre></td></tr></table></figure><ul><li><p><strong>一个对象，如果有多个基类，则该子类有多个虚函数表指针</strong>，一<strong>个虚函数表，对应各个基类中的vptr按继承顺序依次放置在类的内存空间中，且子类与第一个基类公用一个vptr</strong>(第二个基类有自己的vptr)</p></li><li><p>适合VS2015 ,不适合GCC linux</p><ul><li><img src="object-model/1563275212420.png" alt="1563275212420"></li></ul></li><li><p>子类对象ins有两个虚函数表指针，</p></li><li><p>类Derived有两个虚函数表</p></li><li><p>子类和第一个基类共用一个vptr，（vptr指向一个虚函数表，所以也可以说子类和第一个基类公用一个虚函数表vtbl)，类Derived的虚函数表1中的5个函数，g正好为Base1中函数</p></li><li><p>子类中虚函数覆盖了父类中的同名虚函数</p></li></ul><h2 id="16-辅助工具、vpt、vtbl创建时机"><a href="#16-辅助工具、vpt、vtbl创建时机" class="headerlink" title="16 辅助工具、vpt、vtbl创建时机"></a>16 辅助工具、vpt、vtbl创建时机</h2><ul><li><p>开发者命令行窗口 cl.exe</p></li><li><p>“第一”</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl /d1 reportSingleClassLayoutDerived main.cpp</span><br></pre></td></tr></table></figure></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Derived   size(8):</span><br><span class="line">        +---</span><br><span class="line"> <span class="number">0</span>      | +--- (base class Base1)</span><br><span class="line"> <span class="number">0</span>      | | &#123;vfptr&#125;</span><br><span class="line">        | +---</span><br><span class="line"> <span class="number">4</span>      | +--- (base class Base2)</span><br><span class="line"> <span class="number">4</span>      | | &#123;vfptr&#125;</span><br><span class="line">        | +---</span><br><span class="line">        +---</span><br><span class="line"></span><br><span class="line">Derived::$vftable@Base1@:</span><br><span class="line">        | &amp;Derived_meta</span><br><span class="line">        |  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>      | &amp;Derived::f</span><br><span class="line"> <span class="number">1</span>      | &amp;Base1::g</span><br><span class="line"> <span class="number">2</span>      | &amp;Derived::mh</span><br><span class="line"> <span class="number">3</span>      | &amp;Derived::mi</span><br><span class="line"> <span class="number">4</span>      | &amp;Derived::mj</span><br><span class="line"></span><br><span class="line">Derived::$vftable@Base2@:</span><br><span class="line">        | <span class="number">-4</span></span><br><span class="line"> <span class="number">0</span>      | &amp;Base2::h</span><br><span class="line"> <span class="number">1</span>      | &amp;Derived::i</span><br><span class="line"></span><br><span class="line">Derived::f <span class="keyword">this</span> adjustor: <span class="number">0</span></span><br><span class="line">Derived::i <span class="keyword">this</span> adjustor: <span class="number">4</span></span><br><span class="line">Derived::mh <span class="keyword">this</span> adjustor: <span class="number">0</span></span><br><span class="line">Derived::mi <span class="keyword">this</span> adjustor: <span class="number">0</span></span><br><span class="line">Derived::mj <span class="keyword">this</span> adjustor: <span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -fdump-<span class="class"><span class="keyword">class</span>-<span class="title">hierarchy</span> -<span class="title">fsyntax</span>-<span class="title">only</span> <span class="title">main</span>.<span class="title">cpp</span></span></span><br><span class="line"><span class="class">//生成.<span class="title">class</span>文件</span></span><br></pre></td></tr></table></figure></li><li><p>vptr什么时候创建的，<strong>vptr跟着对象走，对象创建的时候（运行时）</strong></p></li><li><p>对于有虚函数的类，<strong>编译器在构造函数中添加代码，为vptr赋值的代码，（在编译期间）</strong></p></li><li><p><strong>创建对象时，执行构造函数，赋值vptr，可看作成员变量</strong></p></li></ul><hr><ul><li>虚函数表是编译器在<strong>编译期间</strong>，（obj .o文件）为每个类确定了对象的虚函数表中的内容，在<strong>编译期间</strong>添加给vptr赋值的代码，调用构造函数，</li></ul><p><img src="object-model/B3mENrq.png" alt="B3mENrq"></p><h2 id="17-单纯的类不纯时引发的虚函数调用问题"><a href="#17-单纯的类不纯时引发的虚函数调用问题" class="headerlink" title="17 单纯的类不纯时引发的虚函数调用问题"></a>17 单纯的类不纯时引发的虚函数调用问题</h2><ul><li>单纯的类： 不包含虚函数和虚基类</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">int</span> z;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">X()</span></span><br><span class="line"><span class="comment">:x(0), y(0), z(0)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt;"X construct" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">X()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"X construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">memset</span>(<span class="keyword">this</span>,<span class="number">0</span>,<span class="keyword">sizeof</span>(X));<span class="comment">//OK</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">X(const X&amp; t)</span></span><br><span class="line"><span class="comment">:x(t.x), y(t.y), z(t.z)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; "X copy construct" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">X(<span class="keyword">const</span> X&amp; t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(<span class="keyword">this</span>, &amp;t, <span class="keyword">sizeof</span>(X));<span class="comment">//OK</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"X copy construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>如果类不单纯，使用memset,memcpy出现崩溃</li><li>不单纯，某些情况下，编译器在类内中增加些代码，某些隐藏成员变量。这种隐藏成员变量的增加（使用）赋值，均在执行构造函数或拷贝构造函数之前进行。如果使用memset memcpy使得编译器给隐藏变量的值清空或覆盖</li><li>比如增加虚函数，编译器增加虚函数表指针（隐藏的成员变量）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">int</span> z;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">X()</span></span><br><span class="line"><span class="comment">:x(0), y(0), z(0)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt;"X construct" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line">X()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//vptr=vtbl// memset将vptr清零</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"X construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">memset</span>(<span class="keyword">this</span>,<span class="number">0</span>,<span class="keyword">sizeof</span>(X));<span class="comment">//OK</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">X(const X&amp; t)</span></span><br><span class="line"><span class="comment">:x(t.x), y(t.y), z(t.z)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; "X copy construct" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">X(<span class="keyword">const</span> X&amp; t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(<span class="keyword">this</span>, &amp;t, <span class="keyword">sizeof</span>(X));<span class="comment">//OK</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"X copy construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~X()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"X deconstruct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">virtual_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"X virtual func"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"X  func"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">X x0;<span class="comment">//__vfptr = 0x00000000 &#123;???, ???&#125;</span></span><br><span class="line">x0.x = <span class="number">100</span>;</span><br><span class="line">x0.y = <span class="number">200</span>;</span><br><span class="line">x0.z = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">x0.virtual_func();<span class="comment">//栈中创建对象，即使vptr=0依然可以调用虚函数</span></span><br><span class="line"></span><br><span class="line"><span class="function">X <span class="title">x1</span><span class="params">(x0)</span></span>;<span class="comment">//__vfptr = 0x00000000 &#123;???, ???&#125;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;x1.x&lt;&lt;<span class="string">" "</span>&lt;&lt;x1.y&lt;&lt;<span class="string">" "</span>&lt;&lt;x1.z &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">X* px0 = <span class="keyword">new</span> X();<span class="comment">//new 出对象,vptr=0 虚函数无法调用</span></span><br><span class="line">px0-&gt;func(); <span class="comment">//OK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//px0-&gt;virtual_func();//fail  读取位置 0x00000000 时发生访问冲突</span></span><br><span class="line"><span class="keyword">delete</span> px0;<span class="comment">//调用px0-&gt;~X()异常; 读取位置 0x00000000 时发生访问冲突</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">X construct</span></span><br><span class="line"><span class="comment">X virtual func</span></span><br><span class="line"><span class="comment">X copy construct</span></span><br><span class="line"><span class="comment">100 200 300</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><p>虚函数表指针为空</p></li><li><p>只有虚函数，没有继承。虚函数和普通函数无区别</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">9</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;i= %p \n"</span>,&amp;i);</span><br><span class="line">X x1;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"x::func =%p\n"</span>,&amp;X::func);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">long *pvptr=(long*) &amp;x1;</span></span><br><span class="line"><span class="comment">long* vptr = (long*) (*pvptr);</span></span><br><span class="line"><span class="comment">printf("virtual_func =%p\n",vptr[1]);//按其定义顺序，第一个为析构函数</span></span><br><span class="line"><span class="comment">// */</span></span><br><span class="line">x1.func();</span><br><span class="line">x1.virtual_func();</span><br><span class="line"><span class="comment">// 推断func 和virtual_func 函数地址在编译时就已经确定了</span></span><br><span class="line">x1.func();</span><br><span class="line"><span class="number">00782989</span>  lea         ecx,[x1]  </span><br><span class="line"><span class="number">0078298</span>C  call        X::func (<span class="number">07814</span>A1h)  </span><br><span class="line">x1.virtual_func();</span><br><span class="line"><span class="number">00782991</span>  lea         ecx,[x1]  </span><br><span class="line"><span class="number">00782994</span>  call        X::virtual_func (<span class="number">07813</span>CAh)</span><br></pre></td></tr></table></figure><ul><li><strong>静态联编，编译时就可以确定调用哪个函数，知道函数地址，把调用语句和被调用函数绑定在一起</strong></li><li>动态联编，程序运行时根据实际情况，动态把调用语句和被调用函数绑定，一般只在多态和虚函数情况下存在。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">X* pX0 = <span class="keyword">new</span> X();</span><br><span class="line">pX0-&gt;func();</span><br><span class="line">pX0-&gt;virtual_func();<span class="comment">//__vfptr = 0x00000000 &#123;???, ???&#125;</span></span><br><span class="line"><span class="comment">//通过虚函数表指针，找到虚函数表，找到virtual_func中函数地址</span></span><br><span class="line"></span><br><span class="line">pX0-&gt;func();</span><br><span class="line"><span class="number">00B</span>E29EC  mov         ecx,dword ptr [pX0]  </span><br><span class="line"><span class="number">00B</span>E29EF  call        X::func (<span class="number">0B</span>E14A1h)  </span><br><span class="line">pX0-&gt;virtual_func();</span><br><span class="line"><span class="number">00B</span>E29F4  mov         eax,dword ptr [pX0]  </span><br><span class="line"><span class="number">00B</span>E29F7  mov         edx,dword ptr [eax]  </span><br><span class="line"><span class="number">00B</span>E29F9  mov         esi,esp  </span><br><span class="line"><span class="number">00B</span>E29FB  mov         ecx,dword ptr [pX0]  </span><br><span class="line"><span class="number">00B</span>E29FE  mov         eax,dword ptr [edx+<span class="number">4</span>]  </span><br><span class="line"><span class="number">00B</span>E2A01  call        eax  </span><br><span class="line"><span class="number">00B</span>E2A03  cmp         esi,esp  </span><br><span class="line"><span class="number">00B</span>E2A05  call        __RTC_CheckEsp (<span class="number">0B</span>E11A9h)</span><br></pre></td></tr></table></figure></li></ul><h2 id="18-数据成员绑定时机"><a href="#18-数据成员绑定时机" class="headerlink" title="18 数据成员绑定时机"></a>18 数据成员绑定时机</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">string</span> myvar;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> myvar;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> myvar;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>编译器对成员函数myfunc的解析是在A类定义完毕后才开始的,定义完毕后，才可以看到A中myvar</li><li>对myvar的解析和绑定是在这个类定义完毕后开始的</li><li>成员函数中的myvar解析为成员，全局函数中的myvar解析成全局myvar</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> myvar;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> myvar;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myfunc</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*&#123;</span></span><br><span class="line"><span class="comment">return myvar;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> A::myfunc()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ::myvar&lt;&lt; <span class="built_in">endl</span>;<span class="comment">//全局</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; myvar &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> myvar;<span class="comment">// 仍然是局部的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> myvar; <span class="comment">//全局 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">string</span> mytype;</span><br><span class="line"><span class="built_in">string</span> myvar=<span class="string">"global str"</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//typedef int mytype;</span></span><br><span class="line">mytype m_value;</span><br><span class="line"><span class="keyword">int</span> myvar;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//void myfunc(mytype val)//string 声明顺序</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">(mytype val)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> mytype;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//void A::myfunc(mytype val)//报错</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><ul><li>对于成员函数参数，是在编译器第一次遇到mytype时确定的,mytype第一次遇到时，只看到typedef string mytype;为了在类中尽早看到类型定义语句typedef，挪到类的开头</li></ul><h2 id="19-进程内存空间布局"><a href="#19-进程内存空间布局" class="headerlink" title="19 进程内存空间布局"></a>19 进程内存空间布局</h2><ul><li>不同数据在内存中有不同的保存时机，保存位置</li><li>当运行一个可执行文件时，操作系统将可执行文件加载到内存，此时进程有一个虚拟的地址空间</li></ul><p><img src="object-model/20181009105508560.png" alt="20181009105508560"></p><p><img src="object-model/20190517215414850.png" alt="20190517215414850"></p><ul><li>正文段 即代码段</li><li>BSS段，未被初始化的数据段，不带初值的变量，或者初始化为0的全局量，每次运行不变</li><li>初始化的数据段，初始化的变量，全局量，每次运行不变</li><li>函数中变量堆栈中，每次运行变化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptest = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">120</span>);</span><br><span class="line"><span class="keyword">int</span> g1;</span><br><span class="line"><span class="keyword">int</span> g2;</span><br><span class="line"><span class="keyword">int</span> g3 = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> g4 = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">int</span> g5;</span><br><span class="line"><span class="keyword">int</span> g6 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g7;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g8 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g9 = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MYACLS</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_i;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_si;<span class="comment">//声明</span></span><br><span class="line"><span class="keyword">int</span> m_j;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_sj;</span><br><span class="line"><span class="keyword">int</span> m_k;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_sk;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> MYACLS::m_sj = <span class="number">0</span>;<span class="comment">//定义</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ptest= %p \n"</span>, &amp;ptest);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;g1= %p \n"</span>,&amp;g1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;g2= %p \n"</span>, &amp;g2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;g3= %p \n"</span>, &amp;g3);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;g4= %p \n"</span>, &amp;g4);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;g5= %p \n"</span>, &amp;g5);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;g6= %p \n"</span>, &amp;g6);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;g7= %p \n"</span>, &amp;g7);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;g8= %p \n"</span>, &amp;g8);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;g9= %p \n"</span>, &amp;g9);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;MYACLS::m_sj = %p \n"</span>, &amp;(MYACLS::m_sj));</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;myfunc = %p \n"</span>, myfunc);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;main = %p \n"</span>, main);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"&amp;myfunc = "</span>&lt;&lt;(<span class="keyword">void</span>*)myfunc &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//cout 打印函数指针</span></span><br></pre></td></tr></table></figure><ul><li>linux 下 nm命令列出可执行文件中全局变量存放的地址</li><li>nm 4_2</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">linux 下 nm </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>全局地址 不变，</li></ul><h2 id="20-数据成员布局"><a href="#20-数据成员布局" class="headerlink" title="20 数据成员布局"></a>20 数据成员布局</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MYACLS</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_i;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_si;<span class="comment">//静态成员变量在类中仅仅是声明</span></span><br><span class="line"><span class="keyword">int</span> m_j;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_sj;</span><br><span class="line"><span class="keyword">int</span> m_k;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_sk;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MYACLS myobj;<span class="comment">//myobj = &#123;m_i=2 m_j=5 m_k=8 &#125;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(myobj)&lt;&lt; <span class="built_in">endl</span>;<span class="comment">//12 bytes</span></span><br><span class="line">myobj.m_i = <span class="number">2</span>;</span><br><span class="line">myobj.m_j = <span class="number">5</span>;</span><br><span class="line">myobj.m_k = <span class="number">8</span>;</span><br></pre></td></tr></table></figure><ul><li>普通变量的存储顺序是在类中的定义顺序决定的</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x007AFE90</span>  <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">08</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> cc cc cc cc b4 fe <span class="number">7</span>a <span class="number">00</span> <span class="number">9</span>e <span class="number">1f</span>  ............??????z.?.</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">MYACLS myobj;<span class="comment">//myobj = &#123;m_i=2 m_j=5 m_k=8 &#125;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(myobj)&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">myobj.m_i = <span class="number">2</span>;</span><br><span class="line">myobj.m_j = <span class="number">5</span>;</span><br><span class="line">myobj.m_k = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;myobj.m_i= %p \n"</span>,&amp;myobj.m_i);<span class="comment">//栈中分配</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;myobj.m_j= %p \n"</span>, &amp;myobj.m_j);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;myobj.m_k= %p \n"</span>, &amp;myobj.m_k);</span><br><span class="line"></span><br><span class="line">MYACLS *pmyobj = <span class="keyword">new</span> MYACLS();<span class="comment">//堆中分配</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;pmyobj-&gt;m_i= %p \n"</span>,&amp;pmyobj-&gt;m_i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;pmyobj-&gt;m_j= %p \n"</span>, &amp;pmyobj-&gt;m_j);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;pmyobj-&gt;m_k= %p \n"</span>, &amp;pmyobj-&gt;m_k);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&amp;myobj.m_i= 0115F98C</span></span><br><span class="line"><span class="comment">&amp;myobj.m_j= 0115F990</span></span><br><span class="line"><span class="comment">&amp;myobj.m_k= 0115F994</span></span><br><span class="line"><span class="comment">&amp;pmyobj-&gt;m_i= 0141FD50</span></span><br><span class="line"><span class="comment">&amp;pmyobj-&gt;m_j= 0141FD54</span></span><br><span class="line"><span class="comment">&amp;pmyobj-&gt;m_k= 0141FD58</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><p>晚出现变量有较高地址，和Public，private数量无关</p></li><li><p>边界调整，字节对齐</p><ul><li><p>某些因素导致成员变量之间排列不连续，目的是提高效率，编译器自动调整</p></li><li><p>在成员之间填补一些字节，使用sizeof凑成一个4/8的整数倍</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MYACLS</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_i;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_si;<span class="comment">//静态成员变量在类中仅仅是声明</span></span><br><span class="line"><span class="keyword">int</span> m_j;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_sj;</span><br><span class="line"><span class="keyword">int</span> m_k;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_sk;</span><br><span class="line"><span class="keyword">char</span> m_c;</span><br><span class="line"><span class="keyword">int</span> m_n;</span><br><span class="line">&#125;;</span><br><span class="line">MYACLS myobj;<span class="comment">//myobj = &#123;m_i=2 m_j=5 m_k=8 &#125;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(myobj)&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">myobj.m_i = <span class="number">2</span>;</span><br><span class="line">myobj.m_j = <span class="number">5</span>;</span><br><span class="line">myobj.m_k = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;myobj.m_i= %p \n"</span>,&amp;myobj.m_i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;myobj.m_j= %p \n"</span>, &amp;myobj.m_j);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;myobj.m_k= %p \n"</span>, &amp;myobj.m_k);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;myobj.m_c= %p \n"</span>, &amp;myobj.m_c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;myobj.m_n= %p \n"</span>, &amp;myobj.m_n);</span><br><span class="line"></span><br><span class="line">MYACLS *pmyobj = <span class="keyword">new</span> MYACLS();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;pmyobj-&gt;m_i= %p \n"</span>,&amp;pmyobj-&gt;m_i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;pmyobj-&gt;m_j= %p \n"</span>, &amp;pmyobj-&gt;m_j);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;pmyobj-&gt;m_k= %p \n"</span>, &amp;pmyobj-&gt;m_k);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;pmyobj-&gt;m_c= %p \n"</span>, &amp;pmyobj-&gt;m_c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;pmyobj-&gt;m_n= %p \n"</span>, &amp;pmyobj-&gt;m_n);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&amp;myobj.m_i= 0095FA98</span></span><br><span class="line"><span class="comment">&amp;myobj.m_j= 0095FA9C</span></span><br><span class="line"><span class="comment">&amp;myobj.m_k= 0095FAA0</span></span><br><span class="line"><span class="comment">&amp;myobj.m_c= 0095FAA4</span></span><br><span class="line"><span class="comment">&amp;myobj.m_n= 0095FAA8</span></span><br><span class="line"><span class="comment">&amp;pmyobj-&gt;m_i= 00A66268</span></span><br><span class="line"><span class="comment">&amp;pmyobj-&gt;m_j= 00A6626C</span></span><br><span class="line"><span class="comment">&amp;pmyobj-&gt;m_k= 00A66270</span></span><br><span class="line"><span class="comment">&amp;pmyobj-&gt;m_c= 00A66274</span></span><br><span class="line"><span class="comment">&amp;pmyobj-&gt;m_n= 00A66278</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>为统一字节对齐问题，引入一字节对齐概念（不对齐）</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1)<span class="comment">//1 字节对齐</span></span></span><br><span class="line"><span class="meta">#prarma pack()<span class="comment">// 取消自定义对齐方式，恢复默认</span></span></span><br></pre></td></tr></table></figure></li><li><p>1个地址 对应一个字节？？？？？？？？？？！！！！！！！！！,四个字节，地址相差4？？？</p></li><li></li><li><p>虚函数，添加vptr虚函数表指针（内部数据成员）,虚函数表指针位于开头或末尾</p></li></ul></li><li><p>成员变量偏移值，离对象开头首地址偏移多少</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MYACLS</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_i;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_si;<span class="comment">//静态成员变量在类中仅仅是声明</span></span><br><span class="line"><span class="keyword">int</span> m_j;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_sj;</span><br><span class="line"><span class="keyword">int</span> m_k;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_sk;</span><br><span class="line"><span class="keyword">char</span> m_c;<span class="comment">//1个字节</span></span><br><span class="line"><span class="keyword">int</span> m_n;<span class="comment">//4个字节</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_pria;</span><br><span class="line"><span class="keyword">int</span> m_prib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"-----the offset of data member----"</span>&lt;&lt; <span class="built_in">endl</span>;<span class="comment">//偏移量和类对象关系不大</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;MYACLS.m_i= %p \n"</span>, &amp;MYACLS::m_i);<span class="comment">//偏移量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;MYACLS.m_j= %p \n"</span>, &amp;MYACLS::m_j);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;MYACLS.m_k= %p \n"</span>, &amp;MYACLS::m_k);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;MYACLS.m_c= %p \n"</span>, &amp;MYACLS::m_c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;MYACLS.m_n= %p \n"</span>, &amp;MYACLS::m_n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;MYACLS.m_pria= %p \n"</span>, &amp;MYACLS::m_pria);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;MYACLS.m_prib= %p \n"</span>, &amp;MYACLS::m_prib);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"---------------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-----the offset of data member----</span></span><br><span class="line"><span class="comment">&amp;MYACLS.m_i= 00000000</span></span><br><span class="line"><span class="comment">&amp;MYACLS.m_j= 00000004</span></span><br><span class="line"><span class="comment">&amp;MYACLS.m_k= 00000008</span></span><br><span class="line"><span class="comment">&amp;MYACLS.m_c= 0000000C</span></span><br><span class="line"><span class="comment">&amp;MYACLS.m_n= 00000010</span></span><br><span class="line"><span class="comment">&amp;MYACLS.m_pria= 00000014</span></span><br><span class="line"><span class="comment">&amp;MYACLS.m_prib= 00000018</span></span><br><span class="line"><span class="comment">---------------------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//另一种打印偏移量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET(A,m) (int)(&amp;((A*)0)-&gt;m)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; GET(MYACLS,m_prib) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加上虚函数后</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MYACLS</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_i;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_si;<span class="comment">//静态成员变量在类中仅仅是声明</span></span><br><span class="line"><span class="keyword">int</span> m_j;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_sj;</span><br><span class="line"><span class="keyword">int</span> m_k;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_sk;</span><br><span class="line"><span class="keyword">char</span> m_c;<span class="comment">//1个字节</span></span><br><span class="line"><span class="keyword">int</span> m_n;<span class="comment">//4个字节</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_pria;</span><br><span class="line"><span class="keyword">int</span> m_prib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"-----the offset of data member----"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;MYACLS.m_i= %p \n"</span>, &amp;MYACLS::m_i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;MYACLS.m_j= %p \n"</span>, &amp;MYACLS::m_j);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;MYACLS.m_k= %p \n"</span>, &amp;MYACLS::m_k);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;MYACLS.m_c= %p \n"</span>, &amp;MYACLS::m_c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;MYACLS.m_n= %p \n"</span>, &amp;MYACLS::m_n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;MYACLS.m_pria= %p \n"</span>, &amp;MYACLS::m_pria);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;MYACLS.m_prib= %p \n"</span>, &amp;MYACLS::m_prib);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"---------------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; GET(MYACLS, m_prib) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///*</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>  <span class="title">myfv</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">32</span></span><br><span class="line"><span class="comment">&amp;myobj.m_i= 005EFB9C</span></span><br><span class="line"><span class="comment">&amp;myobj.m_j= 005EFBA0</span></span><br><span class="line"><span class="comment">&amp;myobj.m_k= 005EFBA4</span></span><br><span class="line"><span class="comment">&amp;myobj.m_c= 005EFBA8</span></span><br><span class="line"><span class="comment">&amp;myobj.m_n= 005EFBAC</span></span><br><span class="line"><span class="comment">&amp;pmyobj-&gt;m_i= 008160D4</span></span><br><span class="line"><span class="comment">&amp;pmyobj-&gt;m_j= 008160D8</span></span><br><span class="line"><span class="comment">&amp;pmyobj-&gt;m_k= 008160DC</span></span><br><span class="line"><span class="comment">&amp;pmyobj-&gt;m_c= 008160E0</span></span><br><span class="line"><span class="comment">&amp;pmyobj-&gt;m_n= 008160E4</span></span><br><span class="line"><span class="comment">-----the offset of data member----</span></span><br><span class="line"><span class="comment">&amp;MYACLS.m_i= 00000004</span></span><br><span class="line"><span class="comment">&amp;MYACLS.m_j= 00000008</span></span><br><span class="line"><span class="comment">&amp;MYACLS.m_k= 0000000C</span></span><br><span class="line"><span class="comment">&amp;MYACLS.m_c= 00000010</span></span><br><span class="line"><span class="comment">&amp;MYACLS.m_n= 00000014</span></span><br><span class="line"><span class="comment">&amp;MYACLS.m_pria= 00000018</span></span><br><span class="line"><span class="comment">&amp;MYACLS.m_prib= 0000001C</span></span><br><span class="line"><span class="comment">---------------------------------</span></span><br><span class="line"><span class="comment">28</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//另一种打印成员偏移</span></span><br><span class="line"><span class="keyword">int</span> MYACLS::*mypoint = &amp;MYACLS::m_n;<span class="comment">//定义成员变量指针</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;pmyobj-&gt;m_n= %p \n"</span>, mypoint);</span><br></pre></td></tr></table></figure></li></ul><h2 id="21-数据成员存取"><a href="#21-数据成员存取" class="headerlink" title="21 数据成员存取"></a>21 数据成员存取</h2><ul><li>静态成员变量，可以当作全局变量，只在类的空间内可见，MYACLS::m_si</li><li>静态成员变量只有一个实体，保存在可执行文件数据段</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MYACLS</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_i;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_si;</span><br><span class="line"><span class="keyword">int</span> m_j;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> MYACLS::m_si = <span class="number">10</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">MYACLS myobj;</span></span><br><span class="line"><span class="comment">MYACLS *pmobj = new MYACLS();</span></span><br><span class="line"><span class="comment">cout &lt;&lt; myobj.m_si&lt;&lt; endl;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; MYACLS::m_si &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; pmobj-&gt;m_si &lt;&lt; endl;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">printf("myobj.m_i = %p\n",&amp;myobj.m_i);</span></span><br><span class="line"><span class="comment">printf("pmobj-&gt;m_i = %p\n", &amp;pmobj-&gt;m_i);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">printf("MYACLS::m_si = %p\n", &amp;MYACLS::m_si);</span></span><br><span class="line"><span class="comment">printf("myobj.m_si = %p\n", &amp;myobj.m_si);</span></span><br><span class="line"><span class="comment">printf("pmobj-&gt;m_si = %p\n", &amp;pmobj-&gt;m_si);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">myobj.m_i = 0110FBE4</span></span><br><span class="line"><span class="comment">pmobj-&gt;m_i = 014B04E8</span></span><br><span class="line"><span class="comment">MYACLS::m_si = 0100A000</span></span><br><span class="line"><span class="comment">myobj.m_si = 0100A000</span></span><br><span class="line"><span class="comment">pmobj-&gt;m_si = 0100A000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">myobj.m_i = 00EFFE44 //堆栈中每次都发生变化</span></span><br><span class="line"><span class="comment">pmobj-&gt;m_i = 0108F860</span></span><br><span class="line"><span class="comment">MYACLS::m_si = 0100A000//数据段中每次地址都一样</span></span><br><span class="line"><span class="comment">myobj.m_si = 0100A000</span></span><br><span class="line"><span class="comment">pmobj-&gt;m_si = 0100A000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><p>非静态成员变量，存放在类的对象中，存取通过类对象（类对象指针）</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*成员函数</span></span><br><span class="line"><span class="comment">void func()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    m_i = 5;</span></span><br><span class="line"><span class="comment">     m_j = 6;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">pmyobj-&gt;func();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">MYACLS::func(pmyobj)</span></span><br><span class="line"><span class="comment">void MYACLS::func(MYACLS* const this)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">this.m_i=5;</span></span><br><span class="line"><span class="comment">this.m_j=6;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>对于普通成员变量访问，编译器将类对象的首地址+成员变量的偏移值访问</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&amp;myobj+sizeof(m_i)=&amp;m_j</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">m_i = 5;</span></span><br><span class="line"><span class="comment">00D51983  mov         eax,dword ptr [this]  </span></span><br><span class="line"><span class="comment">00D51986  mov         dword ptr [eax],5  </span></span><br><span class="line"><span class="comment">m_j = 6;</span></span><br><span class="line"><span class="comment">00D5198C  mov         eax,dword ptr [this]  </span></span><br><span class="line"><span class="comment">00D5198F  mov         dword ptr [eax+4],6 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>存在父类时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FAC</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_fai;</span><br><span class="line"><span class="keyword">int</span> m_faj;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MYACLS</span> :</span><span class="keyword">public</span> FAC&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_i;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_si;</span><br><span class="line"><span class="keyword">int</span> m_j;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_i = <span class="number">5</span>;</span><br><span class="line">m_j = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"MYACLS::m_i = %p\n"</span>, &amp;MYACLS::m_i);<span class="comment">//0 变为了 8</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>虚基类中成员变量访问间接</p></li><li><p>通过对象访问成员，通过对象指针访问</p><h2 id="22-单一继承下的数据成员布局"><a href="#22-单一继承下的数据成员布局" class="headerlink" title="22 单一继承下的数据成员布局"></a>22 单一继承下的数据成员布局</h2></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FAC</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_fai;</span><br><span class="line"><span class="keyword">int</span> m_faj;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MYACLS</span> :</span><span class="keyword">public</span> FAC &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_i;</span><br><span class="line"><span class="keyword">int</span> m_j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"FAC::m_fai = %p \n"</span>,&amp;FAC::m_fai);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"FAC::m_faj = %p \n"</span>, &amp;FAC::m_faj);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"MYACLS::m_fai = %p \n"</span>, &amp;MYACLS::m_fai);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"MYACLS::m_faj = %p \n"</span>, &amp;MYACLS::m_faj);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"MYACLS::m_fai = %p \n"</span>, &amp;MYACLS::m_i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"MYACLS::m_faj = %p \n"</span>, &amp;MYACLS::m_j);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">FAC::m_fai = 00000000</span></span><br><span class="line"><span class="comment">FAC::m_faj = 00000004</span></span><br><span class="line"><span class="comment">MYACLS::m_fai = 00000000</span></span><br><span class="line"><span class="comment">MYACLS::m_faj = 00000004</span></span><br><span class="line"><span class="comment">MYACLS::m_fai = 00000008</span></span><br><span class="line"><span class="comment">MYACLS::m_faj = 0000000C</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><p>一个子类对象所包含的内容是自己成员+父亲成员的总和</p></li><li><p>偏移值来看，父类成员先出现，按定义顺序出现，孩子类后出现</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_i1;</span><br><span class="line"><span class="keyword">char</span> m_c1;</span><br><span class="line"><span class="keyword">char</span> m_c2;</span><br><span class="line"><span class="keyword">char</span> m_c3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="keyword">sizeof</span>(Base) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Base::m_i1 = %p \n"</span>, &amp;Base::m_i1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Base::m_c1 = %p \n"</span>, &amp;Base::m_c1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Base::m_c2 = %p \n"</span>, &amp;Base::m_c2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Base::m_c3 = %p \n"</span>, &amp;Base::m_c3);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">Base::m_i1 = 00000000</span></span><br><span class="line"><span class="comment">Base::m_c1 = 00000004</span></span><br><span class="line"><span class="comment">Base::m_c2 = 00000005</span></span><br><span class="line"><span class="comment">Base::m_c3 = 00000006</span></span><br><span class="line"><span class="comment">**********************填充（边界调整）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>内存紧凑</li></ul></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_i1;</span><br><span class="line"><span class="keyword">char</span> m_c1;</span><br><span class="line"><span class="keyword">int</span> m_c2;</span><br><span class="line"><span class="keyword">char</span> m_c3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">16</span></span><br><span class="line"><span class="comment">Base::m_i1 = 00000000 4 </span></span><br><span class="line"><span class="comment">Base::m_c1 = 00000004  4 </span></span><br><span class="line"><span class="comment">Base::m_c2 = 00000008  4</span></span><br><span class="line"><span class="comment">Base::m_c3 = 0000000C  4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_i1;</span><br><span class="line"><span class="keyword">char</span> m_c1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> :</span><span class="keyword">public</span> Base1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">char</span> m_c2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span> :</span><span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">char</span> m_c3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(Base1) "</span> &lt;&lt; <span class="keyword">sizeof</span>(Base1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(Base2) "</span> &lt;&lt; <span class="keyword">sizeof</span>(Base2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(Base3) "</span>&lt;&lt;<span class="keyword">sizeof</span>(Base3) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Base3::m_i1 = %p \n"</span>, &amp;Base3::m_i1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Base3::m_c1 = %p \n"</span>, &amp;Base3::m_c1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Base3::m_c2 = %p \n"</span>, &amp;Base3::m_c2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Base3::m_c3 = %p \n"</span>, &amp;Base3::m_c3);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sizeof(Base1) 8</span></span><br><span class="line"><span class="comment">sizeof(Base2) 12</span></span><br><span class="line"><span class="comment">sizeof(Base3) 16</span></span><br><span class="line"><span class="comment">Base3::m_i1 = 00000000</span></span><br><span class="line"><span class="comment">Base3::m_c1 = 00000004</span></span><br><span class="line"><span class="comment">Base3::m_c2 = 00000008</span></span><br><span class="line"><span class="comment">Base3::m_c3 = 0000000C</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>引入继承关系 增加内存空间</p></li><li><p>Visiual Studio 2015   8 -&gt;12 -&gt;16</p><ul><li>​<img src="object-model/1563600149145.png" alt="1563600149145"></li></ul></li><li><p>linux G++ 5.4.0    8-&gt;12-&gt;12</p><ul><li><img src="object-model/1563600372578.png" alt="1563600372578"></li></ul></li><li><p>linux和windows 布局不一样，编译器实现不一样</p></li><li><p>内存拷贝谨慎</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base2 b2;</span><br><span class="line">Base3 b3;</span><br><span class="line"><span class="comment">//不能用Memcpy内存拷贝把Base2中内容拷贝到Base3中</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="23-单类单继承虚函数下的数据成员布局"><a href="#23-单类单继承虚函数下的数据成员布局" class="headerlink" title="23 单类单继承虚函数下的数据成员布局"></a>23 单类单继承虚函数下的数据成员布局</h2><ul><li><p>单个类带虚函数的数据成员布局</p><ul><li><p>类中引入虚函数时，有额外成本</p><ul><li>编译时，编译器产生虚函数表</li><li>对象中一个成员变量，虚函数表指针vptr，用于指向虚函数表</li><li>增加或者扩展构造函数，增加给虚函数表指针vptr赋值的代码，让vptr指向虚函数表</li><li>多重继承，2个父类，每个父类有vptr，子类继承把这两个vptr都继承，有两个vptr，如果子类还有自己额外的虚函数，子类与第一个父类共有一个vptr</li><li>析构函数也被扩展虚函数表指针vptr的赋值代码，似乎和构造函数代码相同?????</li></ul></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MYACLS</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_i;</span><br><span class="line"><span class="keyword">int</span> m_j;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">myvirtualfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">MYACLS()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> abc = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">~MYACLS()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> def = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(MYACLS)&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;MYACLS::m_i %p \n"</span>,&amp;MYACLS::m_i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;MYACLS::m_j %p \n"</span>, &amp;MYACLS::m_j);</span><br><span class="line"></span><br><span class="line">MYACLS myobj;<span class="comment">//+&amp;myobj0x008ffe30 </span></span><br><span class="line"></span><br><span class="line">myobj.m_i = <span class="number">3</span>;</span><br><span class="line">myobj.m_j = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">12</span></span><br><span class="line"><span class="comment">&amp;MYACLS::m_i 00000004</span></span><br><span class="line"><span class="comment">&amp;MYACLS::m_j 00000008</span></span><br><span class="line"><span class="comment">0x008FFE30  34 8b c2 00 03 00 00 00 06 00 00 00</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>单一继承父类带虚函数的数据成员布局</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure><p>class Base {<br>public:</p><pre><code>int m_bi;virtual void mybvirtualfunc(){}</code></pre><p>};<br>class MYACLS:public Base {<br>public:</p><pre><code>int m_i;int m_j;virtual void myvirtualfunc(){}MYACLS(){    int abc = 1;}~MYACLS(){    int def = 0;}</code></pre><p>};</p><pre><code>cout &lt;&lt; sizeof(MYACLS)&lt;&lt; endl;printf(&quot;&amp;MYACLS::m_bi %p \n&quot;, &amp;MYACLS::m_bi);printf(&quot;&amp;MYACLS::m_i %p \n&quot;,&amp;MYACLS::m_i);printf(&quot;&amp;MYACLS::m_j %p \n&quot;, &amp;MYACLS::m_j);MYACLS myobj;//+        &amp;myobj    0x008ffe30  //+        &amp;myobj    0x0093f970 </code></pre></li></ul></li></ul><pre><code>    myobj.m_i = 3;    myobj.m_j = 6;/*16&amp;MYACLS::m_bi 00000004&amp;MYACLS::m_i 00000008&amp;MYACLS::m_j 0000000C0x0093F970 40 8b 9c 00 cc cc cc cc 03 00 00 00 06 00 00 00*/ <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 单一继承父类不带虚函数的数据成员布局</span><br><span class="line">  * ```c++</span><br><span class="line">    class Base &#123;</span><br><span class="line">    public:</span><br><span class="line">    int m_bi;</span><br><span class="line">    //virtual void mybvirtualfunc()</span><br><span class="line">    //&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    class MYACLS:public Base &#123;</span><br><span class="line">    public:</span><br><span class="line">    int m_i;</span><br><span class="line">    int m_j;</span><br><span class="line">    virtual void myvirtualfunc()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    MYACLS()</span><br><span class="line">    &#123;</span><br><span class="line">    int abc = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    ~MYACLS()</span><br><span class="line">    &#123;</span><br><span class="line">    int def = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">    16</span><br><span class="line">    &amp;MYACLS::m_bi 00000000 //base类最前面 vptr不在最前在第二个？？ error 偏移值不对</span><br><span class="line">    &amp;MYACLS::m_i 00000008</span><br><span class="line">    &amp;MYACLS::m_j 0000000C</span><br><span class="line">    </span><br><span class="line">    实际内存</span><br><span class="line">    0x00EFFBD4  34 8b 4f 00 cc cc cc cc 03 00 00 00 06 00 00 00</span><br><span class="line">    */</span><br></pre></td></tr></table></figure></code></pre><p><img src="object-model/1564636968738.png" alt="1564636968738"></p><h2 id="24-多重继承数据布局与this调整"><a href="#24-多重继承数据布局与this调整" class="headerlink" title="24 多重继承数据布局与this调整"></a>24 多重继承数据布局与this调整</h2><ul><li><p>单一继承数据成员布局this指针偏移</p><ul><li><p>Base类无虚函数，访问Base类成员时，Base 的this指针需要根据子类的this调整</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_bi;</span><br><span class="line"><span class="comment">//virtual void mybvirtualfunc()</span></span><br><span class="line"><span class="comment">//&#123;&#125;</span></span><br><span class="line">Base()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Base this= %p \n"</span>,<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MYACLS</span> :</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_i;</span><br><span class="line"><span class="keyword">int</span> m_j;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">myvirtualfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">MYACLS()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> abc = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"MYACLS this= %p \n"</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">~MYACLS()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> def = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(MYACLS) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;MYACLS::m_bi %p \n"</span>, &amp;MYACLS::m_bi);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;MYACLS::m_i %p \n"</span>, &amp;MYACLS::m_i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;MYACLS::m_j %p \n"</span>, &amp;MYACLS::m_j);</span><br><span class="line"></span><br><span class="line">MYACLS myobj;<span class="comment">//+&amp;myobj0x008ffe30  //+&amp;myobj0x0093f970 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myobj.m_i = <span class="number">3</span>;</span><br><span class="line">myobj.m_j = <span class="number">6</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">16</span></span><br><span class="line"><span class="comment">&amp;MYACLS::m_bi 00000000</span></span><br><span class="line"><span class="comment">&amp;MYACLS::m_i 00000008</span></span><br><span class="line"><span class="comment">&amp;MYACLS::m_j 0000000C</span></span><br><span class="line"><span class="comment">Base this= 0075F8E0  访问Base成员变量 需要 MYACLS this指针+4</span></span><br><span class="line"><span class="comment">MYACLS this= 0075F8DC  </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>Base有虚函数,子类和父类共享VPTR，this指针相同</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_bi;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mybvirtualfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line">Base()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Base this= %p \n"</span>,<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MYACLS</span> :</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_i;</span><br><span class="line"><span class="keyword">int</span> m_j;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">myvirtualfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">MYACLS()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> abc = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"MYACLS this= %p \n"</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">~MYACLS()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> def = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(MYACLS) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;MYACLS::m_bi %p \n"</span>, &amp;MYACLS::m_bi);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;MYACLS::m_i %p \n"</span>, &amp;MYACLS::m_i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;MYACLS::m_j %p \n"</span>, &amp;MYACLS::m_j);</span><br><span class="line"></span><br><span class="line">MYACLS myobj;<span class="comment">//+&amp;myobj0x008ffe30  //+&amp;myobj0x0093f970 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myobj.m_i = <span class="number">3</span>;</span><br><span class="line">myobj.m_j = <span class="number">6</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">16</span></span><br><span class="line"><span class="comment">&amp;MYACLS::m_bi 00000004</span></span><br><span class="line"><span class="comment">&amp;MYACLS::m_i 00000008</span></span><br><span class="line"><span class="comment">&amp;MYACLS::m_j 0000000C</span></span><br><span class="line"><span class="comment">Base this= 008FFB1C</span></span><br><span class="line"><span class="comment">MYACLS this= 008FFB1C</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><img src="object-model/1564639647231.png" alt="1564639647231"></p></li></ul></li><li><p>多重继承且父类都带虚函数的数据成员布局</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_bi;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mybvirtualfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line">Base()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Base this= %p \n"</span>,<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_b2i;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mybvirtualfunc2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line">Base2()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Base2 this= %p \n"</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MYACLS</span> :</span><span class="keyword">public</span> Base,<span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_i;</span><br><span class="line"><span class="keyword">int</span> m_j;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">myvirtualfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">MYACLS()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> abc = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"MYACLS this= %p \n"</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">~MYACLS()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> def = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(MYACLS) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;MYACLS::m_bi %d \n"</span>, &amp;MYACLS::m_bi);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;MYACLS::m_b2i %d \n"</span>, &amp;MYACLS::m_b2i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;MYACLS::m_i %d \n"</span>, &amp;MYACLS::m_i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;MYACLS::m_j %d \n"</span>, &amp;MYACLS::m_j);</span><br><span class="line"></span><br><span class="line">MYACLS myobj;<span class="comment">//+&amp;myobj0x008ffe30  //+&amp;myobj0x0093f970 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myobj.m_i = <span class="number">3</span>;</span><br><span class="line">myobj.m_j = <span class="number">6</span>;</span><br><span class="line">myobj.m_bi = <span class="number">1</span>;</span><br><span class="line">myobj.m_b2i = <span class="number">2</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">24</span></span><br><span class="line"><span class="comment">&amp;MYACLS::m_bi 4   </span></span><br><span class="line"><span class="comment">&amp;MYACLS::m_b2i 4</span></span><br><span class="line"><span class="comment">&amp;MYACLS::m_i 16</span></span><br><span class="line"><span class="comment">&amp;MYACLS::m_j 20</span></span><br><span class="line"><span class="comment">Base this= 0086F9C8</span></span><br><span class="line"><span class="comment">Base2 this= 0086F9D0  //相对于Base this 偏移0xD0-0XC8=8个</span></span><br><span class="line"><span class="comment">MYACLS this= 0086F9C8</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">0x0098F944  84 7b 42 00 01 00 00 00 9c 7b 42 00 02 00 00 00 03 00 00 00 06  ?&#123;B.....?&#123;B..........</span></span><br><span class="line"><span class="comment">0x0098F959  00 00 00 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><img src="object-model/1564639561643.png" alt="1564639561643"></p></li><li><p>偏移量指成员变量相对于该原生对象中的偏移</p></li><li><p>访问Base1中对象不需要偏移，Base2中成员需要偏移8字节+该成员的偏移</p></li><li><p>访问成员变量—–this指针+成员偏移值</p></li><li><p>多态。。。。。！！！！！！</p></li><li><p>this指针调整，导致pbase2调整8个字节，=&amp;myobj+8</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MYACLS myobj;</span><br><span class="line"><span class="comment">//+&amp;myobj0x0077f9a8 &#123;m_i=3 m_j=6 &#125;MYACLS *</span></span><br><span class="line"><span class="comment">//pbase1 = 0x0077f9a8 &#123;m_i=3 m_j=6 &#125;</span></span><br><span class="line"><span class="comment">//pbase2 = 0x0077f9b0 &#123;m_i=3 m_j=6 &#125;</span></span><br><span class="line">Base * pbase1 = &amp;myobj;</span><br><span class="line">Base2 *pbase2 = &amp;myobj;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">编译器</span></span><br><span class="line"><span class="comment">Base2 * pbase2=(Base2*) ( (char*)&amp;myobj +sizeof(Base1) )</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//psubobj = 0x00ef0578 &#123;m_i=-842150451 m_j=-842150451 &#125;</span></span><br><span class="line"><span class="comment">//pbase22 = 0x00ef0580 &#123;m_i=-842150451 m_j=-842150451 &#125; 相差8个字节</span></span><br><span class="line">Base2 *pbase22 = <span class="keyword">new</span> MYACLS();<span class="comment">// new 出来24字节</span></span><br><span class="line">MYACLS *psubobj =(MYACLS *) pbase22;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pbase22;<span class="comment">//会报错,pbase2中保存的地址是分配后的首地址+偏移量</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="25-虚基类问题的提出"><a href="#25-虚基类问题的提出" class="headerlink" title="25 虚基类问题的提出"></a>25 虚基类问题的提出</h2><ul><li><p>虚基类（虚继承/虚派生）问题提出</p><ul><li><p>存在于三重继承结构中，空间、效率、二义性</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grand</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_grand;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span> :</span><span class="keyword">public</span> Grand &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> :</span><span class="keyword">public</span> Grand &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span> :</span><span class="keyword">public</span> A1,<span class="keyword">public</span> A2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"sizeof(Grand) "</span>&lt;&lt;<span class="keyword">sizeof</span>(Grand) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"sizeof(A1) "</span>&lt;&lt; <span class="keyword">sizeof</span>(A1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"sizeof(A2) "</span>&lt;&lt; <span class="keyword">sizeof</span>(A2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(C1) "</span>&lt;&lt;<span class="keyword">sizeof</span>(C1) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//8 两份grand</span></span><br><span class="line"></span><br><span class="line">C1 c1;</span><br><span class="line">c1.m_grand = <span class="number">12</span>;<span class="comment">//error 访问不明确</span></span><br><span class="line"></span><br><span class="line">c1.A1::m_grand = <span class="number">12</span>;</span><br><span class="line">c1.A2::m_grand = <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0x007EF778  0c 00 00 00 0d 00 00 00</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>grand 只继承1次</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grand</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_grand;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span> :</span><span class="keyword">public</span> <span class="keyword">virtual</span> Grand &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> :</span><span class="keyword">public</span> <span class="keyword">virtual</span> Grand &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span> :</span><span class="keyword">public</span> A1,<span class="keyword">public</span> A2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"sizeof(Grand) "</span>&lt;&lt;<span class="keyword">sizeof</span>(Grand) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"sizeof(A1) "</span>&lt;&lt; <span class="keyword">sizeof</span>(A1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"sizeof(A2) "</span>&lt;&lt; <span class="keyword">sizeof</span>(A2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(C1) "</span>&lt;&lt;<span class="keyword">sizeof</span>(C1) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//8 两份grand</span></span><br><span class="line"></span><br><span class="line">C1 c1;</span><br><span class="line">c1.m_grand = <span class="number">12</span>;</span><br><span class="line">c1.A1::m_grand = <span class="number">12</span>;</span><br><span class="line">c1.A2::m_grand = <span class="number">13</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sizeof(Grand) 4</span></span><br><span class="line"><span class="comment">sizeof(A1) 8</span></span><br><span class="line"><span class="comment">sizeof(A2) 8</span></span><br><span class="line"><span class="comment">sizeof(C1) 12</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">0x0135FE64  54 8b ea 00 64 8b ea 00 0d 00 00 00</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li></li></ul></li><li><p>虚基类初探</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grand</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//int m_grand;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span> :</span><span class="keyword">public</span> <span class="keyword">virtual</span> Grand &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> :</span><span class="keyword">public</span> <span class="keyword">virtual</span> Grand &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span> :</span><span class="keyword">public</span> A1,<span class="keyword">public</span> A2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sizeof(Grand) 1</span></span><br><span class="line"><span class="comment">sizeof(A1) 4</span></span><br><span class="line"><span class="comment">sizeof(A2) 4</span></span><br><span class="line"><span class="comment">sizeof(C1) 8</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>虚基类表指针 vbptr （virtual base table pointer）指向虚基类表 vbtable （virtual base table）</p></li><li><p>virtual继承后，A1 A2被编译器插入虚基类表指针vbptr，类似成员变量,占用4字节</p></li><li><p>VS开发人员命令行</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl /d1 reportSingleClassLayoutGrand project100.cpp<span class="comment">//Grand 类名 无空格</span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class A1        size(4):</span><br><span class="line">        +---</span><br><span class="line"> <span class="number">0</span>      | &#123;vbptr&#125;</span><br><span class="line">        +---</span><br><span class="line">        +--- (<span class="keyword">virtual</span> base Grand)</span><br><span class="line">        +---</span><br><span class="line"></span><br><span class="line">A1::$vbtable@:</span><br><span class="line"> <span class="number">0</span>      | <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>      | <span class="number">4</span> (A1d(A1+<span class="number">0</span>)Grand)</span><br><span class="line">vbi:       <span class="class"><span class="keyword">class</span>  <span class="title">offset</span> <span class="title">o</span>.<span class="title">vbptr</span>  <span class="title">o</span>.<span class="title">vbte</span> <span class="title">fVtorDisp</span></span></span><br><span class="line"><span class="class">           <span class="title">Grand</span>       4       0       4 0</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">C1</span>        <span class="title">size</span>(8):</span></span><br><span class="line">        +---</span><br><span class="line"> <span class="number">0</span>      | +--- (base class A1)</span><br><span class="line"> <span class="number">0</span>      | | &#123;vbptr&#125;</span><br><span class="line">        | +---</span><br><span class="line"> <span class="number">4</span>      | +--- (base class A2)</span><br><span class="line"> <span class="number">4</span>      | | &#123;vbptr&#125;</span><br><span class="line">        | +---</span><br><span class="line">        +---</span><br><span class="line">        +--- (<span class="keyword">virtual</span> base Grand)</span><br><span class="line">        +---</span><br><span class="line"></span><br><span class="line">C1::$vbtable@A1@:</span><br><span class="line"> <span class="number">0</span>      | <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>      | <span class="number">8</span> (C1d(A1+<span class="number">0</span>)Grand)</span><br><span class="line"></span><br><span class="line">C1::$vbtable@A2@:</span><br><span class="line"> <span class="number">0</span>      | <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>      | <span class="number">4</span> (C1d(A2+<span class="number">0</span>)Grand)</span><br><span class="line">vbi:       <span class="class"><span class="keyword">class</span>  <span class="title">offset</span> <span class="title">o</span>.<span class="title">vbptr</span>  <span class="title">o</span>.<span class="title">vbte</span> <span class="title">fVtorDisp</span></span></span><br><span class="line"><span class="class">           <span class="title">Grand</span>       8       0       4 0</span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grand</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="keyword">int</span> m_grand;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span> :</span><span class="keyword">public</span> <span class="keyword">virtual</span> Grand &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_a1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> :</span><span class="keyword">public</span> <span class="keyword">virtual</span> Grand &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_a2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span> :</span><span class="keyword">public</span> A1,<span class="keyword">public</span> A2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_c1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"sizeof(Grand) "</span>&lt;&lt;<span class="keyword">sizeof</span>(Grand) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"sizeof(A1) "</span>&lt;&lt; <span class="keyword">sizeof</span>(A1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"sizeof(A2) "</span>&lt;&lt; <span class="keyword">sizeof</span>(A2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(C1) "</span>&lt;&lt;<span class="keyword">sizeof</span>(C1) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//8 两份grand</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">sizeof(Grand) 4</span></span><br><span class="line"><span class="comment">sizeof(A1) 12</span></span><br><span class="line"><span class="comment">sizeof(A2) 12</span></span><br><span class="line"><span class="comment">sizeof(C1) 24   4*int+2*vbptr</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class C1        size(24):</span></span><br><span class="line"><span class="comment">        +---</span></span><br><span class="line"><span class="comment"> 0      | +--- (base class A1)</span></span><br><span class="line"><span class="comment"> 0      | | &#123;vbptr&#125;</span></span><br><span class="line"><span class="comment"> 4      | | m_a1</span></span><br><span class="line"><span class="comment">        | +---</span></span><br><span class="line"><span class="comment"> 8      | +--- (base class A2)</span></span><br><span class="line"><span class="comment"> 8      | | &#123;vbptr&#125;</span></span><br><span class="line"><span class="comment">12      | | m_a2</span></span><br><span class="line"><span class="comment">        | +---</span></span><br><span class="line"><span class="comment">16      | m_c1</span></span><br><span class="line"><span class="comment">        +---</span></span><br><span class="line"><span class="comment">        +--- (virtual base Grand)</span></span><br><span class="line"><span class="comment">20      | m_grand</span></span><br><span class="line"><span class="comment">        +---</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>虚基类始终放在最后面</p></li><li><p><img src="object-model/1564644052354.png" alt="1564644052354"></p></li></ul></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> object_model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello-hexo-blog</title>
      <link href="/2019/07/13/hello-hexo-blog/"/>
      <url>/2019/07/13/hello-hexo-blog/</url>
      
        <content type="html"><![CDATA[<contents><h2 id="This-is-a-hexo-blog-test"><a href="#This-is-a-hexo-blog-test" class="headerlink" title="This is a hexo blog test"></a>This is a hexo blog test</h2><p><img src="%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190625195218.jpg" alt="markdown img test"></p><img src="/2019/07/13/hello-hexo-blog/微信图片_20190625195218.jpg" title="hexo img test"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1366330017&auto=1&height=66"></iframe></contents>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/07/13/hello-world/"/>
      <url>/2019/07/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP网络协议</title>
      <link href="/2019/04/04/tcp-ip-note/"/>
      <url>/2019/04/04/tcp-ip-note/</url>
      
        <content type="html"><![CDATA[<ul><li>TCP/TP协议</li><li>TCP/IP详解</li></ul><a id="more"></a><h3 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h3><ul><li>概述</li><li>链路层</li><li>IP:网际协议</li></ul><h3 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h3><ul><li>ARP</li><li>ICMP</li><li>PING</li><li>Traceroute</li><li>IP选路</li></ul><h3 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h3><ul><li>UDP</li><li>广播和多播</li><li>DNS</li><li>TFTP</li></ul><h3 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h3><ul><li>TCP</li></ul><h3 id="第五天"><a href="#第五天" class="headerlink" title="第五天"></a>第五天</h3><ul><li>TCP</li></ul><h3 id="第六天"><a href="#第六天" class="headerlink" title="第六天"></a>第六天</h3><ul><li>FTP 协议分析</li><li>Telnet</li><li>HTTP</li><li>SMTP/POP3</li><li>SSL</li><li>SNMP</li><li>SIP</li></ul><p><img src="TCP-IP%E5%8D%8F%E8%AE%AE%E5%85%B3%E7%B3%BB%E5%9B%BE(A3%E7%BA%B8%E5%BC%A0%E8%A7%84%E6%A0%BC).png" alt="TCP-IP协议关系图(tcp-ip-note/TCP-IP协议关系图(A3纸张规格).png)"></p><h3 id="第一天-1"><a href="#第一天-1" class="headerlink" title="第一天"></a>第一天</h3><h4 id="1-1-概述分层"><a href="#1-1-概述分层" class="headerlink" title="1.1 概述分层"></a>1.1 概述分层</h4><p><img src="http://image.blissseven.top/blog/20190405/A3LzhN7a90NY.png?imageslim" alt="mark"></p><ul><li>链路层：处理与电缆（或其他任何传输媒介）的物理接口细节</li><li>网络层 处理分组在网络中的活动，e.g 分组选路</li><li>运输层 为两台主机上的应用程序提供端到端的通讯</li><li>应用层 处理特定的应用程序细节 </li></ul><p><img src="http://image.blissseven.top/blog/20190405/D91jgtBfdKKj.png?imageslim" alt="mark"></p><h4 id="1-2-运行FTP的两台主机"><a href="#1-2-运行FTP的两台主机" class="headerlink" title="1.2 运行FTP的两台主机"></a>1.2 运行FTP的两台主机</h4><p><img src="http://image.blissseven.top/blog/20190405/7iatLbWg7hSO.png?imageslim" alt="mark"></p><ul><li><p>大多网络应用程序设计为<strong>客户-服务器</strong>模式</p></li><li><p>双方都有对应的一个或者多个协议进行通讯</p></li><li><p><strong>应用程序</strong>通常都是<strong>用户进程</strong>，而<strong>下三层</strong>一般在<strong>内核</strong>执行</p></li><li><p>应用层关心应用程序的细节，下三层处理通讯细节</p></li><li><p><strong>分层为应用程序隐藏通讯细节！！！！</strong></p></li></ul><h4 id="1-3-通过路由器链接的两个网络"><a href="#1-3-通过路由器链接的两个网络" class="headerlink" title="1.3 通过路由器链接的两个网络"></a>1.3 通过路由器链接的两个网络</h4><p><img src="http://image.blissseven.top/blog/20190405/P7PYb1C8JSRY.png?imageslim" alt="mark"></p><ul><li>端系统 end system —PC 服务器</li><li>中间系统 intermediate system—路由器</li><li>应用层和运输层使用端到端（end to end）协议</li><li><strong>网络层提供的是逐跳协议</strong> hop to hop —PC和路由器 路由器和PC</li><li>网络IP提供的是一种不可靠的服务，只是<strong>尽可能快的把分组源节点送到目的节点，但不提供可靠性保障</strong></li><li>TCP在不可靠的IP层上提供一个可靠的运输层</li><li>互联网的目的之一就是在应用程序中隐藏所有的物理细节</li></ul><p><img src="http://image.blissseven.top/blog/20190405/9g28nbRU48Eo.png?imageslim" alt="mark"></p><ul><li>假设电脑–大厦，应用程序–某个房间，房间号–端口号（标识一个应用程序），FTP 客户端和服务器通过FTP协议 应用程序到应用程序直接进行通讯， TCP协议主机到主机，端到端。IP协议一个城市的快递公司，链路层–一个媒介，介质到介质。</li><li>IP 逐跳 以太网逐媒介</li></ul><p><img src="http://image.blissseven.top/blog/20190405/bKxD5xLV24r6.png?imageslim" alt="mark"></p><h4 id="1-4-TCP-IP协议簇中不同层次的协议"><a href="#1-4-TCP-IP协议簇中不同层次的协议" class="headerlink" title="1.4 TCP/IP协议簇中不同层次的协议"></a>1.4 TCP/IP协议簇中不同层次的协议</h4><p><img src="http://image.blissseven.top/blog/20190405/CaTBcBSlOwnU.png?imageslim" alt="mark"></p><ul><li>TCP使用不可靠的IP服务，并提供一种可靠的运输层服务</li><li>UDP为应用程序发送和接受数据报，不可靠（查询：DNS53，数据传输：TFTP69，SNMP 161，实时流量：语音视频流）</li><li>IP是网络层的主要协议，同时被TCP和UDP使用，还有IPX</li><li>ICMP是IP协议的附属协议 （ping 一个应用程序，调用ICMP，当IP包丢时，会通过ICMP告诉源，什么问题导致丢失）</li><li>ARP ip地址解析为MAC地址</li></ul><h4 id="1-5-封装"><a href="#1-5-封装" class="headerlink" title="1.5 封装"></a>1.5 封装</h4><p><img src="http://image.blissseven.top/blog/20190405/HgeyDSIy3DBz.png?imageslim" alt="mark"></p><ul><li><p>以太网数据帧的物理特性使其长度必须保持在46-1500字节之间，不够46 补够46，大于1500分片</p></li><li><p>以太网的帧首部也有一个16bit的帧类型域（IP ARP,ppoe）（以太网协议号），告诉  下一个头部是什么</p></li><li><p>IP 在首部存入一个长度为8bit的数值，称作<strong>协议域</strong>（ICMP TCP UDP ESP GRE）(IP协议号)</p></li><li><p>TCP /UDP都用一个16bit的端口号表示不同的应用程序（FTP TELNET HTTP）</p></li><li><p>发送方叫封装，接收方叫分用</p></li><li><p>最基本的协议号和端口号</p><ul><li>以太网协议号<ul><li>IP:<strong>0X0800</strong>  | <strong>ARP:0X0806</strong>  |  <strong>PPPOE 0X8863 0X8864</strong></li></ul></li><li>IP 协议号<ul><li><strong>ICMP</strong>:1  |  <strong>TCP</strong>:6  |  <strong>UDP</strong>:17  |  GRE:47  |  ESP:50  |  AH:51</li></ul></li><li>端口号<ul><li><strong>FTP</strong>: 20 21  |  <strong>SSH</strong>:22  |  <strong>Telnet</strong>：23  |  <strong>SMTP</strong>:25  |  TACACS+:49  | HTTP:80  |  <strong>HTTPS</strong>:443  |  IKE: 500</li></ul></li></ul></li></ul><h4 id="1-6-分用"><a href="#1-6-分用" class="headerlink" title="1.6 分用"></a>1.6 分用</h4><p><img src="http://image.blissseven.top/blog/20190405/kKfV9xoT7EuQ.png?imageslim" alt="mark"></p><h4 id="1-7-端口号"><a href="#1-7-端口号" class="headerlink" title="1.7 端口号"></a>1.7 端口号</h4><ul><li><strong>服务器一般通过知名端口号识别</strong>（ftp 20 21 telnet 23 目的端口号即为服务器端端口号）</li><li><strong>客户端口号又称临时端口号（存在时间很短）</strong></li><li><strong>大多数TCP/IP实现给临时端口号分配1024-5000之间的端口号</strong></li><li><strong>大于5000 的端口号是为其他服务器预留的</strong></li></ul><h4 id="1-8-实现过程"><a href="#1-8-实现过程" class="headerlink" title="1.8 实现过程"></a>1.8 实现过程</h4><p><img src="http://image.blissseven.top/blog/20190405/NH3IMklG8YW3.png?imageslim" alt="mark"></p><ul><li>软件是同4.xBSD系统的网络版一起发布的，它的源代码是许多实现的基础</li></ul><h4 id="2-1-链路层-以太网和IEEE802封装"><a href="#2-1-链路层-以太网和IEEE802封装" class="headerlink" title="2.1 链路层 以太网和IEEE802封装"></a>2.1 链路层 以太网和IEEE802封装</h4><ul><li><p>以太网</p><ul><li>一般指数字设备公司、英特尔公司、Xerox公司在1982年联合公布的一个标准</li><li>采用CSMA/CD 的媒体接入方法（Carrier Sense. Multiple Access with Collision Detection）</li><li>速率10Mb/s，地址18bit</li><li>之后由IEEE 802.3委员会将其规范化，但两者直接对以太网帧的格式定义有所不同.IEEE802.3所规范的以太网有时又被称为802.3以太网（非IP协议 CDP,VTP）</li></ul></li><li><p>IEEE 802封装</p><ul><li>802.3 针对整个CSMA/CD网络</li><li>802.4 针对令牌总线网络</li><li>802.5 针对令牌环网络</li></ul></li><li><p>MAC地址长48bit。任何一个网卡的mac地址唯一</p><ul><li>根据MAC地址转发</li></ul><p><img src="http://image.blissseven.top/blog/20190406/LghBoVdPgbL7.png?imageslim" alt="mark"></p><p><img src="http://image.blissseven.top/blog/20190406/pooromEOanqD.png?imageslim" alt="mark"></p><p><img src="http://image.blissseven.top/blog/20190407/DMPX7TOM6G6u.png?imageslim" alt="mark"></p><p><img src="http://image.blissseven.top/blog/20190407/Pnwq7jYHfLWS.png?imageslim" alt="mark"></p></li></ul><h4 id="2-2-封装格式"><a href="#2-2-封装格式" class="headerlink" title="2.2 封装格式"></a>2.2 封装格式</h4><p><img src="http://image.blissseven.top/blog/20190406/xn23VBYLE3AE.png?imageslim" alt="mark"></p><ul><li>两种帧格式都采用48bit（6字节）的目的地址和和源地址，类型即高速下一个为IP头部</li><li>ARP RARP协议对32bit的IP地址和48bit的硬件地址进行映射</li><li>802定义的<strong>有效长度值与以太网的有效类型值无一相同，这样就可以对两种帧格式进行区分</strong>。</li><li>目的服务访问点(Destination Service Access Point ,DSAP)和源服务访问点（Source Service Access Point，SSAP）的值都为<strong>0xaa，ctrl字段为3.随后的三个字节org code都设置为0</strong>。随后的2个字节类型字段和以太网帧格式一样。802.3规定数据部分至少为38字节，而对于以太网至少为46字节。为了保证这一点，不够的要补充pad字节。 </li></ul><p><img src="http://image.blissseven.top/blog/20190406/1OjiXA0JAwUn.png?imageslim" alt="mark"></p><p><img src="http://image.blissseven.top/blog/20190406/VbXuGabg30YX.png?imageslim" alt="mark"></p><h4 id="2-3-环回口"><a href="#2-3-环回口" class="headerlink" title="2.3 环回口"></a>2.3 环回口</h4><p><img src="http://image.blissseven.top/blog/20190406/MvspyPaMtEgk.png?imageslim" alt="mark"></p><ul><li>传给<strong>环回地址（一般为127.x.x.x）的任何数据均作为IP输入</strong></li><li><strong>传给广播地址或多播地址的数据报复制一份给环回接口，然后送到以太网上。这是因为广播传送和多播传送的定义包含主机本身。广播的数据报根本就没有出去，不是发出去再收回来</strong></li><li>任何传给该主机IP地址的数据均送到环回接口</li></ul><h4 id="2-4-MTU和路径MTU"><a href="#2-4-MTU和路径MTU" class="headerlink" title="2.4 MTU和路径MTU"></a>2.4 MTU和路径MTU</h4><p><img src="http://image.blissseven.top/blog/20190406/wVf0Yjr0F6nh.png?imageslim" alt="mark"></p><ul><li><strong>以太网和802.3对数据帧的长度</strong>都有一个限制，其最大值分别是<strong>1500和1492字节</strong>。<strong>链路层的这个特性称作MTU，最大传输单元。出方向的时候查看MTU</strong>，</li><li>如果IP层有一个数据报要传送，而且数据的长度比链路层的MTU还大，那么IP层就要分片（fragementation）</li><li>点到点的链路层（SLIP /PPP）的MTU<strong>并非指的是网络媒体的物理特性</strong>，相反，他是一个<strong>逻辑限制，目的是为交互使用提供足够快的响应时间</strong></li><li>两台通信主机通信路径中的最小MTU，成为路径MTU</li><li>路径MTU再两个方向上是不一致的</li><li>MTU计算出方向</li></ul><h4 id="3-1-网络层和数据链路层的关系"><a href="#3-1-网络层和数据链路层的关系" class="headerlink" title="3.1 网络层和数据链路层的关系"></a>3.1 网络层和数据链路层的关系</h4><ul><li>网络层的主要作用是实<strong>现终端节点之间的通信。</strong>这种终端节点之间的通信也叫点对点通信。（主机到主机，IP到IP）</li><li>数据链路层的主要作用是在<strong>互联同一种数据链路的节点之间进行包/帧传递</strong>，而一旦跨越<strong>多种数据链路，就需要借助于网络层</strong>。网络层可以跨越不同的数据链路，即使再不同的数据链路上也能实现两端点之间的数据包传输</li><li><img src="http://image.blissseven.top/blog/20190406/S0bAV3U04ys1.png?imageslim" alt="mark"></li><li><strong>数据链路层提供直连(网络层面的直连)两个设备之间的通信功能</strong>。作为网络层的IP负责在没有直连的两个网络之间进行通信传输</li><li><img src="http://image.blissseven.top/blog/20190406/jG9PJwX1g7F4.png?imageslim" alt="mark"></li><li>每张票只能在某一限定区间内移动。区间内就是网络上的数据链路。而这个区间的出发点和目的点就是数据链路的源地址和目标地址等首部信息。整个全程的行程表就是网络层</li><li>MAC地址标识同一个链路不同计算机的识别码，IP用于在连接到网络中的所有主机中识别出进行通信的目标地址</li></ul><h4 id="3-2-IP介绍"><a href="#3-2-IP介绍" class="headerlink" title="3.2 IP介绍"></a>3.2 IP介绍</h4><ul><li>IP为TCP/IP协议族中最为核心协议。TCP/UDP/ICMP/IGMP数据都以IP数据报格式传输</li><li>IP提供不可靠的无连接的数据报传送服务</li><li>不可靠（unreliable）指的是不能保证IP数据报能成功到达目的地。IP仅提供最好的传输服务。如果发生某种错误。IP有一个简单的错误处理算法，丢弃该数据报，然后发送ICMP消息给信源端。任何要求的可靠性必须由上层来提供（tcp/ip）</li><li>无连接（connectionless）IP并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。IP数据报可以不按发送顺序接受。如果一信源向相同的信宿发送两个连续的数据报（A,B），每个数据报都是独立的进行路由选择，可能选择不同的路线，因此B可能再A之前到达。TCP对数据包排序，顺序不对时，缓存。</li><li>ifconfig/netstat</li></ul><h4 id="3-3-IP首部"><a href="#3-3-IP首部" class="headerlink" title="3.3 IP首部"></a>3.3 IP首部</h4><ul><li><img src="http://image.blissseven.top/blog/20190406/lp02PfVJt4c9.png?imageslim" alt="mark"></li></ul><ul><li><img src="http://image.blissseven.top/blog/20190406/QcEsFkEUEIck.png?imageslim" alt="mark"></li><li></li></ul><h4 id="3-4-首部字段分析1"><a href="#3-4-首部字段分析1" class="headerlink" title="3.4 首部字段分析1"></a>3.4 首部字段分析1</h4><ul><li>版本，4bit组成。表示标识IP首部的版本号，IPV4版本号为4。<ul><li><img src="http://image.blissseven.top/blog/20190406/vMt1opcThTRy.png?imageslim" alt="mark"></li></ul></li><li>首部长度，4bit构成。IP首部大小。单位为4字节（32bit），即一行。对于没有可选项的IP包。首部长度为5。即IP首部长度为20字节。</li><li>首部长度最大15 *4字节=60个字节，15行。选项最多40个字节<ul><li><img src="http://image.blissseven.top/blog/20190406/KmFJBPBX80Ul.png?imageslim" alt="mark"></li></ul></li><li>区分服务位，TOS位<ul><li>8bit构成，表明服务质量。</li><li><img src="http://image.blissseven.top/blog/20190406/GI1X6VkGoRAV.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190406/uwLCkisWmEAL.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190406/wHE7GYTe2ul7.png?imageslim" alt="mark"></li></ul></li><li>总长度，表<strong>示IP首部和数据部分合起来的总字节数</strong>。长16bit。因此IP包最大为65535=2^16字节。<ul><li>目前还不存在能够传输最大长度为65535字节的IP包的数据链路。不过，因为有IP分片处理，从IP的上一层角度看，不论底层采用何种数据链路，都可以认为能够以IP的最大包长传输数据</li></ul></li><li><strong>标识ID，16bit组成。用于分片重组</strong>。同一个分片的标识值相同，不同分片标识值不同。通常，每发送一个IP包，它的值也会逐渐增加。此外，如果ID相同，但目标地址、源地址或协议不同的话，也会认为是不同的分片。一个数据报，一个ID，可能分成很多片。</li><li>标志，flag<ul><li>3bit构成，表示<strong>包被分片的相关信息</strong>。</li><li><img src="http://image.blissseven.top/blog/20190406/wNlO2FY5XemT.png?imageslim" alt="mark"></li></ul></li><li>片位移FO–Fragment Offset<ul><li>13bit构成。<strong>标识被分片的每一个片段相对于原始数据的位置</strong>。第一个分片对应的值为0。由于FO域占13bit。因此最多可以标识8192=2^13个相对位置。单位为8字节。因此最大可表示原始数据8x8192=65536字节的位置。</li></ul></li><li>TTL 生存时间<ul><li>8bit构成。可以<strong>中转多少个路由器，每经过一个路由就减一，防止环形路由</strong>。</li></ul></li><li>协议<ul><li>8bit构成。<strong>表示IP首部的下一个首部属于哪个协议</strong>。</li><li>1 ICMP 6 TCP 17 UDP</li></ul></li><li>首部校验和（Header CheckSum）<ul><li>16bit构成。只校验数据报的首部，不校验数据部分。确保IP数据包不被破坏。</li></ul></li><li>源地址<ul><li>32bit，表示发送端IP地址</li></ul></li><li>目标地址<ul><li>32bit，接收端IP地址</li></ul></li><li>可选项<ul><li>最多40字节</li><li><img src="http://image.blissseven.top/blog/20190407/qzedik0vVsuU.png?imageslim" alt="mark"></li></ul></li><li>填充Padding<ul><li>再由可选项的情况下，首部长度可能不是32bit的整数倍，为此向该字段填0，调整为32bit的整数倍。</li></ul></li><li>数据<ul><li>存入数据</li></ul></li></ul><h4 id="3-5-IP路由的选择"><a href="#3-5-IP路由的选择" class="headerlink" title="3.5 IP路由的选择"></a>3.5 IP路由的选择</h4><ul><li><img src="http://image.blissseven.top/blog/20190407/sqaHbWKDXjE2.png?imageslim" alt="mark"></li><li>该例子中所有主机和路由器都使用了默认路由。事实上，大多数主机和一些路由器可以用默认路由来处理任何目的，除非它在本地局域网上</li><li><strong>数据报中的目的IP地址始终不发生任何变化（只有使用源路由选项时，目的IP地址地址才可能被修改，很罕见</strong>）。所有<strong>路由选择决策都是基于这个目的IP地址</strong></li><li>每个链路层可能具有不同的数据帧首部，而且链路层的目的地址（如果有的话）始终指向下一站的链路层地址。在例子中，两个以太网封装了含有下一站以太网的链路层首部，但是SLIP链路没有这样做。以太网地址一般通过ARP获得。</li><li><img src="http://image.blissseven.top/blog/20190407/SoARmv2I0DMg.png?imageslim" alt="mark"></li><li>源目IP始终保持不表（除非有NAT存在）</li><li>每一跳数据链路层地址都随之改变，源为出接口物理地址，目的为路由的下一跳的物理地址</li></ul><h4 id="3-6-特殊情况的IP地址"><a href="#3-6-特殊情况的IP地址" class="headerlink" title="3.6 特殊情况的IP地址"></a>3.6 特殊情况的IP地址</h4><ul><li><p><img src="http://image.blissseven.top/blog/20190407/Cs9nlaHpwLV9.png?imageslim" alt="mark"></p></li><li><p><strong>0表示所有bit为0；-1表示所有比特为1；netid,subnetid 和hostid分别表示不为全0 全1的对应字段。子网号栏为空表示该地址没有进行子网划分</strong>。</p></li><li><p>表<strong>的头两项为特殊的源地址，中间项为特殊的环回地址，最后四项为广播地址</strong></p></li><li><p>表中头两项，网络号为0，如主机使用BOOTP协议确定本机IP地址时只能作为初始化过程中的源地址出现。</p></li><li><p>DHCP   UDP包，有源IP地址，为0.0.0.0 目的IP 255.255.255.255</p></li><li><p>192.168.1.0/24 24 指网络号加子网号的总位数，在没有划分之前ip地址是网络号+主机号，划分子网之后，出现了子网号，<strong>子网号是从主机号借的位。 子网掩码中前多少号为1</strong></p></li><li><p>在使用TCP/IP 协议的网络中，主机标识段host ID 为全1 的IP 地址为广播地址，广播的分组传送给host<br>ID段所涉及的所有计算机。例如，对于10.1.1.0 （255.255.255.0 ）网段，其广播地址为10.1.1.255 （255 即为2<br>进制的11111111 ），当发出一个目的地址为10.1.1.255 的分组（封包）时，它将被分发给该网段上的所有计算机。</p></li><li><p><strong>网络地址就是：把IP地址转成二进制和子网掩码进行与运算</strong></p></li><li><p>广播地址：网络地址的主机位全部变成1 </p></li><li><p>网络地址+1即为第一个主机地址，广播地址-1即为最后一个主机地址</p></li><li><p>主机的数量=2^二进制位数的主机-2</p></li></ul><h3 id="第二天-1"><a href="#第二天-1" class="headerlink" title="第二天"></a>第二天</h3><h4 id="1-0-建立TCP连接与ARP的关系"><a href="#1-0-建立TCP连接与ARP的关系" class="headerlink" title="1.0 建立TCP连接与ARP的关系"></a>1.0 建立TCP连接与ARP的关系</h4><p>应用接受用户提交的数据，触发TCP建立连接，TCP的第一个SYN报文通过connect函数到达IP层，IP层通过查询路由表：</p><ul><li><p>如果目的IP和自己在同一个网段：</p><ul><li>当<strong>IP层的ARP高速缓存表中存在目的IP对应的MAC地址时</strong>，则调用网络接口send函数（参数为IP Packet和目的MAC））将数据提交给网络接口，网络接口完成Ethernet Header + IP + CRC的封装，并发送出去；</li><li>当IP层的ARP高速缓存表中不存在目的IP对应的MAC地址<strong>时，则IP层将TCP的SYN缓存下来，发送ARP广播请求目的IP的MAC，</strong>收到ARP应答之后，将应答之中的&lt;IP地址，对应的MAC&gt;对缓存在本地ARP高速缓存表中，然后完成TCP  SYN的IP封装，调用网络接口send函数（参数为IP Packet和目的MAC））将数据提交给网络接口，网络接口完成Ethernet  Header + IP + CRC的封装，并发送出去；。</li></ul></li><li><p>如果目的<strong>IP地址和自己不在同一个网段，就需要将包发送给默认网关，这需要知道默认网关的MAC地址</strong>：</p><ul><li>当IP层的ARP高速缓存表中存在默认网关对应的MAC地址时，则调用网络接口send函数（参数为IP Packet和默认网关的MAC）将数据提交给网络接口，网络接口完成Ethernet Header + IP + CRC</li><li>当<strong>IP层的ARP高速缓存表中不存在默认网关对应的MAC地址时，则IP层将TCP的SYN缓存下来，发送ARP广播请求默认网关的MAC，收到ARP应答之后，将应答之中的&lt;默认网关地址，对应的MAC&gt;对缓存在本地ARP高速缓存表中，然后完成TCP  SYN的IP封装</strong>，调用网络接口send函数（参数为IP Packet和默认网关的MAC）将数据提交给网络接口，网络接口完成Ethernet  Header + IP + CRC的封装，并发送出去。</li></ul></li></ul><h4 id="1-1-ARP介绍"><a href="#1-1-ARP介绍" class="headerlink" title="1.1 ARP介绍"></a>1.1 ARP介绍</h4><ul><li><img src="http://image.blissseven.top/blog/20190407/kfgvQmLx6ceC.png?imageslim" alt="mark"></li><li>当一台主机把以太网数据帧发送到位于同一局域网上的另一台主机时，<strong>是根据48bit的以太网地址来确认目的接口</strong>的。<strong>设备驱动程序从不检查IP数据报中的目的IP地址</strong></li><li>地址解析为这两种不同的地址形式提供映射。</li><li>ARP 为IP地址到对应的硬件地址之间提供动态映射。动态—自动完成</li><li>RARP被那些没有磁盘驱动器的系统使用，需要系统管理员进行手动设置</li><li></li><li><img src="http://image.blissseven.top/blog/20190407/TPvJ00qLkM1c.png?imageslim" alt="mark"></li><li>直连时，解析目的主机MAC地址，否则解析下一跳<strong>默认网关 或者路由的MAC地址</strong></li><li>逻辑地址（一般IP），物理地址（MAC/DLCI/全局IP）</li><li>仅仅知道目的逻辑地址，不知道物理地址，设备不会向网络发送任何数据帧</li></ul><h4 id="1-2逻辑到物理地址的解析协议"><a href="#1-2逻辑到物理地址的解析协议" class="headerlink" title="1.2逻辑到物理地址的解析协议"></a>1.2逻辑到物理地址的解析协议</h4><ul><li><p><img src="http://image.blissseven.top/blog/20190407/kDCI8d3eHBIJ.png?imageslim" alt="mark"></p></li><li><p>以太网 ARP</p></li><li><p>帧中继 （Franme Relay Inverse ARP）</p></li><li><p>MGRE（NHRP）</p></li><li><p>这些均支持自动和手动模式</p></li><li><p>点对点网络无需地址解析协议</p><ul><li>PPP 点对点网络</li><li>点对点GRE网络</li><li>IPSec VTI网络</li><li>存储FC网络</li><li>数据中心FP网络</li></ul></li></ul><h4 id="1-3-ARP高速缓存"><a href="#1-3-ARP高速缓存" class="headerlink" title="1.3 ARP高速缓存"></a>1.3 ARP高速缓存</h4><ul><li>ARP高效运行的关键是，<strong>每个主机都有一个ARP高速缓存/存放了最近Internet地址到硬件地址之间的映射记录</strong>。高速缓存每一项的生存时间一般为20分钟，起始时间从被创建时开始。</li><li>PC arp -a arp -d清除</li><li>路由器 show arp   clear arp</li></ul><h4 id="1-4-ARP的分组格式"><a href="#1-4-ARP的分组格式" class="headerlink" title="1.4 ARP的分组格式"></a>1.4 ARP的分组格式</h4><ul><li><img src="http://image.blissseven.top/blog/20190407/c9Rd4j0YFFdr.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190407/QReuCtAQPxNh.png?imageslim" alt="mark"></li><li>帧类型0800 IP 0806 ARP 0835 RARP</li><li>紧跟着帧类型字段的前4字段指定了最后四个字段的类型和长度</li><li>硬件类型 以太网 =1</li><li><strong>协议类型 IPv4 0x0800</strong></li><li>硬件长度 <strong>以太网地址长度6 字节</strong></li><li>协议长<strong>度 IPv4=4字节</strong></li><li>操作码 1 request 2 reply 3 RARP请求 4 RARP 应答</li><li><img src="http://image.blissseven.top/blog/20190407/L99ukCAr8jV7.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190407/sksxeThYrFHF.png?imageslim" alt="mark"></li><li>大部分的广播包，它们有一个共同特征：<strong>二层封装时目的MAC是全f（ffff.ffff.ffff）或三层封装时目的IP是全1（255.255.255.255）</strong>。可以这样更方便的记住：目的地址最大的，就是广播。</li><li>“问”是通过广播形式实现，”答”是通过单播形式。</li></ul><h4 id="1-5-交换机工作原理"><a href="#1-5-交换机工作原理" class="headerlink" title="1.5 交换机工作原理"></a>1.5 交换机工作原理</h4><ul><li><img src="http://image.blissseven.top/blog/20190407/FdOxsKlMwKu8.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190407/qyV3UnUVRBLh.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190407/kHwV3ORsPDDo.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190407/l7ALNaDAPxFt.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190407/RxtXay1fahEc.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190407/PcC3WyTx0kFV.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190407/6gJ0qYWMkWyF.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190407/5tXfDbMDRJ7V.png?imageslim" alt="mark"></li></ul><h4 id="1-6-特殊的ARP-ARP代理"><a href="#1-6-特殊的ARP-ARP代理" class="headerlink" title="1.6 特殊的ARP-ARP代理"></a>1.6 特殊的ARP-ARP代理</h4><ul><li><p><img src="http://image.blissseven.top/blog/20190407/Q4l6mKOlhSPq.png?imageslim" alt="mark"></p></li><li><p><strong>R1没有路由能力，不分直连不直连</strong>。</p></li><li><p><strong>有路由能力的直连的直接解析，没有直连的解析网关</strong></p></li><li><p>一台主机（通常路由器）应答要发送至另一台机器的ARP请求。通过“伪造”其身份，<strong>路由器负责将信息包路由到“真实”目的地。代理ARP可以帮助子网中的计算机到达远程子网，而无需配置路由或默认网关</strong>。</p></li><li><p>　代理ARP就是通过使用一个主机(通常为router)，来作为指定的设备使用自己的 MAC 地址来对另一设备的ARP请求作出应答。</p></li><li><p>为什么需要代理ARP？<strong>路由器的重要功能之一就是把局域网的广播包限制在该网内，阻止其扩散，否则会造成网络风暴</strong>。</p><p>　　<strong>ARP请求是个广播包，它询问的对象如果在同一个局域网内，就会收到应答</strong>。<strong>但是如果询问的对象不在同一个局域网该如何处理？路由器就提供的代理ARP为这个问题提供了解决方案。</strong></p></li><li><p>　两台<strong>主机A和B处于同一网段但不同的广播段时，主机A发送ARP请求主机B的MAC地址时，因为路由器不转发广播包的原因</strong>，ARP请求只能到达路由器。如果路由器启用了<strong>代理ARP功能，并知道主机B属于它连接的网络，那么路由器就用自己接口的MAC地址代替主机B的MAC地址来对主机A进行ARP应答。</strong>主机A接收ARP应答，但并不知道代理ARP的存在</p></li><li><p>优点：<strong>代理ARP能在不影响路由表的情况下添加一个新的Router，使子网对该主机变得透明化。一般代理ARP应该使用在主机没有配置默认网关或没有任何路由策略的网络上</strong>。</p></li><li><p>缺点：从工作工程可以看到，这其实是一种ARP欺骗。而且，通过两个<strong>物理网络之间的路由器的代理ARP功能其实互相隐藏了物理网络</strong>，这导致<strong>无法对网络拓扑进行网络概括</strong>。此外，代理ARP增加了使用它的那段网络的ARP流量，主机需要更大的ARP缓存空间，也不会为不使用ARP进行地址解析的网络工作。</p></li></ul><h4 id="1-7-免费ARP"><a href="#1-7-免费ARP" class="headerlink" title="1.7 免费ARP"></a>1.7 免费ARP</h4><ul><li>作用1 告诉<strong>整个广播域，目前这个IP对应的MAC是什么</strong>  （网络设备冷备）</li><li>作用2 看看<strong>广播内有没有别的主机使用自己的IP，如果使用了，界面上弹出IP冲突</strong>（防止地址冲突）</li><li><img src="http://image.blissseven.top/blog/20190407/j6fCn07z2SWw.png?imageslim" alt="mark"></li><li><strong>接收方，接收到包后，尽管目的IP不是自己，但会读取源IP和源MAC，并更新自己的ARP缓存</strong></li><li><img src="http://image.blissseven.top/blog/20190407/TEcNYiDH8hHv.png?imageslim" alt="mark"></li></ul><h4 id="2-1-ICMP介绍"><a href="#2-1-ICMP介绍" class="headerlink" title="2.1 ICMP介绍"></a>2.1 ICMP介绍</h4><ul><li>ICMP<strong>为IP层的一个组成部分。传递差错报文以及其他需要注意的信息。ICMP报文通常被IP层或者更高层协议（TCP/UDP）使用</strong>。一些ICMP报文把差错报文返回给用户进程</li><li>一旦丢包，<strong>丢包的路由器将差错报文发送源</strong>。</li><li><strong>ICMP报文在IP数据报内部被传输</strong></li><li>ICMP报<strong>文前四个字节都相同</strong>，IP 首部20字节。</li><li><img src="http://image.blissseven.top/blog/20190408/IAyD5lcoVH3k.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190408/HK2DtSjhnGvz.png?imageslim" alt="mark"></li><li>ICMP协议号为1  <strong>ICMP</strong>:1  |  <strong>TCP</strong>:6  |  <strong>UDP</strong>:17  |  GRE:47  |  ESP:50  |  AH:51</li><li>echo request 类型为8 代码为0</li><li>echo reply 类型为0 代码为0</li><li>校验和：<ul><li>以太网管自己的，IP校验和IP头部，TCP /ICMP 管自己头部和后面所有的</li></ul></li><li><img src="http://image.blissseven.top/blog/20190408/6McohHNMnT1v.png?imageslim" alt="mark"></li><li>最后<strong>两列表示ICMP报文是查询报文还是差错报文</strong></li><li>当发送一份ICMP差错报文时，报文始终包含<strong>IP的首部</strong>和<strong>产生ICMP差错报文的IP数据报的前8个字节</strong>，这样接受ICMP差错报文的模块就会把它与某个<strong>特定的协议（根据IP数据报首部中的协议字段来判断</strong>）和<strong>用户进程（根据包含在IP数据报前8个字节中的TCP或UDP报文首部中的TCP或UDP端口号来判断</strong>）联系起来。</li></ul><h4 id="2-2-差错报文"><a href="#2-2-差错报文" class="headerlink" title="2.2 差错报文"></a>2.2 差错报文</h4><ul><li>下列情况不会导致产生ICMP差错报文，为了防止过去允许ICMP差错报文对广播分组响应所带来的广播风暴<ul><li><strong>ICMP差错报文，但是ICMP查询报文可能会产生差错报文</strong></li><li><strong>目的地址是广播地址或多播地址的IP数据报</strong></li><li>作为链路层广播的数据报</li><li>不是IP分片的第一片，只有第一片才有四层端口号的信息。</li><li><strong>源地址不是单个主机的数据报。即源地址不能为零地址、环回地址、广播地址、多播地址</strong></li></ul></li><li><img src="http://image.blissseven.top/blog/20190408/R6Yut5IiC2ms.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190408/J6VxGGXmpIPA.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190408/nrKHFiinFAwb.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190408/MUvsnpo5keDa.png?imageslim" alt="mark"></li></ul><h4 id="2-3-ping介绍"><a href="#2-3-ping介绍" class="headerlink" title="2.3 ping介绍"></a>2.3 ping介绍</h4><ul><li>用于进行通信的主机或路由器之间，<strong>判断所发送的数据包是否已经成功到达对端的一种消息</strong></li><li>ICMP Echo Request —————ICMP Echo Reply</li><li>ping 可以确定问题出在哪里，也可以<strong>测出到这台主机的往返时间，表明该主机离我们有多远</strong></li><li><strong>一台主机的可达性可能不止取决于IP是否可达，还取决于使用何种协议以及端口号，ping不通，不见得一定不通</strong></li><li>成发送回显请求的ping程序为客户，而被ping的主机为服务器。大<strong>都数的TCP/IP实现都在内核中直接支持ping服务器</strong>。这种服务器不是一个用户进程（第六章介绍的两种ICMP查询服务，地址掩码和时间戳请求，也都是直接在内核中进行处理的）</li><li><img src="http://image.blissseven.top/blog/20190408/qQEdFmE86aME.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190408/KyI6V1niVmNa.png?imageslim" alt="mark"></li><li>对于其他类型的ICMP查询报文，服务器必须相应标识符和序列号字段。另外，<strong>客户发送的选项数据必须回显，假设客户对这些信息都会感兴趣</strong></li><li>Unix系统在实现ping程序时是把ICMP报文中的<strong>标识符字段</strong>置成发送<strong>进程的ID号</strong>。这样即使在同一台主机上同时运行了多个ping程序实例，ping程序也可以识别出返回的信息。</li><li>在windows下，不管开多少个窗口ping的identifier都是相同的，而且每增加一个出去的ping包序列号增加256，能分清楚回来的包吗？？</li><li><strong>序号逐个增1</strong></li><li><img src="http://image.blissseven.top/blog/20190408/fCLcPfWr43do.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190408/TWM4v9rU7Afh.png?imageslim" alt="mark"></li></ul><h4 id="IP选项"><a href="#IP选项" class="headerlink" title="IP选项"></a>IP选项</h4><h4 id="2-4-IP记录路由选项"><a href="#2-4-IP记录路由选项" class="headerlink" title="2.4 IP记录路由选项"></a>2.4 IP记录路由选项</h4><ul><li>ping程序都提供-R选项，以提供<strong>记录路由</strong>的功能。使得ping程序在发送出去的IP数据报中设置IP <strong>RR选项</strong>（在IP可选项部分）（该IP数据报包含ICMP回显请求报文）。这样，每个处理该数据报的路由器都会把它的IP地址放入选项字段中，当<strong>数据报到达目的端时，IP地址清单应该复制到ICMP回显应答</strong>中，这样返回途中所经过的路由器地址也被加入到清单中。当ping程序收到回显应答时，他就会打印出这份IP地址清单</li><li><strong>源端主机生成RR选项，中间路由器对RR选项进行处理，以及把ICMP回显请求中的RR清单复制到ICMP回显应答中，所有这些都为选项功能。</strong>幸运的是，现在大多数系统都支持这些选项，只有一些系统不把ICMP请求中的IP清单复制到ICMP应答中。</li><li>但是，<strong>最大的问题是IP首部中只有有限的空间来存放IP地址</strong>。我们从IP首部图中可以看出，IP首部中的首部长度字段只有4bit，因此整个IP首部最长只能包含15<em>32 =60个字节.由于IP首部固定长度20字节，*</em>RR选项用于3个字节，这样只剩下37个字节来存放IP地址清单，也就是说，只能存放9个IP地址**。</li><li>记录路由出方向的IP</li><li>来来回回都记录</li><li><img src="http://image.blissseven.top/blog/20190408/wAmvpdnUuhRu.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190408/pxyTzds9OvRP.png?imageslim" alt="mark"></li><li><strong>code为一个字节，指明IP选项的类型</strong>。<strong>对于RR选项来说，值为7</strong>。len为RR选项总字节长度，这种情况下为39（尽管可以为RR选项设置比最大长度小的长度，但是ping程序总是提供39字节的选项字段，最多可以记录9个IP，由于IP首部中留给选项的空间有限，它一般情况下设置成最大值）</li><li>ptr为指针字段，一个基于1的指针，指向存放下一个IP地址的位置，最小值为4，指向存放第一个IP地址的位置。随着每个IP地址存入清单，ptr的值分别为8，12，16，最大36.当记录下9个IP地址后，ptr值为40，表示清单已满</li><li>当路由（多穴）在清单中记录IP地址时，记录出口地址。当原始主机（运行ping的主机）收到带有RR选型的ICMP回显应答时，它也要把它的入口地址放入清单中。</li></ul><h4 id="2-5-IP时间戳选项"><a href="#2-5-IP时间戳选项" class="headerlink" title="2.5 IP时间戳选项"></a>2.5 IP时间戳选项</h4><ul><li><img src="http://image.blissseven.top/blog/20190408/PkBAgezK8cjU.png?imageslim" alt="mark"></li><li><strong>时间戳选项代码0x44</strong>，其他两个字段len ptr与记录路由选项相同。<strong>选项总长度（一般36/40）和指向下一个可用空间的指针（5，9，13）</strong></li><li>接下来两个字段是4bit值，OF表示溢出字段，FL表示标志字段</li><li>时间戳的取值一般为<strong>UTC午夜开始计时的毫秒数</strong>。与ICMP时间戳请求和应答相似，如果路由器不使用这种格式，他就可以插入任何它使用的时间表示格式。但是必须打开时间戳中的高位以表明为非标准值</li></ul><h4 id="3-1-Traceroute-VS-IP路径记录"><a href="#3-1-Traceroute-VS-IP路径记录" class="headerlink" title="3.1 Traceroute VS IP路径记录"></a>3.1 Traceroute VS IP路径记录</h4><ul><li><strong>不是所有路由都支持记录路由选项，Traceroute不需要路由具备任何特殊的功能</strong></li><li>记录路由一般是单向的选项，发送端设置了该选项，那么接收端不得不从收到的IP首部中提取出所有的信息，然后全部返回给发送端。我们看到大多数ping服务器的实现（内核中的ICMP回显应答功能）把收到的RR清单返回，但是这样使得记录下来的IP地址翻了一番（一来一回）。（<strong>Traceroute 只需要目的端运行一个UDP模块，其他不需要任何特殊的服务器应用程序</strong>）</li><li>IP首部留给选项的空间有限，不能存放当前大多数的路径</li></ul><h4 id="3-2-Traceroute"><a href="#3-2-Traceroute" class="headerlink" title="3.2 Traceroute"></a>3.2 Traceroute</h4><ul><li><p><strong>可以看到一个IP数据报从一台主机到另一台主机所经过的路由</strong></p></li><li><p>Traceroute 使<strong>用ICMP报文和IP首部中的TTL字段（</strong>生存周期）。TTL字段由发送端初始设置一个8bit字段。当前为64。ping程序发送ICMP回显应答，经常把<strong>TTL设为最大值255</strong></p></li><li><p><strong>每个处理数据报的路由器都需要把TTL值减1或者减去数据报在路由器中停留的秒数</strong>。由于大多数的路由器转发数据报的时延都小于1s，因此<strong>TTL最终成为一个跳站的计数器</strong></p></li><li><p>当路由器收到一份IP数据报，如果其<strong>TTL字段是0或1，则路由器不转发该数据报（接收到这种数据报的目的主机可以将它交给应用程序，这是因为不需要转发该数据报。但是在通常情况下，系统不应接受TTL为0的数据报</strong>）。相反，路由器将该数据报丢弃，并给信源机发一份<strong>ICMP超时信息</strong>。Traceroute程序的关键在于<strong>包含这份ICMP信息的IP报文的信源地址是该路由器的IP地址</strong></p></li><li><p>如何判断是否已经到达目的主机？</p><ul><li>Traceroute发送一份<strong>UDP数据</strong>报给目的主机，但它选择一个不可能的值作为<strong>UDP端口号</strong>（大于30000，目的端口号），使目的主机的任何一个应用程序都不可能使用该端口。应为当该数据报到达时，将使目的主机的UDP模块产生一份“端口不可达”的ICMP报文。traceroute要做的就是<strong>区分接收到的ICMP报文是超时还是端口不可达，以判断什么时候结束</strong></li></ul></li><li><p><img src="http://image.blissseven.top/blog/20190409/qPpfqVrrcOPi.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190409/PLhtqitFI8bV.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190409/UFFb6roD2DBY.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190409/CuNoKNHiITBh.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190409/88QEjnhFf8ar.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190409/1jB4ssfPKaHQ.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190409/j5W7seTQliSE.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190409/6ix6qPXivdP4.png?imageslim" alt="mark"></p></li></ul><h4 id="3-3-IP源站选路选项"><a href="#3-3-IP源站选路选项" class="headerlink" title="3.3 IP源站选路选项"></a>3.3 IP源站选路选项</h4><ul><li>由发送者指定路由，有两种方式<ul><li><strong>严格的源站路由选择</strong>。<strong>发送端指明IP数据报所必须采用的确切路由</strong>。如果一个路由器发现源站路由所指定的下一个路由不在其直接链接的网络上，那么它就返回一个“源站路由失败”的ICMP差错报文。</li><li><strong>宽松的源站路由</strong>。<strong>发送端指明了一个数据报经过的IP地址清单</strong>，但是数据报在清单上指明的任意两个地址之间可以通过其他路由器。</li></ul></li><li>这个格式与记录路由选项格式基本一致。不同之处是，对于源站选路，必须在发送IP数据报前填充IP地址清单。而对于记录路由选项，需要为IP地址清单分配并清空一些空间，并让路由器填充该清单中的各项。同时，对于源站选路，只要为所需要的IP地址数分配空间并进行初始化，通常其数量小于9（预先填好值）。对于记录路由选项而说，必须尽可能分配空间，已达到9个地址。</li><li>对于宽松的源站选路而说，code的值为0x83；对于严格的源站选路，其值为0x89，len和ptr字段与路径记录部分所描述的一样。</li><li><img src="http://image.blissseven.top/blog/20190409/Ah6BhT9UVt8m.png?imageslim" alt="mark"></li></ul><h4 id="3-4-IP源站选路的操作机制"><a href="#3-4-IP源站选路的操作机制" class="headerlink" title="3.4 IP源站选路的操作机制"></a>3.4 IP源站选路的操作机制</h4><ul><li>源站路由选项的实际称呼为“源站及记录路由”，对于宽松的源站选路和严格的源站选路分别用LSRR 和SSRR表示，这是因为数据报在沿路由发送过程中，对IP地址清单进行了跟新<ul><li>a. 发送主机从应用程序接收源站路由清单，将第一个表项去掉（它为数据报的最终目的地址），将剩余的项移到1个项中，如下图，并将原来的目的地址作为清单的最后一项。指针仍然指向清单的第一项（即，指针值为4）</li><li>b.每个处理数据报的路由器都检测其是否为数据报的最终目的地址，如果不是，则正常转发数据报（在这种情况下，必须指明管送源站选路，否则就不能接收到该数据报）</li><li>c. 如果该路由器为最终目的，且指针不太与路径的长度，那么<ul><li><ol><li>由ptr所指定的清单中的下一个地址为数据报的最终目的地址</li><li>由外出接口相对应的IP地址取代刚才使用的源地址</li><li>指针+4</li></ol></li></ul></li></ul></li><li>Host Requirements RFC指明，TCP客户必须能指明源站选路，同时，TCP服务器必须能够接受源站选路，并且对于该TCP连接的所有保温都能采用反向路由。如果TCP服务器下面接收到一个不同的源站选路，那么新的源站路由将取代旧的源站路由。</li><li><img src="http://image.blissseven.top/blog/20190409/GD1mfjuVWRU6.png?imageslim" alt="mark"></li></ul><h4 id="3-5-IP选路"><a href="#3-5-IP选路" class="headerlink" title="3.5 IP选路"></a>3.5 IP选路</h4><ul><li>选路为IP最重要功能之一</li><li>如图为一个路由守护程序daemon，通常是一个用户进程</li><li>在unix系统中，大多数普通的守护程序都<strong>是路由程序和网关程序</strong></li><li>路由表经常被IP访问，但是它被路由守护程序更新的频度却低的很多</li><li>当接收到<strong>ICMP重定向报文</strong>时，路由表也要被更新</li><li>netstat显示路由表</li><li><img src="http://image.blissseven.top/blog/20190409/gC2Epali3XGQ.png?imageslim" alt="mark"></li><li>route print  /netstat -rn</li><li>选路原理<ul><li>1 搜索匹配的主机地址</li><li>2 搜索匹配的网络地址</li><li>3 搜索默认表项（默认表项一般在路由表中被指定为一个网络表项，其网络号为0）</li><li><strong>IP执行选路机制，而路由守护程序一般提供选路策略</strong></li></ul></li><li><img src="http://image.blissseven.top/blog/20190409/6BjTXm0gt4kv.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190409/L0w0nGhL2Jq7.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190409/9ymglpJc5zxj.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190409/ldiEhXlnzvq0.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190409/yqFUvOj9PaQv.png?imageslim" alt="mark"></li></ul><h4 id="第三天-1"><a href="#第三天-1" class="headerlink" title="第三天"></a>第三天</h4><h4 id="1-1-UDP介绍"><a href="#1-1-UDP介绍" class="headerlink" title="1.1 UDP介绍"></a>1.1 UDP介绍</h4><ul><li><p>UDP是一个简单的<strong>面向数据报</strong>的运输层协议：<strong>进程的每个输出操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据包</strong></p></li><li><p>与面向流字符的协议不同，如TCP，TCP的<strong>应用程序产生的全体数据</strong>与<strong>真正发送的单个IP数据报</strong>可能没有什么关系。</p></li><li><p>UDP不提供可靠性，它把应用程序传给IP层的数据发送出去，但是不保证它们能到达目的地</p></li><li><p>应用程序必须关心IP数据报的长度，如果超过网络的MTU，需要对IP数据报进行分片</p></li><li><p><img src="http://image.blissseven.top/blog/20190409/4qftmQp6yGyx.png?imageslim" alt="mark"></p></li><li><p><strong>UDP是制造IP分片的主要协议</strong></p></li><li><p>应用程序每有一个数据包，不管数据量大小，UDP就加上UDP头部，IP头部组成一个IP数据报发送</p></li><li><p>而TCP会选择合适的大小，小的数据包会组装成大的数据包，存在对流的控制</p></li><li><p>应用</p><ul><li>查询类DNS<ul><li>没有TCP三次握手，快</li><li>多个DNS同时查询</li></ul></li><li>数据传输TFTP<ul><li>停止等待协议，慢 （需应用层确认数据）</li><li>适合于无盘工作站</li></ul></li><li>语音视频流<ul><li>支持广播和组播</li><li>支持丢包，保障效率</li></ul></li></ul></li></ul><h4 id="1-2-UDP首部"><a href="#1-2-UDP首部" class="headerlink" title="1.2 UDP首部"></a>1.2 UDP首部</h4><ul><li><img src="http://image.blissseven.top/blog/20190409/dB39333NT9gh.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190409/jQ4QTm5THEq3.png?imageslim" alt="mark"></li><li>IP头部协议号<strong>ICMP</strong>:1  |  <strong>TCP</strong>:6  |  <strong>UDP</strong>:17  |  GRE:47  |  ESP:50  |  AH:51</li><li><strong>端口号，表示发送进程和接受进程</strong></li><li><strong>TCP端口号与UDP端口号是相互独立的</strong>（rsh和syslog=514）</li><li>尽管相互独立，如果TCP和UDP同时提供某种指明服务，<strong>两个协议通常选择相同的端口号</strong>，纯粹为了使用方便，而不是协议本身的要求（DNS 两个都是53端口）</li><li>UDP长度指的<strong>是UDP首部和UDP数据的字节长度，最小8字节</strong></li></ul><h4 id="1-3-UDP校验和"><a href="#1-3-UDP校验和" class="headerlink" title="1.3 UDP校验和"></a>1.3 UDP校验和</h4><ul><li>UDP校验和覆盖UDP首部和UDP数据</li><li>IP首部检验和覆盖IP首部</li><li><strong>UDP检验和可选，TCP校验和必须</strong></li><li>IP计算校验和和UDP计算校验和存在不同的地方。首先<strong>UDP数据报长度可以为奇数字节</strong>，但是校验和算法是把若干个16bit字相加。解决方法是必要时在最后添加填充字节0，只是为了校验和的计算（即，可能增加的填充字节不被传送）</li><li><strong>UDP数据报和TCP段都包含一个12字节的伪首部</strong>，<strong>是为了计算校验和而设置</strong>的。伪首部包含IP首部一些字段，其目的是让<strong>UDP两次检查数据是否已经正确到达目的地</strong>（e.g.IP不接受地址不是本主机的数据报，以及IP不会把应传给另一高层的数据报传给UDP）</li><li><img src="http://image.blissseven.top/blog/20190409/OmH3UaUwyOLS.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190409/VzLeVC3pXE95.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190409/c5b96RwV0yzx.png?imageslim" alt="mark"></li></ul><h4 id="1-4-IP分片"><a href="#1-4-IP分片" class="headerlink" title="1.4 IP分片"></a>1.4 IP分片</h4><ul><li>IP把MTU（出接口，出去的时候查看MTU）与数据报长度（IP头部+IP数据）比较</li><li>如果需要则进行分片。<strong>分片可以发生在原始发送端主机上，也可以发生在中间路由器上</strong></li><li>把一份IP数据报分片之后，<strong>只有到达目的地才进行重新组装</strong>(FR fragment)</li><li><strong>重新组装由目的端的IP层来完成</strong>，其目的是使分片和重新组装过程<strong>对传输层（TCP/UDP）是透明的</strong></li><li>已经分片过的数据报有可能会再次进行分片</li><li><img src="http://image.blissseven.top/blog/20190409/22nWjMi4DEeR.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190406/lp02PfVJt4c9.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190409/NPbesepxDKqv.png?imageslim" alt="mark"></li><li>16位标识，<strong>初始IP数据报唯一的标识符</strong></li><li>CU=0</li><li>DF =Do not Fragementation</li><li>MF =More Fragementation</li><li>IP数据报被分片后，<strong>每一片都成为一个分组</strong>，具有自己的IP首部，并在选择路由时与其它分组独立。这样，当数据报的这些片到达目的端时<strong>有可能会失序</strong>，但是在IP首部种有足够的信息让接收端能正常组装这些数据报片</li><li>尽管IP分片过程看起来透明，有个缺点：<strong>即使只丢失一片数据也要重传整个数据报</strong></li><li>IP层本身没有超时重传的机制—由更高层来负责超时和重传（TCP有超时和重传机制，但UDP没有。一些UDP应用程序本身也执行超时和重传）。当来自TCP报文段的某一片丢失后。TCP在超时后会重发整个TCP报文段，该报文段对应于一份数据报。<strong>没有办法只重传数据报中一个数据报片。</strong></li><li>如果对数据报分片的是中间路由器，而不是起始端系统，那么起始段系统就无法知道数据报是如何被分片的。所以，要避免分片。</li><li><img src="http://image.blissseven.top/blog/20190409/e0LeBr1AjVDI.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190409/IT3XVNWjUY5T.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190409/RW6eXnulYTmJ.png?imageslim" alt="mark"></li><li>分片注意事项<ul><li>分片时，除最后一片外，其它每一片中的数据部分（<strong>除IP首部外的其余部分，IP负载）必须为8字节的整数倍</strong></li><li>IP首部被复制到各个分片中，但是端口号在UDP首部（传输层信息），只在第一片中被发现</li><li>IP数据报是指<strong>IP层端到端的传输单元</strong>（在分片之前和重新组装之后），<strong>分组是指在IP层和链路层之间传送的数据单元</strong>。<strong>一个分组可以是一个完整的IP数据报，也可以是IP数据报的一个分片</strong></li><li><img src="http://image.blissseven.top/blog/20190409/Ek4glDhjPwHo.png?imageslim" alt="mark"></li><li>IP数据报数据范围为46-1500，所以垫片=6</li><li></li></ul></li><li>路径MTU Path MTU</li><li>由于在整个数据包传输过程中，可能在多个节点经历分片。所以如果希望数据报总是不会被分片，就需要用这个路径上最小的MTU来发送数据包。这个在一个路径的某一个方向上最小的MTU就是路径MTU。两个方向上的path mtu可能不一样</li></ul><h4 id="1-5-ICMP不可达差错（需要分片）"><a href="#1-5-ICMP不可达差错（需要分片）" class="headerlink" title="1.5 ICMP不可达差错（需要分片）"></a>1.5 ICMP不可达差错（需要分片）</h4><ul><li><img src="http://image.blissseven.top/blog/20190409/JsJa9lfXdKdd.png?imageslim" alt="mark"></li><li>发生ICMP不可达差错的另一种情况是，<strong>当路由器收到一份需要分片的数据报1，而在IP首部又设置了不分片（DF）的标志bit</strong>。如果每个程<strong>序需要判断到达目的端的路径中最小MTU是多少–称作路径MTU发现机制，那么这个差错就可以被程序利用</strong></li><li>如果路由器没有提供这种新的ICMP差错报文，那么下一站的MTU就设为0</li><li><img src="http://image.blissseven.top/blog/20190409/pxwEXAHuTSoI.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190409/kueY0afaNUyz.png?imageslim" alt="mark"></li></ul><h4 id="1-6-最大UDP数据报长度"><a href="#1-6-最大UDP数据报长度" class="headerlink" title="1.6 最大UDP数据报长度"></a>1.6 最大UDP数据报长度</h4><ul><li>IP数据报最大长度为65535字节，由IP首部16bit总长度字段限制</li><li>限制1： <strong>应用程序可能会受到其程序接口的限制</strong>。socket API提供了一个可供引用程序调用的函数，已设置接受和发送缓存的长度。对于UDP socket，这个长度与应用程序可以读写的最大UDP数据报的长度直接相关。</li><li>限制2：<strong>TCP/IP内核的实现</strong>。可能存在一些实现特性，使ip数据报长度小于65535字节。这个限制与<strong>源端和目的端的实现</strong>有关</li><li>3.2节中提到，要求主机必须能够接收最短为576字节的IP数据报。在许多UDP应用程序设计中，其应用程序数据被限制成512字节或更小，因此比这个限制小。</li><li><img src="http://image.blissseven.top/blog/20190409/3QaNpGuWieFH.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190409/LeBTqFelUsNf.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190409/jSCvNB7XMJk2.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190409/eR74jDHybHcj.png?imageslim" alt="mark"></li></ul><h4 id="2-1-广播与多播"><a href="#2-1-广播与多播" class="headerlink" title="2.1 广播与多播"></a>2.1 广播与多播</h4><ul><li><p>三种IP地址：<strong>单播地址、广播地址、多播地址</strong></p></li><li><p>广播和多播进应用于UDP，它们对需将报文传往多个接收者的应用来说重要</p></li><li><p>TCP是一个面向连接的协议，它意味着分别运行于两主机（由IP地址确定）内的两个进程（由端口号确定）间存在一条连接，一定单播</p></li><li><p>有时一个主机要向网络上的所有其他主机发送帧，即，广播。通过ARP和RARP可以看到该过程</p></li><li><p>多播处于单播和广播之间：帧仅传送给属于多播组的多个主机</p></li><li><p><img src="http://image.blissseven.top/blog/20190409/mMKkOOra6LUk.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190409/OCVh5jsxyAhl.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190409/JXHiWe0ToTHP.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190409/E3lscMiAXE6V.png?imageslim" alt="mark"></p></li><li><p>抓包程序，网卡都是杂合模式</p></li><li><p>组播在设备驱动程序（链路层）就已经被丢弃了</p></li><li><p>广播在UDP（传输层）之后被丢弃，消耗PC资源</p></li></ul><h4 id="2-2-广播"><a href="#2-2-广播" class="headerlink" title="2.2 广播"></a>2.2 广播</h4><ul><li><p><img src="http://image.blissseven.top/blog/20190409/055eq0bFaJo0.png?imageslim" alt="mark"></p></li><li><p><strong>受限的广播 255.255.255.255</strong></p></li><li><p>指向网络的广播 10.255.255.255 192.168.1.255 //netid.255.255.255</p><ul><li><strong>指向网络的广播地址是主机号为全1的地址</strong>。A类网络广播地址为netid.255.255.255，其中netid为A类网络的网络号。</li><li>一个路由器必须转发指向网络的广播，但它也必须有一个不进行转发的选择。</li></ul></li><li><p>指向子网的广播 10.1.1.255 10.1.255.255  //跟子网掩码 netid.subnetid.255</p><ul><li><strong>指向子网的广播地址为主机号为全1且有特定子网号的地址</strong>。作为子网直接广播地址的IP地址需要了解子网的掩码。</li><li>例如，如果路由器收到发往128.1.2.255的数据报，当B类网络128.1的子网掩码为255.255.255.0时，该地址就是指向子网的广播地址；但如果该子网的掩码为255.255.254.0，该地址就不是指向子网的广播地址。</li></ul></li><li><p>指向所有子网的广播 10.255.255.255// 跟指向子网的广播地址不一样 //netid.255.255</p><ul><li>指向所有子网的广播也需要了<strong>解目的网络的子网掩码</strong>，以便与指向网络的广播地址区分开。<strong>指向所有子网的广播地址的子网号及主机号</strong>为全1。</li><li>例如，如果目的子网掩码为255.255.255.0，那么IP地址128.1.255.255是一个指向所有子网的广播地址。<strong>然而，如果网络没有划分子网，这就是一个指向网络的广播。</strong></li></ul></li><li><p>主机处理的地址 192.168.255.255 cisco路由支持</p></li><li><p>路由器支持255.255.255.255 主机不支持（当主机处理）</p></li><li><p><strong>最常用的是指向子网的广播。受限的广播通常只在系统初始启动时才会用到</strong>。</p></li></ul><h4 id="2-3-组播"><a href="#2-3-组播" class="headerlink" title="2.3 组播"></a>2.3 组播</h4><ul><li><p><img src="http://image.blissseven.top/blog/20190409/4oN1sWJSwGa5.png?imageslim" alt="mark"></p></li><li><p><strong>多播组地址包括为1110的最高4bit和多播组号。通常可表示为点分十进制数，范围从224.0.0.0到239.255.255.255</strong></p></li><li><p>能够<strong>接收发往一个特定多播组地址数据的主机集合</strong>称为主机组(host group)。一个主机组可跨越多个网络。主机组中成员可随时加入或离开主机组。主机组中对主机的数量没有限制，同时<strong>不属于某一主机组的主机可以向该组发送信息</strong>。</p></li><li><p>一些多播组地址被IANA确定为知名地址。它们也被当作永久主机组，这和TCP及UDP中的熟知端口相似。同样，这些知名多播地址在RFC最新分配数字中列出。注意这些多播地址所代表的组是永久组，而它们的组成员却不是永久的。</p><p>例如，224.0.0.1代表“该子网内的所有系统组”，224.0.0.2代表“该子网内的所有路由器组”。<strong>多播地址224.0.1.1用作网络时间协议NTP</strong>，224.0.0.9用作RIP-2(见10.5节)，224.0.1.2用作SGI公司的dogfight应用。</p></li><li><p>IANA拥有一个<strong>以太网地址块，即高位24 bit为00:00:5e</strong>（十六进制表示），这意味着该地址块所拥有的地址范围从00:00:5e:00:00:00到00:00:5e:ff:ff:ff。IANA将其中的一半分配为多播地址。<strong>为了指明一个多播地址，任何一个以太网地址的首字节必须是01</strong>，这意味着<strong>与IP多播相对应的以太网地址范围从01:00:5e:00:00:00到01:00:5e:7f:ff:ff。</strong></p></li><li><p><strong>这种地址分配将使以太网多播地址中的23bit与IP多播组号对应起来，通过将多播组号中的低位23bit映射到以太网地址中的低位23bit实现</strong>，这个过程如图12-3所示。</p></li><li><p>由于<strong>多播组号中的最高5bit在</strong>映射过程中被忽略，因此<strong>每个以太网多播地址对应的多播组是不唯一的</strong>。32个不同的多播组号被映射为一个以太网地址。例如，多播地址224.128.64.32（十六进制e0.80.40.20）和224.0.64.32（十六进制e0.00.40.20）都映射为同一以太网地址01:00:5e:00:40:20。</p></li><li><p>既然<strong>地址映射是不唯一的，设备驱动程序或IP层就必须对数据报进行过滤</strong>。因为网卡可能接收到主机不想接收的多播数据帧。</p></li><li><p>单个物理网络的多播是简单的。多播进程将目的IP地址指明为多播地址，设备驱动程序将它转换为相应的以太网地址，然后把数据发送出去。这些接收进程必须通知它们的IP层，它们想接收的发往给定多播地址的数据报，并且设备驱动程序必须能够接收这些多播帧。这个过程就是“加入一个多播组”（使用“接收进程”复数形式的原因在于对一确定的多播信息，在同一主机或多个主机上存在多个接收者，这也是为什么要首先使用多播的原因）。当一个主机收到多播数据报时，它必须向属于那个多播组的每个进程均传送一个复制。这和单个进程收到单播UDP数据报的UDP不同。使用多播，一个主机上可能存在多个属于同一多播组的进程</p></li><li><p><img src="http://image.blissseven.top/blog/20190409/suaj3D2PWdCY.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190409/sImkY0lnhX4X.png?imageslim" alt="mark"></p></li><li></li></ul><h4 id="3-1-DNS-介绍"><a href="#3-1-DNS-介绍" class="headerlink" title="3.1 DNS 介绍"></a>3.1 DNS 介绍</h4><ul><li><p>Host文件 C：\Windows\System32\drivers\etc\hosts  /etc/hosts</p></li><li><p>用于<strong>TCP/IP应用程序的分布式数据库，提供主机名字和IP地址之间的转换以及有关电子邮件的选录信息</strong></p></li><li><p>分布式是指在Internet上的单个站点不能拥有所有的信息</p></li><li><p>DNS提供了允许服务器和客户程序相互通信的协议</p></li><li><p>对DNS的访问是<strong>通过一个地址解析器（resolver）</strong>来完成的</p></li><li><p>解析器通常是应用程序的一部分。解析器并不像TCP/IP协议那样是操作系统的内核</p></li><li><p>操作系统内核中的TCP/IP协议簇对于DNS一点都不知道</p></li><li><p><img src="http://image.blissseven.top/blog/20190409/dRG1vxlj2dfI.png?imageslim" alt="mark"></p></li></ul><h4 id="3-2-DNS服务器"><a href="#3-2-DNS服务器" class="headerlink" title="3.2 DNS服务器"></a>3.2 DNS服务器</h4><ul><li><p>本章介绍如何使用TCP/IP协议（主要是UDP）与名字服务器通信，不介绍运行名字服务器或有关可选参数的细节</p></li><li><p>各个域的分层上都有各自的域名服务器</p></li><li><p><strong>各层域名服务器都了解该层以下分层中所有域名服务器的IP地址</strong>。因此它们从根域名服务器开始成树状结构</p></li><li><p>由于所有域名服务器都了解根域名服务器的地址，所以若从根开始按照顺序追踪，可以访问世界上所有域名服务器</p></li><li><p><img src="http://image.blissseven.top/blog/20190409/wgJUgc277bGC.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190409/2niTNaIuz2oL.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190409/3URNoIVX5pNQ.png?imageslim" alt="mark"></p></li></ul><h4 id="3-3-DNS报文"><a href="#3-3-DNS报文" class="headerlink" title="3.3 DNS报文"></a>3.3 DNS报文</h4><ul><li><p><img src="http://image.blissseven.top/blog/20190409/tXgSmbLx1nbI.png?imageslim" alt="mark"></p></li><li><p>报文有<strong>12字节的首部和4个长度可变的字段</strong>组成。</p></li><li><p>标识字段由客户程序设置并又服务器返回结果。客户程序通过它来确定相应与查询是否匹配</p></li><li><p>16bit标志字段</p><ul><li><img src="http://image.blissseven.top/blog/20190410/2b96RK2EP6xH.png?imageslim" alt="mark"></li><li>QR 1bit 0表示查询报文，1表示响应报文</li><li>opcode 4bit 0 标准查询 1 反向查询 2 服务器状态请求</li><li>AA 1bit 授权回答  该名字服务器是授权于该域的</li><li>TC 1bit 截断的 使用UDP时，它表示当应答的总长度超过512字节时，只返回前512个字节。</li><li>RD 1bit 期望递归 </li><li>RA 1bit 可用递归</li><li>rcode 4 bit返回码 0没有差错 3 名字差错</li><li>随后的4个16 bit字段说明最后4个变长字段中包含的条目数。对于查询报文，问题(question)数通常是1，而其他3项则均为0。类似地，对于应答报文，回答数至少是1，剩下的两项可以是0或非0。</li></ul></li><li><p>查询问题</p><ul><li><img src="http://image.blissseven.top/blog/20190410/JhMF9LeGhKm0.png?imageslim" alt="mark"></li><li><strong>查询名是要查找的名字，它是一个或多个标识符的序列</strong>。<strong>每个标识符以首字节的计数值来说明随后标识符的字节长度，每个名字以最后字节为0结束，长度为0的标识符是根标识符</strong>。计数字节的值必须是<strong>0~63的数</strong>，因为标识符的最大长度仅为63</li><li><img src="http://image.blissseven.top/blog/20190410/DSTVNmr4HImO.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190410/DVH5Qkn7BkOB.png?imageslim" alt="mark"></li></ul></li><li><p>资源记录部分</p><ul><li><p>DNS报文中最后的三个字段，回答字段、授权字段和附加信息字段，均采用一种称为资源记录RR（Resource Record）的相同格式。图14-8显示了资源记录的格式。</p></li><li><p><img src="http://image.blissseven.top/blog/20190410/F0bSiE6Sw2YD.png?imageslim" alt="mark"></p></li><li><p>域名为记录中资源数据对应的名字。格式与查询名字段格式相同</p></li><li><p>类型说明为RR的类型码。值与之前的查询类型值相同。类通常为1，指internet数据。</p></li><li><p>生存时间时是客户程序保留该资源记录的秒数，资源记录通常的生存时间通常2天。</p></li><li><p><img src="http://image.blissseven.top/blog/20190410/fPIa7nHjv4WO.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190410/YCs6uenfotXb.png?imageslim" alt="mark"></p></li></ul></li></ul><ul><li><p><img src="http://image.blissseven.top/blog/20190410/SoeBbTeVovDR.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190410/aPtBL9e6PI2N.png?imageslim" alt="mark"></p></li></ul><h4 id="4-1-TFTP简介"><a href="#4-1-TFTP简介" class="headerlink" title="4.1 TFTP简介"></a>4.1 TFTP简介</h4><ul><li><p>Trivial File Transfer Protocol 简单文件传送协议，运行在UDP 端口69，缺乏FTP的高级特性，TFTP只负责将文件写入到远端服务器或者从远端服务器上读取文件。不能够列举、删除或者重命名文件或者目录，并且也不提供用户认证。目前，通常只在局域网内。</p></li><li><p>传输由client发起，发起一个request来读或者写server上的文件。client可以在request中包含一些可选的参数来和server进行协商。如果server允许这个request，那么文件默认以512字节为一个块或者用协商的大小来发送。为了防止IP分片。每个被传输的块通常被携带在一个IP包中。并且在下一块被传送之前，需要发送确认。如果包小于默认的512字节或者协商的大小，意味着传输要终止</p></li><li><p><img src="http://image.blissseven.top/blog/20190410/qcDM7wFyc5af.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190410/A5mLl2n9d7Ac.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190410/citdSNVKwv5g.png?imageslim" alt="mark"></p></li><li><p>模式字段是一个ASCII码串netascii或octet（可大小写任意组合），<strong>同样以0字节结束</strong>。netascii表示数据是<strong>以成行的ASCII码字符组成，以两个字节—回车字符后跟换行字符（称为CR/LF）作为行结束符</strong>。这两个<strong>行结束字符在这种格式和本地主机使用的行定界符之间进行转化</strong>。octet则将<strong>数据看作8bit一组的字节流而不作任何解释</strong>。</p></li><li><p><img src="http://image.blissseven.top/blog/20190410/GiwDf8jydbpe.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190410/IW9Jtr6HKj8m.png?imageslim" alt="mark"></p></li></ul><h4 id="第四天-1"><a href="#第四天-1" class="headerlink" title="第四天"></a>第四天</h4><h4 id="1-1-TCP介绍"><a href="#1-1-TCP介绍" class="headerlink" title="1.1 TCP介绍"></a>1.1 TCP介绍</h4><ul><li><img src="http://image.blissseven.top/blog/20190410/wW2WHTds8xrC.png?imageslim" alt="mark"></li><li>UDP是一种没有复杂控制，提供面向无连接通信服务的一种协议。将部分控制转移给应用程序去处理（e.g.TFTP），自己只提供作为传输层协议的最基本功能</li><li>TCP 对传输、发送、通信进行控制的协议，只有在确认通信对端存在时才会发送数据，从而控制通信流量的浪费，根据TCP这些机制，在IP这种无连接的网络上也能够实现高可靠性的通信。</li><li><strong>TCP的可靠性</strong><ul><li><strong>应用数据被分割</strong>为TCP认为最为合适发送的数据块</li><li>TCP发出一个字段后，<strong>启动一个定时器</strong>，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段</li><li>当TCP收到来自TCP连接另一端的数据，将发送一个确认。这个确认不是理机发送，<strong>通常延迟几分之一秒</strong>，200ms。delayed_ack</li><li>TCP保持<strong>首部和数据的校验和</strong></li><li>TCP报文段作为IP数据报来传输，而IP数据报的到达有可能会失序，TCP报文段的到达也可能失序。如果必要，<strong>TCP对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层</strong>。</li><li><strong>TCP提供对流量的控制</strong>。TCP连接的每一方都有固定大小的缓冲空间。<strong>TCP的接收端只允许另一端发送  接收端缓冲区所能容纳的数据。</strong>这将防止较快主机致使较慢主机的缓冲区溢出</li></ul></li><li>TCP的字节流<ul><li>两个应用程序通过TCP连接交换8bit字节构成<strong>字节流</strong>。<strong>TCP不在字节流中插入记录标识符</strong>。称“字节流服务”。如果一方的应用程序先传10字节，又传20字节，再传50字节，连接的另一方将无法了解发送方每次发送了多少字节。收方可以分四次接收这80个字节，每次接受二十字节。一端将字节流放到TCP连接上，同样的字节流将出现在TCP连接的另一端</li><li>TCP对字节流的内容不做任何解释。TCP不知道传输的数据字节流是二进制数据亦或ASCII字符。对字节流的解释由TCP连接双方的应用层解释</li></ul></li></ul><h4 id="1-2-TCP首部"><a href="#1-2-TCP首部" class="headerlink" title="1.2 TCP首部"></a>1.2 TCP首部</h4><ul><li><img src="http://image.blissseven.top/blog/20190410/8AMLnhHgXyzf.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190410/OGm31qwaIIEz.png?imageslim" alt="mark"></li><li>每个<strong>TCP段都包含源端和目的端的端口号，用于寻找发送端和收端应用进程</strong>。IP分用。<strong>这两个值和IP首部中的源端IP地址和目的端IP地址唯一确定一个TCP连接</strong>。五元组唯一确定session（+protocl）</li><li>一个IP地址和一个端口也成为一个插口（socket）插口对（socketpair）</li><li>序号用来标识从TCP发端向TCP收端发送的数据字节流，它标识在这个报文段中的<strong>第一个数据字节的序号</strong>。<strong>不会从0或1开始，而是在建立连接时由计算机生成的随机数作为其初始值</strong>。？？？？如果将字节流看作在两个应用程序间的单向流动，则TCP用序号对每个字节进行计数。<strong>序号为32bit的无符号数，序号到达2的32次方减1后又从0开始</strong>。SYN标志消耗了一个序号（FIN标志也占了一个序号）</li><li>确认序号是上次已成功收到数据字节序号加1。只有ACK标志位1时确认序号字段才有效。</li><li><strong>发送ACK无需占用任何序号</strong>，因为32bit的确认序号字段和ACK标志一样，总是TCP首部的一部分。因此，我们看到一旦一个连接建立起来，这个字段总是被设置,ACK标志也总是被设置为1</li><li>TCP为应用层提供<strong>全双工服务</strong>。数据可以在两个方向上独立进行传输，因此，<strong>连接的每一端都必须保持每个方向上的传输数据序号</strong>。</li><li>TCP可以表述为一个没有选择确认或否认的滑动窗口协议，（目前可以选择确认option SACK）。例如如果2-1024字节已经成功收到，下一报文段中包含序号2049-3072的字节，收端不能确认这个新的报文段，所能做的就是发挥一个确认序号为1025的ACK。无法对一个报文进行否认。例如，1024-2048字节的报文检验和出错，TCP接收端能做的就是发回一个确认序号为1024的ACK</li><li>数据偏移，或者首部长度，表示TCP所传输的数据部分应该从TCP报的那个位开始计算，4个bit，字节位4字节（32bit）,没有选项字段的话，TCP首部20字节，可设置为5。TCP头部最大15*4=60字节</li><li><img src="http://image.blissseven.top/blog/20190410/8DGswJwtNps0.png?imageslim" alt="mark"><ul><li>URG ，包中有紧急处理的数据</li><li>ACK，为1时，确认应答的字段有效，TCP规定除了最初建立连接时的SYN报之外，该位必须为1</li><li>PSH 为1时，表示将收到的数据立刻传给上传应用协议，否则可先进行缓存</li><li>RST 为1时，TCP连接中出现异常必须强制断开连接。</li><li>SYN 为1时，<strong>希望建立连接，并在其序列号的字段进行序列号初始化值的设定</strong></li><li>FIN 为1时，表示今后不会再有数据发送，希望断开连接（单向传输断开）。当通信结束希望断开连接时，<strong>通信双方的主机就可以相互交换FIN位置为1的TCP段</strong>。每个主机又对对方的fin包进行确认应答后就可以断开连接。<strong>主机收到FIN设置为1的TCP段后不必立即回复FIN包，而是可以等到缓存区中所有数据都已成功发送而被自动删除后再发</strong>（关闭连接）</li><li><img src="http://image.blissseven.top/blog/20190410/t0xBR4pQNU1p.png?imageslim" alt="mark"></li></ul></li><li>窗口大小<ul><li>16bit，流量控制，用于通知从相同的TCP首部确认应答号所指位置开时能够接受的数据大小（8位字节）TCP不允许发送超过此处所表示大小的数据。窗口为0表示可以发送窗口探测，以了解最新窗口大小。但这个数据必须为1个字节。再下一次确认之前，最多发送这么多字节，接收方的流控</li></ul></li><li>校验和<ul><li><img src="http://image.blissseven.top/blog/20190410/mDxTB7JDNdtn.png?imageslim" alt="mark"></li><li>TCP检验和覆盖TCP首部和TCP数据，TCP校验和必须，而UDP简要和可选，TCP/UDP检验和都要加上12字节的伪首部</li></ul></li><li>紧急指针<ul><li>16bit，只在URG控制位为1时有效。表hi本报文段中紧急数据的指针。正确来讲，从数据部分的首位到紧急指针所指示的位置为止都为紧急数据。紧急指针指出了紧急数据的末尾再报文段中的位置</li><li>如何处理紧急数据属于应用层问题</li></ul></li><li>选项<ul><li>用于提高TCP的传输性能，根据数据偏移（首部长度）进行控制所以其长度最大为字节</li><li>为32 bit的整数倍</li><li><img src="http://image.blissseven.top/blog/20190410/fIBeFlrwkOnU.png?imageslim" alt="mark"></li><li>MSS ，<strong>每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志的那个段）中指明这个选项。指明本端所能接收的最大长度的报文段</strong></li><li><img src="http://image.blissseven.top/blog/20190410/MRcgT5BKDH1J.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190410/paNXC469JwnH.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190410/DJJUXIPGNA0q.png?imageslim" alt="mark"></li></ul></li></ul><h4 id="1-2-连接的管理"><a href="#1-2-连接的管理" class="headerlink" title="1.2 连接的管理"></a>1.2 连接的管理</h4><ul><li>TCP提供<strong>面向连接</strong>的通信传输。UDP是<strong>面向无连接</strong>的通信协议，不检查对端是否可以通信，直接将UDP包发送出去。TCP与此相反，会在数据通信之前，通过TCP首部发送一个SYN包作为建立连接的请求等待确认回答。如果对端发来确认应答，则认为可以进行数据通信。此外，在通信结束后会进行断开连接的处理（FIN包）</li><li>TCP首部用于控制的字段来管理TCP连接，一个链接的建立和断开，正常过程至少来回发送7个包</li><li><img src="http://image.blissseven.top/blog/20190410/myMlC8kVKXdt.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190410/BP8YLRhcf67t.png?imageslim" alt="mark"></li><li>发送第一个SYN的一端执行主动打开（active open），接收这个SYN并发送下一个SYN的另一端执行被动打开（passive open）</li><li>当一端为建立连接而发送它的SYN是，它为连接选择一个初始序号。ISN随时间而变化，且每个连接都有不同的ISN。RFC793指出ISN可看作一个32bit的计数器。每4ms加1。<strong>这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释</strong>。</li><li><img src="http://image.blissseven.top/blog/20190410/XBJNDJwAWBE5.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190410/nkwneo2RWLr6.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190410/tAi4YnnpGdQE.png?imageslim" alt="mark"></li><li>客户通过向服务器发送一个SYN来创建要给主动打开，做欸三次握手的一部分。客户端把这段连接的序号设定为随机数A</li><li>服务器端应当为要给合法的SYN回送一个SYN/ACK。ACK的确认码为A+1，SYN/ACK包本身又有一个随即序号B</li><li>最后客户端再发送一个ACK。当服务端收到这个ACK后，就完成了握手，并进入连接创建状态。此时报序号被设定为收到的确认号A+1，而相应则为B+1。</li></ul><h4 id="1-3连接的断开"><a href="#1-3连接的断开" class="headerlink" title="1.3连接的断开"></a>1.3连接的断开</h4><ul><li><img src="http://image.blissseven.top/blog/20190410/38cW6kia9qgt.png?imageslim" alt="mark"></li><li>SYN 起始序号 结束序号 最大的报文大小</li><li>建立一个连接需要三次握手，而终止一个连接需要四次握手。与TCP的半关闭有关。既然一个TCP连接是全双工的，因此每个方向必须单独的进行关闭。当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向上的连接。当一端收到了FIN，它必需通知应用层另一端终止那个方向的数据传送。发送FIN通常是应用层进行关闭的结果</li><li>收到一个FIN只意味着这一方向上没有数据留档。一个TCP连接在收到一个FIN后仍能发送数据。而这对于半关闭的应用来说是可能的，尽管在实际的应用中只有很少的TCP应用程序会这么做</li><li>首先进行关闭的一方进行主动关闭，另一方执行被动关闭</li><li><img src="http://image.blissseven.top/blog/20190410/sO5VAduFhh3o.png?imageslim" alt="mark"></li><li>还可以发ACK，关闭是关闭数据传输</li><li><strong>发送Fin将导致应用程序关闭它们的连接。这些FIN的ACK是TCP软件自动完成的</strong></li><li><img src="http://image.blissseven.top/blog/20190410/B576otwzRfgk.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190410/TrLTBiSYdkXP.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190410/SM29VQ2PsI7X.png?imageslim" alt="mark"></li></ul><h4 id="1-4-连接建立的超时"><a href="#1-4-连接建立的超时" class="headerlink" title="1.4 连接建立的超时"></a>1.4 连接建立的超时</h4><ul><li><img src="http://image.blissseven.top/blog/20190410/YokR62cdl19G.png?imageslim" alt="mark"></li><li>第一个SYN的重发机制</li><li>第二个SYN和第一个差5.8s，第三个和第二个差24s</li><li>大多数伯克利系统将建立一个新连接的最长时间限制为75s</li><li><img src="http://image.blissseven.top/blog/20190410/3YifFDoG141b.png?imageslim" alt="mark"></li></ul><h4 id="1-5-最大报文长度"><a href="#1-5-最大报文长度" class="headerlink" title="1.5 最大报文长度"></a>1.5 最大报文长度</h4><ul><li>并不是任何条件下都可协商。当建立一个连接时，每一方都有用于通告它期望接收的MSS选项（MSS选项只能出现在SYN报文中）。如果一方不接受来自另一方的MSS值，默认为536字节</li><li>一般，如果没有分段发生，MSS越大越好。报文段越大允许每个报文段传送的数据越多，相对IP和TCP首部有更高的网络利用率。当TCP发送一个SYN时，都能将MSS值设置为外出接口上的MTU长度减去固定的IP首部和TCP首部长度。对于一个以太网，MSS可达1460字节。IEEE802.3封装最大1452字节</li><li>如果目的IP地址为“非本地的 nonlocal”，MSS通常默认为536。如果目的IP网络号和子网号和我们的都相同，那么就是本地的。如果网络号相同，子网号不同，那么可能时本地的，也可能不是本地的。大多数TCP实现都提供了一个配置选项，让管理员说明不同的子网是属于本地的还是非本地的。这个选项的设置将确定MSS可以选择尽可能的大或者默认536。</li><li><img src="http://image.blissseven.top/blog/20190410/5B1NlCVxrgjT.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190410/8uDaGhaQidqw.png?imageslim" alt="mark"></li><li></li></ul><h4 id="1-6-TCP的半关闭"><a href="#1-6-TCP的半关闭" class="headerlink" title="1.6 TCP的半关闭"></a>1.6 TCP的半关闭</h4><ul><li>很少程序使用</li><li><img src="http://image.blissseven.top/blog/20190410/73xE8O6erY41.png?imageslim" alt="mark"></li></ul><h4 id="1-7-TCP状态变迁图"><a href="#1-7-TCP状态变迁图" class="headerlink" title="1.7 TCP状态变迁图"></a>1.7 TCP状态变迁图</h4><ul><li><img src="http://image.blissseven.top/blog/20190410/DIllWQiYhe9H.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190410/Ou1Q34TIaU52.png?imageslim" alt="mark"></li></ul><h4 id="1-8-2MSL-等待状态"><a href="#1-8-2MSL-等待状态" class="headerlink" title="1.8 2MSL 等待状态"></a>1.8 2MSL 等待状态</h4><ul><li>TIME_WAIT状态也称2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（maximum Segment Lifttime）。它是任何报文段被丢弃前在网络内的最长时间</li><li>原因<ul><li><strong>如果服务器再发送FIN后，没有收到客户端的ack。超过重传事件后，服务器重新发送FIN。此时客户端再发送ACK。如果没有TIME_WAIT状态，服务器可能一直收不到ACK，一直保持该会话</strong></li><li>重传超时时间RTO，RTT往返时间,一般小于30s 1分钟 2分钟</li></ul></li><li>RFC 793指出MSL为两分钟。实际实现为30s，1分钟或2分钟</li><li>对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个TCP主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留时间为2倍的MSL。这样可以让TCP再次发送最后的ACK以防止这个ACK丢弃（另一端超时并重发最后的FIN）</li><li>这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，<strong>定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能在被使用</strong>。这个连接只能在2MSL结束后才能被使用</li><li><strong>在连接处于2MSL等待时，任何迟到的报文段将被丢弃。因为处于2MSL等待的、由该插口对定义的连接在这段时间不能被再用</strong>，因此当要建立一个有效的连接时，来自该连接的一个较早替身的迟到报文段作为新连接的一部分不可能不被曲解。</li><li><img src="http://image.blissseven.top/blog/20190410/jxF3eEh5kU1I.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190410/C6rVt1YyvT05.png?imageslim" alt="mark"></li><li>客户执行主动关闭并进入TIME_WAIT状态是正常的。服务器通常执行被动关闭，不会进入TIME_WAIT状态。这暗示如果终止一个客户程序并重新启动这个客户程序，则这个新客户程序将不能重用相同的本地端口。</li><li>对于服务器，使用熟知端口。如果我们终止一个已经建立连接的服务器程序，并试图立即重新启动这个服务器程序，服务器程序将不能把它的这个熟知端口赋值给它的端点，因为那个端口处于2MSL连接的一部分。</li></ul><h4 id="1-9-平静时间"><a href="#1-9-平静时间" class="headerlink" title="1.9 平静时间"></a>1.9 平静时间</h4><ul><li>对于来自于某个连接的较早替身的迟到报文段，2MSL等待可防止将它解释称相同插口对的新连接的一部分。但这只有再处于2MSL等待连接中的主机处于正常工作状态时才有效</li><li>如果使用处于2MSL等待端口的主机出现故障，它会在MSL秒内重新启动，并立即使用故障前仍处于2MSL的插口对来建立一个新的连接吗？？如果是这样，在故障前从这个连接发出而迟到的报文段会被错误的当作属于重启后新连接的报文段。无论如何选择重启后新连接的初始序号，都会发生这种情况</li><li>为了防止这种情况，RFC793指出TCP在重新启动后的MSL秒内不能建立任何连接，这就是平静时间（quite time）</li><li>只有极少数的实现版遵守这一规则，因为大多数主机重新启动的时间都比MSL时间长</li></ul><h4 id="1-10-FIN-WAIT-2状态"><a href="#1-10-FIN-WAIT-2状态" class="headerlink" title="1.10 FIN_WAIT_2状态"></a>1.10 FIN_WAIT_2状态</h4><ul><li>在FIN_WAIT_2状态我们已经发出了FIN，并且另一端也已对它进行确认。除非我们在实行半关闭，否则将等待另一端的应用层意识到它已收到一个文件描述符说明，并向我们发一个FIN来关闭另一个方向的连接。只有当另一端的进程完成这个关闭，我们才会从FIN_WAIT_2状态进入TIME_WAIT状态。</li><li>这意味着我们这有可能永远保持这个状态。另一端也将处于CLOSE_WAIT状态，并一直保持这个状态直到应用层决定进行关闭</li><li>一般防火墙都有解决半关闭（FIN_WAIT_2）的超时时间设置，如果超时，防火墙会向双方发送RSET(伪装源)来踢掉连接。</li></ul><h4 id="1-11复位报文段"><a href="#1-11复位报文段" class="headerlink" title="1.11复位报文段"></a>1.11复位报文段</h4><ul><li>TCP首部的RST比特</li><li>无论何时一个报文段发往基准的连接（reference connection）出现错误，TCP都会发出一个复位报文段（基准的链接是指有目的IP地址和目的端口号以及源IP地址和源端口号指明的连接）。</li><li><img src="http://image.blissseven.top/blog/20190410/EpleNQvg1BvN.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190410/wbRPLy9zOu1g.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190410/VAsgOIUMPkds.png?imageslim" alt="mark"></li></ul><h4 id="1-12-同时打开、关闭"><a href="#1-12-同时打开、关闭" class="headerlink" title="1.12 同时打开、关闭"></a>1.12 同时打开、关闭</h4><ul><li><img src="http://image.blissseven.top/blog/20190410/vpvClDEUgVBB.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190410/1WIDJjioXXNG.png?imageslim" alt="mark"></li></ul><h4 id="1-13-TCP选项"><a href="#1-13-TCP选项" class="headerlink" title="1.13 TCP选项"></a>1.13 TCP选项</h4><ul><li><p>TLV结构 type+length+value</p></li><li><p><img src="http://image.blissseven.top/blog/20190410/RuvSc58EMcgU.png?imageslim" alt="mark"></p></li><li><p>每个选项的开始是1字节kind字段，说明选项的类型。kind字段为0和1的选项仅占1个字节。其他的选项在kind字节后还有len字节。它说明的长度是指总长度，包括kind字节和len字节。</p><p><strong>设置无操作选项的原因在于允许发方填充字段为4字节的倍数。</strong>如果我们使用4.4BSD系统进行初始化TCP连接，tcpdump将在初始的SYN上显示下面TCP选项：</p><p>&lt;mss 512, nop, wscale 0, nop, nop, timestamp 146647 0&gt;</p><p>MSS选项设置为512，后面是NOP，接着是窗口扩大选项。第一个NOP用来将窗口扩大选项填充为4字节的边界。同样，10字节的时间戳选项放在两个NOP后，占12字节，同时使两个4字节的时间戳满足4字节边界。</p></li><li><p>nop一个空字节 Nop+wscale0 四个字节</p></li></ul><h4 id="2-1-TCP的交互数据流"><a href="#2-1-TCP的交互数据流" class="headerlink" title="2.1 TCP的交互数据流"></a>2.1 TCP的交互数据流</h4><ul><li><p>交互数据流：包的数量多，但多为小包</p></li><li><p>以Rlogin应用为例</p></li><li><p>通常每一个交互按键都会产生一个数据分组，这样就会产生四个报文段：</p><ul><li><img src="http://image.blissseven.top/blog/20190410/I04bXR3j5wMO.png?imageslim" alt="mark"></li><li>来自客户的交互按键</li><li>来自服务器的按键确认</li><li>来自服务器的按键回显</li><li>来自客户的按键回显确认</li></ul></li><li><p>经受时延的确认</p><ul><li>通常TCP在接收到数据后并不立即发送ACK，相反，它推迟发送，以便将ACK与需要沿该方向发送的数据一起发送（数据捎带ACK），绝大多数实现采用的时延为200ms，即，TCP将以最大200ms的时延等待是否有数据一起发送</li><li><img src="http://image.blissseven.top/blog/20190410/BuwF6UYVQ10G.png?imageslim" alt="mark"></li></ul></li><li><p>Nagle算法</p><ul><li>要求<strong>一个TCP连接上最多只有一个未被确认的未完成的小分组，在该分组的确认到达前不能发送其他的小分组</strong>。相反，<strong>TCP收集这些少量的分组，并在确认到来时以一个分组的方式发出去</strong>。该算法的<strong>优越性在于它是自适应的</strong>：确认到达的越快，数据也就发送的越快。而在希望减少微小分组数目的低速广域网上，则会发送更少的分组</li><li>注意从<strong>左到右待发数据的长度是不同的，分别为1 1 2 1 2 2 3 1 和三个字节。</strong>这是因为<strong>客户只有收到前一个数据的确认后才发送已经收集的数据</strong>。通过Nagle算法，为发送16个字节的数据客户只需要9个报文段，而不是16个。</li><li><img src="http://image.blissseven.top/blog/20190410/k0dGrBCJCYW2.png?imageslim" alt="mark"></li><li>有时也需要关闭Nagle算法，e.g.小消息必须无时延的发送</li><li>增加时延值，减小了小包的数量</li><li><img src="http://image.blissseven.top/blog/20190410/lzMqBNajvx3v.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190410/AB8e3a9xqYUA.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190410/dXsN3JpfbLim.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190410/yQhAXzTNTAiW.png?imageslim" alt="mark"></li></ul></li></ul><h4 id="2-2-TCP成块的数据流"><a href="#2-2-TCP成块的数据流" class="headerlink" title="2.2 TCP成块的数据流"></a>2.2 TCP成块的数据流</h4><ul><li><p>TFTP使用了<strong>停止等待协议</strong>。数据发送方在确认下一个数据块之前需要等待接收对已发送数据的确认。本章介绍TCP使用的滑动窗口协议的另一种形式的流量控制方法。<strong>该协议允许发送方在停止并等待确认前可以发送多个分组</strong>。由于<strong>发送方不必每发一个分组就停下来等待确认，该协议可以加速数据的传输</strong>。</p></li><li><p>正常数据流</p><ul><li>确认机制：<ul><li>通常使用的“<strong>隔一个报文段确认”</strong>策略，A发送一个报文给B，A再发送一个报文给B，B发送ACK确认收到的两个报文给A</li><li>delay_ed ACK, 如果tcp对每个数据包都发送一个ack确认，那么只是一个单独的数据包为了发送一个ack代价比较高，所以tcp会延迟一段时间，如果这段时间内有数据发送到对端，则捎带发送ack，如果在延迟ack定时器触发(200ms)时候，发现ack尚未发送，则立即单独发送</li></ul></li><li>我们在线路上看到的分组顺序依赖于许多无法控制的因素：发送方TCP的实现、接收方TCP的实现、接收进程读取数据（依赖于操作系统的调度）和网络的动态性（以太网的冲突和避让），对两个TCP而言，没有一种单一的、正确的方法来交换给定数量的数据</li></ul></li><li><p><img src="http://image.blissseven.top/blog/20190411/zlyJcbpYaWHd.png?imageslim" alt="mark"></p><ul><li>通过发送MSS大小，使的慢接收方对快发送方的流量控制</li></ul></li><li><p>滑动窗口</p><ul><li>在建立TCP连接的同时，可以确定发送数据包的单位，也称其<strong>为最大消息长度</strong>（MSS Maximum Segment Size）。最理想的情况是，最大消息长度正好为IP中不会被分片处理的最大数据长度（一般1460-1500-20-20）</li><li><strong>TCP在传送大量数据时，是以MSS的大小将数据进行分割发送。进行重发时也是以MSS为单位</strong></li><li>MSS是在三次握手时，在两端主机之间被计算得出。两端的主机在发送建立连接的请求时，会在TCP首部中写入MSS选项，告诉对方自己的接口能够适应MSS的大小。然后会在两者之间选择一个较小的值投入使用</li><li><img src="http://image.blissseven.top/blog/20190411/QX1ltJ2JBM6v.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190411/1pBB63IaAPY5.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190411/NUuoCQ5jAw5I.png?imageslim" alt="mark"></li><li>将发送方要发送的字节从1至11标号。<strong>接收方通告的窗口成为提出的窗口（offered window）</strong>，它覆盖了从第4字节到第9字节的区域。<strong>表明接收方已经确认了包括第3字节在内的数据，且通告窗口大小为6</strong>。表明可以连续发送6个报文无需确认，实际只发送3个报文，未被确认，回顾第17章，知道<strong>窗口大小是与确认序号相对应</strong>的。发送方计算它的可用窗口，该窗口表明多少数据可以立即传送。当接收方确认数据后，这个滑动窗口不时的向右移动。窗口两个边沿的相对运动增加或减少了窗口的大小</li><li><img src="http://image.blissseven.top/blog/20190411/g4E2gINO8zcM.png?imageslim" alt="mark"></li><li>称窗口左边向右边靠近时为窗口靠拢。<strong>发生在数据被发送和确认时</strong></li><li>当窗口右边沿向右移动时将允许发送更多的数据，称之为<strong>窗口张开</strong>。这<strong>种现象发生在另一端的接收进程读取已经确认的数据并释放了TCP的接收缓存时</strong>。</li><li>当右边沿向左移动，成为窗口收缩。Host Requirements RFC强烈建议不要这么做</li><li><img src="http://image.blissseven.top/blog/20190411/f7vc0NM0wzFG.png?imageslim" alt="mark"></li><li>发送方不必发送一个全窗口大小的数据</li><li>来自接收方的一个报文段确认数据并把窗口左边沿向右滑动。这是因为窗口的大小是相对于确认序号的</li><li>正如从报文段7到报文段8中变化的那样，窗口的大小可以减小，但是窗口的右边沿不能向左移动</li><li>接收方在发送一个ACK前，不必等待窗口被填满。在前面我们看到许多实现每收到两个报文段就会发送一个ACK</li><li>PUSH<ul><li>发送方使用该标志通知接收方将所收到的数据尽快全部提交给接受进程</li><li>数据包括与<strong>PUSH一起传送的数据以及接收方TCP已经为接受进程收到的其他数据</strong>（已缓存的数据）</li></ul></li><li>A的slide window 左侧是自己发出，并被对方确认的字节序列号，右侧是左侧+ B通告window size。</li></ul></li><li><p>慢启动</p><ul><li>TCP三次同步握手建立连接之后，会<strong>采用slow start 算法来快速摸到传输路径带宽的峰值</strong>。</li><li>本章所有例子中，发送方一开始便向网络发送多个报文段，直至达到接收方通告的窗口大小为止。当发送方和接收方处于同一个局域网时，这种方式是可以的。<strong>但是如果在发送方和接收方之间存在多个路由器和速率较慢的链路时，就有可能出现一些问题。一些中间路由器必须缓存分组，并有可能耗尽存储器的空间</strong>，然后发生丢包</li><li>TCP采用慢启动算法来<strong>降低一开始就发送过多的数据到网络</strong></li><li>慢启动为发送方的TCP增加了另一个窗口：拥塞窗口（congestion window）记为cwnd。当与另一个网络的主机建立TCP连接时，拥塞窗口被初始化为<strong>1个报文段（即另一端通告的报文段大小）</strong>。每收到一个ACK，拥塞窗口就增加一个报文段（<strong>cwnd以字节为单位，但是慢启动以报文段为单位进行增加</strong>）。<strong>发送方取拥塞窗口与通告窗口中的最小值作为发送上限</strong>。<strong>拥塞窗口是由发送方使用的流量控制，而通告窗口则是接收方使用的流量控制</strong></li><li>发送方开始时发送一个报文段，然后等待ACK。当<strong>收到该ACK</strong>时，拥塞窗口从1增加到2，即可以发送两个报文段。当收到这两个的报文段的ACK时，拥塞窗口就增加为4.<strong>是一种指数增加的关系</strong></li><li>在某些点<strong>上可能达到了互联网的容量</strong>，于是中间路由器开始丢弃分组，发送方检测到丢包，相当于得到通知：<strong>发送方的拥塞窗口开的过大，需要进行调整</strong>。</li><li><img src="http://image.blissseven.top/blog/20190411/DFfGFKBWB9Yr.png?imageslim" alt="mark"></li><li>发送一个分组的时间<ul><li>通常发送一个分组的时间取决于两个因素：<strong>传播时延和发送时延</strong>（带宽）</li><li>对于一个给定的两个接点之间的通路，<strong>传播时延</strong>（光速）一般为固定的，而发送时延则取决于分组的大小</li><li>在<strong>速率较慢的情况下，发送时延起主要作用，而在千兆比特速率下，传播时延起主要作用</strong></li></ul></li></ul></li><li><p>成块数据的吞吐量</p><ul><li><img src="http://image.blissseven.top/blog/20190411/Xu8ALS9trLeR.png?imageslim" alt="mark"></li><li>时间19之后，没有收到ack所以最大只能发送4个报文。</li><li>带宽时延乘积<ul><li>为了最大限度的利用链路带宽<strong>，必须确保发送方源源不断的收到接收方发送的ACK</strong>，<strong>作为对接收到数据的确认和更新Window size的大小</strong></li><li>在开始阶段，<strong>通告的window size必须大于等于带宽和往返时延的乘积</strong>，才能确保在收到第一个ACK之前，能够一直发送数据流量。因为发送<strong>第一个数据报文到收到对应的ACK</strong>，时间至少为RTT时间（发一个数据报到收到ACK的时间）</li><li>因此<strong>传送通道容量</strong>为<ul><li>capacity(bit)=bandwidth(b/s)* round-trip time(s) 带宽时延乘积</li><li>cwnd和 windows size 最小值 大于等于 bandwidth* rount-trip-time</li></ul></li></ul></li><li>拥塞<ul><li>当数据到达一个大的管道（如一个快速局域网）并向一个较小的管道（如一个较慢的广域网）发送时便会发生拥塞。当多个输入流到达一个路由器，而路由器的输出流小于这些输入流的总和时也会发生拥塞。</li><li><img src="http://image.blissseven.top/blog/20190411/4aarnSaGD65q.png?imageslim" alt="mark"></li></ul></li><li>紧急方式<ul><li>TCP提供了紧急方式，它使一端可以高速另一端有些紧急具有某种方式的<strong>“紧急数据”已经放置在普通的数据流中</strong>。另一端被通知这个紧凑数据已被放置在普通的数据流中，有接收方决定如何处理。可以通过设置TCP首部中的两个字段来发出这种一端到另一端的紧急指针已经被放置在数据流中的通知。<strong>URG被置1，并且一个16bit的紧急指针被置为一个正的偏移量</strong>，<strong>该偏移量与TCP首部中的序号字段相加，得到紧急数据中的最后一个字节的序号</strong>。</li><li>TCP必须通知接受进程，已收到一个紧急数据指针。接受进程读取数据流，并被告知何时碰到紧急数据指针。<strong>只要从接收方当前读取位置到紧急数据指针之间由数据存在，就认为应用程序处于紧急模式</strong>。在紧急指针通过之后，应用程序便转回到正常方式</li><li>TCP本身对紧急数据知之甚少，没有办法指明紧急数据从数据流的何处开始。TCP通过连接传送的唯一信息就是紧急指针已经开始（TCP首部中的URG比特）和指向紧急数据最后一个字节的指针，其他事情交给应用程序去处理。</li><li>作用<ul><li>Telnet Rlogin 中断键</li><li>FTP当用户放弃一个文件的传输</li><li>Telnet和Rlogin从服务器到客户使用紧急方式是因为在这个方向上的数据流很可能要被客户的TCP停止（也即，它通告了一个大小为0的窗口）。但是如果服务器进程进入了紧急方式，尽管它不能够发送任何数据，服务器TCP也会立即发送紧急指针和URG标志。当<strong>客户TCP接收到这个通知时就会通知客户进程，于是客户可以从服务器读取其输入、打开窗口并使数据流动</strong>。</li><li>A发送数据至B，B缓冲满，发送window size=0给A，A又要往B发送数据通过紧急模式</li><li><img src="http://image.blissseven.top/blog/20190411/fX9JqeoVJgCz.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190411/aSV04KT8JwPd.png?imageslim" alt="mark"></li></ul></li></ul></li></ul></li></ul><h4 id="2-3-TCP的超时和重传"><a href="#2-3-TCP的超时和重传" class="headerlink" title="2.3 TCP的超时和重传"></a>2.3 TCP的超时和重传</h4><ul><li><p>TCP提供可靠的运输层。使用的方法之一就是确认从另一端收到的数据。但数据和确认都有可能丢失。TCP通过在发送端发送数据时设置一个定时器来解决这种问题。如果当定时器溢出时还没有收到接收方确认，发送端就重传该数据。<strong>对任何实现而言，关键之处在于超时和重传的策略，即怎样决定超时间隔和重传的间隔。</strong></p></li><li><p>对每个连接，TCP管理4个不同的定时器</p><ul><li><strong>重传定时器</strong>用于当发送一个数据报文时，在规定时间内，发送方需要收到另一端发出的接收报文确认。本章详细介绍该定时器，以及一些相关问题，拥塞避免</li><li>坚持persist定时器使窗口大小信息保持不断流动，即使另一端关闭了其接收窗口 chapter23</li><li>保活keepalive定时器用于检测一个空闲连接的另一端是否依然保持连接。chapter23</li><li>2MSL定时器测量一个连接处于TIME_WAIT状态的时间。chapter18.6</li></ul></li><li><p><img src="http://image.blissseven.top/blog/20190411/i7thLAfpsYPD.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190411/sSqXRH76NoHC.png?imageslim" alt="mark"></p><ul><li>重传之间的时间间隔为1 3 6 12 24 48 和多个62秒</li><li>当第一次发送后所设置的超时时间实际上为1.5秒，服务器时间戳最小精度为500ms</li><li><strong>指数退避 exponential backoff</strong></li><li>首次分组传输（第6行，24.480秒）与复位信号传输（第19行，566.488秒）之间的时间差为9分钟</li><li>solaris2.2 允许管理者修改这个时间（tcp_ip_abort_interval），且其默认值为2分钟，而不是常用的9分钟</li></ul></li><li><p>往返时间测量</p><ul><li><p>TCP超时与重传中最重要的部分就是对一个TCP连接的往返时间RTT的测量。由于网络状况的多变性，RTT时间经常会发生变化，TCP应该跟踪这些变化并相应的改变超时重传时间</p></li><li><p>RFC 793 计算方法</p><ul><li>使用一个低通滤波器来更新一个被平滑的RTT值，记为O</li><li>R&lt;- &amp;R+(1-&amp;)M</li><li>&amp;一个推荐值为0.9的平滑因子。每次进行新测量的时候这个被平滑的RTT将得到更新。</li><li>该算法在给定这个随RTT的变化而变化的平滑因子的条件下，RFC推荐的<strong>重传超时时间</strong>RTO的值应设置为RTO=R@，@为推荐值为2的时延离散因子</li></ul></li><li><p>基于均值和方差来计算RTO</p><ul><li>除了被平滑的RTT，还需要跟踪RTT的方差</li><li><img src="http://image.blissseven.top/blog/20190411/bbqy58qgYdRY.png?imageslim" alt="mark"></li><li>M为当前测出的RTT值，A为被平滑的RTT（均值的估计器），D为被平滑的均值偏差。Err刚得到的测量结果与当前的RTT估计其之差。A和D均被用于计算下一个重传时间。增量g起平均作用，为1/8（0.125）。偏差的增益为h，取值0.25。当RTT变化时，较大的偏差增益使RTO快速上升</li><li><strong>g h 倍数4均为2的倍数的原因，通过移位实现</strong></li><li>A为被平滑的RTT，D为被平滑的RTT方差，RTO=A+4D</li></ul></li><li><p>重传多义性问题</p><ul><li>在一个分组重传时：假定一个分组被发送。当超时发生时，RTO正进行指数退避，分组以更长的RTO进行重传，然后收到一个确认。那么这个ACK是针对第一个分组还是第二个分组呢，在计算RTT值时考虑</li><li>Karn 算法，当一个超时和重传发生时，<strong>在重传数据的确认最后到达之前，不能更新RTT估计器</strong></li><li><img src="http://image.blissseven.top/blog/20190411/TR05xUkpkP8I.png?imageslim" alt="mark"></li><li>一次测量完成，再进行下一次测量</li><li>大多数源于伯克利<strong>的TCP实现在任何时候对每个连接仅测量一次RTT值</strong>。在发送一个报文段时，如果给定连接的定时器已经被使用，则该报文段不被计时</li><li>对每个连接而言，除了这个滴答计数器，<strong>报文段中数据的起始序号也被记录下来</strong>。<strong>当收到一个包含这个序号的确认后，该定时器就被关闭</strong>。如果ACK到达时数据没有被重传，则被平滑的RTT和被平滑的均值偏差将基于这个新测量进行更新。</li></ul></li><li><p><img src="http://image.blissseven.top/blog/20190411/Y361KNRIwW5d.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190411/7bqynsgd9Lyc.png?imageslim" alt="mark"></p><ul><li>发第一个包丢掉时，重传时间6s，第二个也丢掉了，发第三个时重传时间12s</li></ul></li><li><p><img src="http://image.blissseven.top/blog/20190411/fdyqfbGYf1CO.png?imageslim" alt="mark"></p></li></ul></li><li><p>拥塞举例</p><ul><li><img src="http://image.blissseven.top/blog/20190411/OdJCczf8sBET.png?imageslim" alt="mark"></li><li>有两种<strong>分组丢失的指示：超时和接收到重复的确认</strong><ul><li>使用<strong>超时作为丢包指示，需要一个好的RTT算法</strong></li></ul></li><li>重复的ACK,发送端一直发送的数据的起始序列号不是接收方发送ACK的序列号时会发送重复的ACK。收到三个重复的ACK，认为这个包已经丢掉了</li><li><strong>拥塞避免算法是一种处理丢失分组的方法</strong></li><li>该算法假定<strong>由于分组收到损坏引起的丢失是非常少的（远低于1%），因此分组丢失就意味着在源主机滑动目的主机的某处网络上发生了拥塞</strong></li><li>拥塞避免算法和慢启动算法是两个目的不同、独立的算法。当拥塞发生时，我们希望降低分组进入网络的传输效率，于是可以调用慢启动来实现这一点。在实际中，这两个算法通常一起实现</li><li>拥塞避免和慢启动都是<strong>发送方使用的流量控制</strong>（<em>慢启动允许一方发送连续的未经确认的分组，增加方式采用指数增加，拥塞避免算法允许一方发送连续的未经确认的分组，增加方式采用线性增加</em>），而<strong>通告窗口则是接收方进行的流量控制</strong>。<strong>拥塞避免是发送方对网络可能发生拥塞的估计</strong>，而后者则与接收方分配给该<strong>连接的接收缓存大小</strong>有关。</li></ul></li><li><p>拥塞避免算法</p><ul><li><p>拥塞避免算法和慢启动算法都需要<strong>对每个连接维持两个变量</strong>：<strong>一个拥塞窗口cwnd</strong>和一个<strong>慢启动门限ssthresh</strong>。</p></li><li><ol><li>对一个给定的连接，初始化cwnd为1个报文段，ssthresh为65535个字节</li><li>TCP发出未经确认的报文总大小不能超过cwnd和接收方通告窗口的大小</li><li>当拥塞发生时（超时或收到重复确认），ssthresh被设置为当前窗口大小的一半（cwnd和接收方通告窗口的最小值，<strong>但至少为2个报文段</strong>）。此外，如果是超时引起了拥塞，则cwnd被设置为1个报文段（这就是慢启动），另一种是收到重复确认</li><li>当<strong>新的数据被对方确认时，就增加cwnd</strong>，但增加的方式依赖于我们是否正在进行慢启动或拥塞避免。<strong>如果cwnd小于等于ssthresh则正在进行慢启动，否则正在进行拥塞避免</strong>。<strong>慢启动一直持续到我们回到当拥塞发生时所处位置一半时才停止</strong>（因为我们记录了在步骤3中给我们知道麻烦窗口大小的一半，就是ssthresh），接下来执行的是拥塞避免</li></ol></li><li><p><img src="http://image.blissseven.top/blog/20190411/PJVWOCc1rhM6.png?imageslim" alt="mark"></p></li><li><p>慢启动算法初始设置cwnd为1个报文段，此后每收到一个确认就加1，这会使窗口在每个RTT时间内按指数方式增长，发送1个报文段，2个，4个</p></li><li><p>拥塞避免算法要求<strong>每收到一个确认将cwnd增加1/cwnd</strong>。与慢启动指数的增加相比，是一种加性增长。我们希望在一个往返时间内最多为cwnd增加1个报文段（不管在这个RRT中收到了多少了ACK），然<strong>而慢启动将根据这个往返时间中所收到的确认的个数增加cwnd</strong>。</p></li><li><p>丢包的另一种指示是收到了重复的ACK</p></li><li><p>快速重传算法</p><ul><li>如果一连串收到3个或3个以上的重复的ACK，就非常有可能是一个报文段丢失了，于是我们就重传丢失的数据报文段，而<strong>无需等待超时定时器溢出</strong></li></ul></li><li><p>快速恢复算法</p><ul><li><p><strong>快速重传后执行的不是慢启动，而是拥塞避免算法</strong></p></li><li><p>没有执行慢启动原因</p><ul><li>收到重复的ACK不仅仅告诉我们一个分组丢失了，还告诉我们一个数据报离开网络顺利的到达接收者。这是由于接收方只有在收到另一个报文段并发现这个报文段不是我当前需要序号的报文才产生重复的ACK，说明有一个报文段已经离开了网络并进入了对方的缓存，<strong>也就是说，在收发两端之间仍然有流动的数据，而我们不想执行慢启动来突然减少数据流</strong></li><li>慢启动时，cwnd初始化为1，拥塞避免算法时，cwnd初始化为ssthresh</li></ul></li><li><p>1 当受到第三个重复的ACK时，将ssthresh设置为当前拥塞窗口cwnd的一半。重传丢失的报文段。<strong>设置cwnd为ssthresh加上3倍的报文段的大小</strong>。（ssthresh本应立即设置为当重传发生时正在起作用的窗口大小的一半，但是在接收到重复ack的过程中允许cwnd保持增加，这是因为每个重复的ack都表示1个报文段已离开了网络，<strong>收到3个重复的ack，表示有3个报文离开了网络，并被接收TCP缓存了这几个报文段</strong>，正在等待所缺数据的到达）</p></li><li><p>2 每次收到另一个重复的ack时，cwnd增加1个报文段大小并发送1个分组</p></li><li><p>3 <strong>当下一个确认新数据的ACK到达时，设置cwnd为ssthresh（在第1步中设置的值）</strong>。这个ACK应该是<strong>在进行重传后的一个往返时间内对步骤1中重传的确认</strong>。另外，这个ACK也应该是对<strong>丢失的分组和收到的第1个重复的ACK之间的所有中间报文的确</strong>认。这一步采用的是拥塞避免，因为当分组丢失时我们将当前的速率减半</p></li></ul></li><li><p><img src="http://image.blissseven.top/blog/20190411/4GgQdqkEcp8q.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190411/4tHRwKUHQqMf.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190411/8IbC9CyGagly.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190411/lGdKwjdNhzl3.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190411/eyHwqN8oHy73.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190411/MsWPrJfxqxru.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190411/t6xcQyrVPL9h.png?imageslim" alt="mark"></p></li></ul></li><li><p>按每条路由进行度量</p><ul><li>新的TCP实现<strong>在路由表项中维持许多我们在前面就提到过的指标</strong>。当一个TCP连接关闭时，如果已经发送了<strong>足够多的数据来</strong>获得有意义的统计资料，且<strong>目的结点的路由表项不是一个默认的表项，</strong>那么下列信息就保存在路由表项中以备下次使用：<strong>被平滑的RTT，被平滑的均值偏差以及慢启动门限</strong>。<strong>所谓“足够多的数据”是指16个窗口的数据，这样就可以得到16个RRT采样</strong></li><li>当建立一个新的连接时，<strong>不论是主动还是被动，如果该连接将要使用的路由表项已经有这些度量的值，则用这些度量来对相应的变量进行初始化</strong>。</li><li><img src="http://image.blissseven.top/blog/20190411/Qp5Nnyqlcjfo.png?imageslim" alt="mark"></li><li>B C在同一子网，A有一条明细路由去往B C 所在的子网</li></ul></li><li><p>ICMP的差错</p><ul><li>提供information \error message</li><li><strong>TCP能够遇到的常见的ICMP差错就是源站抑制、主机不可达、和网络不可达</strong></li><li>基于伯克利的实现对这些错误的处理<ul><li>接收到的源站抑制ICMP差错报文：拥塞窗口cwnd被设置为1个报文段大小，开始慢启动，但是慢启动门限ssthresh没有变化，所以发送窗口将打开直至它或者充分利用收发双方的链路（受窗口大小和往返时间限制）或者发生了拥塞</li><li><strong>接收到的主机不可达或网络不可达的ICMP错误都被忽略，因为这两个差错都被认为是短暂现象。</strong>这有可能是由于网络发生故障而收敛，需要一定的时间选择替换路径。在收敛过程中可能引起发送这两种ICMP差错中的一种，但是TCP连接并不必被关闭，相反，TCP试图发送引起该差错的数据，尽管最终有可能引起超时</li></ul></li><li><img src="http://image.blissseven.top/blog/20190412/J4fdLWatUUlk.png?imageslim" alt="mark"></li></ul></li><li><p>TCP的重新分组    </p><ul><li>当TCP超时并重传时，他并不一定要重传同样的报文段。相反，TCP允许进行重新分组而发送一个较大的报文段，这将有助于提高性能（当然，这个较大的报文段不能够超过接收方声明的MSS）。在协议中这是允许的，因为TCP是使用字节序号而不是报文段编号来进行识别它所要发送的数据和进行确认。</li></ul></li></ul><h4 id="2-4-TCP的坚持定时器"><a href="#2-4-TCP的坚持定时器" class="headerlink" title="2.4 TCP的坚持定时器"></a>2.4 TCP的坚持定时器</h4><ul><li>ACK的传输并不可靠，也就是说，TCP不对ACK报文段进行确认，TCP只确认那些含有数据的ACK报文段。如果报文段9丢失怎么办？</li><li><img src="http://image.blissseven.top/blog/20190412/IeTFTIcL7sql.png?imageslim" alt="mark"></li><li>问题：如果一个通告窗口更新的确认丢失了，则双方就有可能一直等待下去：接收方等待接收数据（因为它已经向发送方通告了一个非0的窗口），而发送方在等待允许它继续发送数据的窗口更新</li><li>解决方法：<strong>为防止死锁情况发生，发送方使用一个坚持定时器（persist timer）来周期性的向接收方查询，</strong>以便发现窗口是否已经增大。这些从发送方发出的报文段成为<strong>窗口探查（window probe）</strong></li><li><img src="http://image.blissseven.top/blog/20190412/KJQSqDFkg7ic.png?imageslim" alt="mark"></li><li>14 为窗口探查报文</li><li>坚持定时器使用了普通的TCP指数退避，在收到一个大小为0的窗口通告后的第1个（报文段14）间隔为4.949秒，下一个（报文段16）间隔为4.996秒，之后间隔1 12 24 48秒和多个60秒</li><li>窗口探查<strong>包含一个字节的数据</strong>（序号为9217）<strong>TCP总是允许在关闭连接前发送一个字节的数据</strong>。注意。尽管如此，<strong>所返回的窗口为0的ACK并不是确认该字节</strong>（<strong>它们确认了包括9216在内的所有数据</strong>）。<strong>因此这个字节被持续重传。被持续用来探测对端窗口的变化情况</strong>。</li><li>糊涂窗口综合征<ul><li>基于窗口的流量控制方案，如TCP使用的，会导致糊涂窗口综合征SWS（Silly Window Syndrome）的状况。如果发生这种情况，则少量的数据将通过连接进行交换，而不是满长度的报文段。导致传输效率低下</li><li>现象：可发生在两端中的任何一端：<strong>接收方可以通告一个小的窗口（而不是一直等到有大的窗口时才通告），而发送方也可以发送少量的数据（而不是等待其他的数据以便发送一个大的报文段）</strong></li><li>解决方案，可以在任何一端采取措施避免<ul><li><strong>接收方不通告小窗口</strong>。通常的算法是接收方不通告这样的窗口，<strong>窗口小于1个报文段（也就是将要接收的MSS），或者窗口小于与接受方缓存空间的一半，不论实际有多少</strong>。</li><li>发送方避免出现糊涂窗口综合症的措施是仅在满足下列条件时才发送数据<ul><li>可以发送一个满长度的报文</li><li><strong>可以发送至少是接收方通告最大窗口大小一半的报文</strong></li><li><strong>没有还未被确认的数据时或者TCP连接上禁止使用Nagle算法</strong></li></ul></li><li>在有尚未被确认数据的情况下，Nagle算法阻止我们发送小的报文段；禁止Nagle算法后，即便有未确认数据包，也可以发送数据包</li></ul></li><li><img src="http://image.blissseven.top/blog/20190412/23g8KbMhhnek.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190412/pf8dRzPojGML.png?imageslim" alt="mark"></li><li>6 窗口探测报文</li><li>此时MSS=1460 接收方缓冲至少4096</li><li>11 号大于MSS，1533 因为探测报文占了一个字节</li></ul></li></ul><h4 id="2-5-TCP的保活定时器"><a href="#2-5-TCP的保活定时器" class="headerlink" title="2.5 TCP的保活定时器"></a>2.5 TCP的保活定时器</h4><ul><li>如果TCP连接的双方都没有向对方发送数据，则在两个TCP模块之间不交换任何信息，意味着我们可以启动一个客户与服务器建立一个连接，然后离去数小是，数月后，连接依然保持</li><li>许多时候一个服务器希望知道客户主机是否关机或者崩溃又重新启动。许多实现提供的保活定时器可以提供这种能力，但是保活定时器并不是TCP规范中的一部分</li><li>Host Requirements RFC提供了3个不使用保活定时器的理由<ul><li>在出现短暂差错的情况下，这可能使一个非常好的连接释放掉</li><li>它们耗费不必要的带宽</li><li>在按分组计费的情况下会在互联网上花掉更多的钱。并且，许多实现提供了保活定时器</li></ul></li><li>许多人认为，保活定时器应由应用程序完成</li><li><img src="http://image.blissseven.top/blog/20190412/rxQoHHDUVwsz.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190412/g253hsoDCkTC.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190412/1EIuuWfpntN5.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190412/A1nLKYeWwe1M.png?imageslim" alt="mark"></li></ul><h4 id="3-1-TCP的未来和性能"><a href="#3-1-TCP的未来和性能" class="headerlink" title="3.1 TCP的未来和性能"></a>3.1 TCP的未来和性能</h4><ul><li><p>TCP的一些修改建议，长肥管道，基于事务的TCP（T-TCP）</p></li><li><p>路径MTU的发现</p><ul><li>路径MTU单向性</li><li>TCP的路径MTU发现按如下方式进行：在连接建立时，TCP使用输出接口MTU或对端声明的MSS最小值作为起始的报文段大小。路径MTU发现不允许TCP超过对端声明的MSS。如果对端没有指定一个MSS，则默认为536。</li><li>一旦选定了起始报文的报文段大小，在该连接上的所有被<strong>TCP发送的IP数据报都将被设置DF比特</strong>。如果某个中间路由器需要对一个设置了DF标志的数据报进行分片。它就丢弃这个数据报，并产生一个ICMP的不能分片的差错。如果收到这个差错，TCP就减少段大小并进行重传。<strong>如果路由器产生的是一个较新的该类ICMP差错，则报文携带为下一跳的MTU值</strong>。如果是一个较旧的该类ICMP差错，则必须尝试下一个可能的MTU。当由这个ICMP差错引起的重传发生时，拥塞窗口不需要变化，但要启动慢启动。</li><li><img src="http://image.blissseven.top/blog/20190412/iisAnO2xGLX3.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190412/s4cqDYY9dkCr.png?imageslim" alt="mark"></li></ul></li><li><p>大分组好还是小分组好</p><ul><li>常规知识告诉我们较大的分组好，因为发送较少的大分组比发送较多的分组花费更少（假定分组的大小不足以引起分片，否则会引起其他方面的问题）。这些减少的花费和网络（分组首部负荷）、路由器（选路的决定）和主机（协议处理和设备中断）等有关。但并非所有的人都同意该观点</li><li><img src="http://image.blissseven.top/blog/20190412/jVDGEj8k9Jhz.png?imageslim" alt="mark"></li><li>时间片个数为 分组个数2+跳数3-1=4</li><li>从R1发送到R4 需消耗21.4*4=85.6秒</li><li><img src="http://image.blissseven.top/blog/20190412/EzdYpj7k3A0g.png?imageslim" alt="mark"></li><li>时间片个数为 分组个数16+跳数3-1=18 </li><li>18*2.9=52.2ms</li><li>每个链路的空闲时间不一样</li><li>尽管如此，发送还是大的好</li></ul></li><li><p>长肥管道</p><ul><li>把一个连接的容量表示为 capacity(b)=bandwidth(b/s) * round-trip time(s) ,也称带宽时延乘积、两端的管道大小</li><li><strong>当这个乘积变大时，TCP的某些局限性就会暴露出来</strong></li><li><img src="http://image.blissseven.top/blog/20190412/LH0DsGJxw2s2.png?imageslim" alt="mark"></li><li>具有大的带宽时延乘积的网络为长肥网络（long fat network），而另一个运行在LFN上的TCP连接为长肥管道</li><li>局限性<ul><li>TCP首部中窗口大小为16bit，从而将窗口限制在65535个字节内。（最优窗口=带宽时延乘积）然而现有的网络<strong>需要一个更大的窗口来提供最大的吞吐量</strong>。后面将介绍窗口扩大选项将解决这个问题</li><li><strong>在一个长肥网络LFN内的分组丢失会使吞吐量急剧减少</strong>，丢包5%时，吞吐率50%，发生重传</li><li>我们在前面看到许多TCP实现对每个窗口的RTT仅进行一次测量。它们并不对每个报文段进行RTT测量。<strong>在一个长肥网络LFN上需要更好的RTT测量机制</strong>，有一个更好的RTO值。我们将在后面介绍时间戳选项，允许更多的报文段被计时，包括重传</li><li>TCP对每个字节数据使用一个32bit无符号的序号来进行标识。如果在网络中有一个被延迟一段时间的报文段，它所在的连接已经被释放，而一个新的连接在这两个主机之间又被建立了，怎么才能<strong>防止这样的报文段再次出现</strong>呢？首先会想起IP首部中的TTL为每个IP段规定了一个生存时间的上限-255跳或255秒，看哪一个上限先到达。我们还定义了最大的报文段生存时间MSL作为一个实现的参数来阻止这种情况的发生。推荐的MSL值为2分钟（给出一个240秒的2MSL），然而许多实现使用的MSL为30秒</li></ul></li><li>TCP 序号回绕问题<ul><li>在长肥网络LFN上，TCP的序号会碰到一个不同的问题。由于序号空间有限，在已经传输了4294967296个字节以后序号会被重用。如果一个包含序号N字节数据的报文在网络上被延迟并在连接依然有效时出现，会发生什么情况呢？</li><li>在一个以太网上要发送如此多的数据大概需要60分钟，因此不会发生这种情况。但是在带宽增加时，这个时间会减少：一个T3的电话线（45Mb/s）在12分钟内会发生回绕，FDDI（100Mb/s）为5分钟，问题不在于带宽时延乘积，而在于带宽本身</li><li>解决方案：使用TCP的时间戳选项的PAWS（Protection Against Wrapped Sequence numbers）保护回绕的序号</li></ul></li><li>窗口扩大选项</li><li><img src="http://image.blissseven.top/blog/20190412/HQ1EHLT3aKJY.png?imageslim" alt="mark"></li><li>窗口扩大因子</li><li><img src="http://image.blissseven.top/blog/20190412/JCEs3ODCwO2v.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190412/wCr9kqcWBwbA.png?imageslim" alt="mark"></li></ul></li><li><p>时间戳选项</p><ul><li><p><strong>用于更多的数据报参与RTT的计算，以及防止序号回绕</strong></p></li><li><p>时间戳选项使<strong>发送方在每个报文段中放置一个时间戳选项</strong>。接收方在确认中返回这个数值，从而允许发送方为每一个收到的ACK计算RTT。我们提到过目前许多实现为每一个窗口只计算一个RTT，对于包含8个报文段的窗口而言这是正确的。然而，较大的窗口大小则需要进行更好的RTT计算。</p></li><li><p><strong>发送方在第1个字段中放置一个32bit的值，接收方在应答字段中回显这个数值</strong>。<strong>包含这个选项的TCP首部长度将从正常的20字节增加到32字节</strong>，时间戳是要给单调递增的值。由于接收方只需要回显收到的内容，因此<strong>不需要关注时间戳单元是什么</strong>。这个选项不需要再两个主机之间进行任何形式的时间同步。</p></li><li><p>工作细节</p><ul><li><p>为了减少任一端所维持的状态数量，对于<strong>每个连接只保持一个时间戳的数值</strong>。选择何时更新这个数值的算法如下：</p></li><li><p>1 TCP跟踪下一个ACK中将要<strong>发送的时间戳的</strong>值（一个名为tsrecent的变量）以及最后发送的ACK中的确认序号（一个名为 lastack）的变量。这个序号就是接收方期待的序号</p></li><li><p>2 当一个包含有字节号lastack的报文段到达时，则该报文段中的时间戳被保存在tsrecent中</p></li><li><p>3 无论何时发送一个时间戳选项，tsrecent就作为时间戳回显应答字段被发送，而序号字段被保存在lastack中。</p></li><li><p>下面我们以一个例子理解timestamp和timestamp echo字段中存放的内容：假设a主机和b主机之间通信，a主机向b主机发送一个报文段，那么：</p><p>1）timestamp字段中存放的内容：a主机向b主机发送报文s1，在s1报文中timestamp存储的是a主机发送s1时的内核时刻ta1。</p><p>2）timestamp echo字段中存放的内容：b主机收到s1报文并向a主机发送含有确认ack的报文s2，在s2报文中，timestamp为b主机此时的内核时刻tb，而timestamp echo字段为从s1报文中解析出的ta1.</p></li></ul></li><li><p>我们已经看到<strong>接收方TCP不需要对每个包含数据的报文段进行确认</strong>，许多实现每两个报文段发送1个ACK。如果接收方发送1个确认了两个报文段的ACK，那么哪一个收到的时间戳应当放入回显应答字段中来发出去呢？</p></li><li><p>如果ACK被接收方延迟，则作为回显值的时间戳值应该对应于最早被确认的报文段。例如，如果两个包含1-1024和1025-2048字节的报文段到达，每一个都带有一个时间戳选项，接收方产生一个ACK 2049来对它们进行确认。此时ACK中的时间戳应该是包含字节1-1024的第1个报文段中的时间戳。这种处理正确。因为发送方在进行重传超时时间的计算时，必须将迟延的ACK也考虑在内</p></li><li><p>尽管时间戳选项能够更好的计算RTT，它还为发送方提供了一种方法，以避免接收到旧的报文段，并认为它们是现在数据的一部分。</p></li><li><p><img src="http://image.blissseven.top/blog/20190412/nAVz4syOk8rC.png?imageslim" alt="mark"></p></li><li><p>使用时间戳可以避免这种情况。接收方将<strong>时间戳视为序列号的1个32bit的扩展</strong>。由于在时间E重新出现的报文段的时间戳为2，这比<strong>最近有效的时间戳</strong>小（5或6），因此PAWS算法将其丢弃</p></li><li><p><strong>PAWS算法不需要再发送方和接收方之间进行任何形式的时间同步</strong>。接收方所需要的就是时间戳的值应该单调递增，并且每个窗口至少增加1。</p></li></ul></li><li><p>T/TCP为事务用的TCP扩展</p><ul><li>TCP提供的是一种虚电路方式的运输服务。一个连接的生存时间包括三个不同的阶段：建立、数据传输和终止。这种虚电路服务非常适合诸如远程注册和文件传输之类的应用</li><li>一个事务（transaction）就是符合下面这些特征的一个客户请求及其随后的服务器响应<ul><li>1 应该<strong>避免连接建立和连接终止的开销</strong>，在可能的时候发送一个请求分组并接收一个应答分组即可</li><li>2 <strong>等待时间应该减少到等于RTT和SPT之和</strong>。其中RTT(rount -trip-time)为往返时间，而SPT（service processing time）为服务器处理请求的时间</li><li>3 <strong>服务器应当能够检测出重复的请求</strong>，并且当收到一个重复的请求时不重新处理事务（避免重新处理意味着不必再次处理请求，而是<strong>返回保存的与该请求对应的应答</strong>）</li></ul></li><li><strong>TCP提供了过多的事务特征，而UDP提供的则不够</strong>。通常应用程序使用UDP来构造（避免TCP连接的开销），而许多需要的特征（如动态超时和重传、拥塞避免）被放置在应用层，一遍又一遍的重新设计和实现</li><li>一个较好的解决方案是提供一个能够提供<strong>足够多的事务处理功能的运输层</strong>。我们称这样的事务协议为T/TCP。</li><li>T/TCP<ul><li>TCP为处理事务而需要进行的两个改动是<strong>避免三次握手和缩短WAIT_TIME状态</strong>。T/TCP使<strong>用加速打开来避免三次握手</strong></li><li>1 它为打开的连接指定一个32bit的连接计数CC（connection count），<strong>无论主动打开还是被动打开</strong>。<strong>一个主机的CC值从一个全局计数器中获得</strong>，<strong>该计数器每次使用时加1</strong>。</li><li>2 在两个使用T/TCP的主机之间的每一个报文段都包括一个新的TCP选项 CC</li><li>3 <strong>一个服务器维护一个缓存，该缓存保留每个主机上一次的CC值</strong>，这些值从来自这个主机的一个可接受的SYN报文段中获得</li><li>4 当在一个开<strong>始的SYN报文中收到一个CC选项</strong>时，接收方比较收到的值与缓存该发送方的CC值。<strong>如果接收到的CC比缓存的大，则该SYN是新的</strong>，报文中的任何数据被传递给接受应用进程（服务器）。<strong>这个链接被成为半同步</strong>。如果<strong>接收的CC比缓存的小</strong>，或者接受主机上没有对应的这个客户的缓存的CC，则执行正常的TCP三次握手**</li><li>5 为响应一个开始的SYN，带有SYN和ACK的报文段在另一个被称为CCECHO的选项中回显所接收到的CC值 </li><li><img src="http://image.blissseven.top/blog/20190412/xCPPeSANo6ll.png?imageslim" alt="mark"></li><li>把很多东西融合到一个包中，客户的SYN，请求，</li></ul></li></ul></li><li><p>TCP的性能</p><ul><li>TCP的吞吐率限制<ul><li>不能比最慢的链路运行的更快</li><li>不能比最慢的机器的内存运行的更快</li><li>不能够比由由接收方提供的窗口处于往返时间所得结果运行的更快（这就是带宽时延乘积公式，使用窗口大小作为带宽时延乘积，就得到带宽值）。</li></ul></li><li><strong>TCP的最高速率的真正上限是由TCP的窗口大小和光速决定的</strong></li><li>1Mbps =10^6 bit 链路 1M数据=1024 x1024x8 bit</li><li>time=1024x1024x8/ 10^6</li><li><a href="http://osn.fx.net.nz/LFN/" target="_blank" rel="noopener">http://osn.fx.net.nz/LFN/</a></li></ul></li></ul><h3 id="第六天-1"><a href="#第六天-1" class="headerlink" title="第六天"></a>第六天</h3><h4 id="6-1-FTP"><a href="#6-1-FTP" class="headerlink" title="6.1 FTP"></a>6.1 FTP</h4><ul><li>数据传输的主流协议</li><li><strong>两个信道</strong><ul><li>控制信道：认证，罗列目录</li><li>数据信道：传数据</li></ul></li><li>FTP两个模式<ul><li><strong>实际什么模式由客户端决定</strong>。</li><li>Active Mode，第二信道是服务器主动发起的<ul><li><img src="http://image.blissseven.top/blog/20190413/CPWyI9YNATus.png?imageslim" alt="mark"></li><li>21 控制信号端口</li><li>由服务器给客户端的数据都是由第二信道开始的，第一次建立第二信道是list，第二次建立第二信道是传输数据</li><li>port a b c d e f 客户端IP地址a.b.c.d  第二信道客户端目的端口号e*256+f</li><li>源端口20</li><li>发送PORT 172，16，12,101,248,14之后会建立第二信道</li><li>nc -n -l -p 63502 &gt;result.txt将List结果发送到result.txt</li><li>如果要下载文件，需要再次发送port,且再换一个端口号</li><li><img src="http://image.blissseven.top/blog/20190413/qW5RTK530738.png?imageslim" alt="mark"></li><li></li></ul></li><li>Passive Mode，第二信道服务器被动接收的<ul><li><img src="http://image.blissseven.top/blog/20190413/0NJEcoIRgK8w.png?imageslim" alt="mark"></li><li>服务器被动接受，</li><li>PASV命令询问服务器能否支持Passive Mode，服务器会回一个227命令。</li><li>服务器地址a,b,c,e 端口号e*256+f</li><li>第二信道双方都是动态端口，更安全。</li><li><img src="http://image.blissseven.top/blog/20190413/7PkuLmx8M3jv.png?imageslim" alt="mark"></li><li></li></ul></li></ul></li><li>防火墙或NAT设备对FTP的影响<ul><li><img src="http://image.blissseven.top/blog/20190413/eQ50ShPeTNpG.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190413/betkljkNnjq0.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190413/6nwBs0ImrQNr.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190413/NBxAbRp7Mdyu.png?imageslim" alt="mark"></li><li></li></ul></li><li>多信道协议</li><li>应用层命令</li><li>防火墙做了什么</li></ul><h4 id="6-2-Telnet-协议"><a href="#6-2-Telnet-协议" class="headerlink" title="6.2 Telnet 协议"></a>6.2 Telnet 协议</h4><ul><li>特别不安全，交互式数据流，ftp成块式数据流</li><li><strong>远程登陆服务的标准协议的主要方式</strong>。为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用telnet程序，用它链接到服务器。终端使用者可以在telent程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个telent会话，必须输入用户名和密码来登陆服务器。<strong>telnet是常用的远程控制路由器的方法。</strong></li><li>23号端口</li><li>交互式TCP数据流的特点</li><li>安全问题（替代协议SSH）</li><li><img src="http://image.blissseven.top/blog/20190414/FUbXWOGNK6TI.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190414/i6IP4VyVX0DA.png?imageslim" alt="mark"></li></ul><h4 id="6-3-HTTP"><a href="#6-3-HTTP" class="headerlink" title="6.3 HTTP"></a>6.3 HTTP</h4><ul><li>HTTP协议（Hypertext Transfer Protocol超文本传输协议）用于从WWW服务器传输超文本到本地浏览器的传送协议，是一个客户端和服务器端请求和应答的标准（TCP）。</li><li>HTTP servers are pretty dumb servers 哑服务器</li><li>除非主动打招呼，否则不会理你</li><li><img src="http://image.blissseven.top/blog/20190414/XrsoSJs0oanv.png?imageslim" alt="mark"></li><li>http (协议)+blog.sina.com.cn (HOST)+ ***.html URI=URL</li><li><img src="http://image.blissseven.top/blog/20190414/OdK67WBlXgKK.png?imageslim" alt="mark"></li><li>Cookie ：FTP Telnet 持续性协议，HTTP瞬时协议<ul><li>让整个HTTP协议看似是连续性的，让应用持续提供服务</li></ul></li><li>多连接</li><li><img src="http://image.blissseven.top/blog/20190414/jefcTxJUqbd9.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190414/ktKdEeoL1NCY.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190414/NYVii4RTv4cc.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190414/2j8E3nXBgRLm.png?imageslim" alt="mark"></li></ul><h4 id="6-4-SMTP-POP3"><a href="#6-4-SMTP-POP3" class="headerlink" title="6.4 SMTP/POP3"></a>6.4 SMTP/POP3</h4><ul><li><p>SMTP发邮件 POPE收邮件</p></li><li><p>SMTP TCP/25</p></li><li><p>SMTP（simple MailTransfer Protocol 简单邮件传输协议）一组用于由源地址到目的地址传送邮件的规则，由它来控制信件中的中转方式。SMTP属于TCP./IP协议簇，帮助每台计算机在发送或中转信件时找到下一个目的地</p></li><li><p>SMTP服务器基于DNS中的MX记录来路由电子邮件，MX记录注册域名相关的SMTP中继主机，属于该域的电子邮件都应向该主机发送。若SMTP服务器mail.abc.com收到一封信要发送到<a href="mailto:collinsctk@qytang.com.cn" target="_blank" rel="noopener">collinsctk@qytang.com.cn</a></p><ul><li><p>Sendmail请求DNS给出主机qytang.com的MX记录（邮件路由及记录）（如果有CNAME记录(别名)，则需要再解析CNAME，最终得到域名的A记录）</p></li><li><p>qytang.com的MX记录如下(nslookup,set q=mx)</p><ul><li>qytang.com MX preference=5,mail exchanger=mail1.qytang.com</li><li>qytang.com MX preference=10,mail exchanger=mail2.qytang.com</li></ul></li><li><p>Sendmail 请求DNS给出mail1.qytang.com和mail2.qytang.com的A记录（如若有CNAME记录，则需要解析CNMAE最终对应域名的A记录），即IP地址，若返回值为202.100.1.101 和202.100.102</p></li><li><p>Sendmail优先投递MX优先级小的服务器，因此与202.100.1.101连接，传送这封给<a href="mailto:collinsctk@qytang.com" target="_blank" rel="noopener">collinsctk@qytang.com</a>的信到202.100.1.101这台服务器的SMTP后台程序</p></li><li><p><img src="http://image.blissseven.top/blog/20190414/OlptRi21RS0b.png?imageslim" alt="mark"></p></li><li><p>PTR解析（IP-&gt;域名） A解析(域名-&gt;IP) MX解析（邮件服务器）</p></li><li><p>主机-CNAME-&gt;MX记录-&gt;A记录</p></li></ul></li><li><p>SMTP协议工作原理</p><ul><li>SMTP在两种情况下工作<ul><li>电子邮件从客户机传输到服务器</li><li>从某一个服务器传输到服务器</li></ul></li><li>SMTP也是个请求/响应协议，命令和响应都是基于ASCII文本，并以CR/LF（回车换行）结束。响应包括一个表示返回状态的三位数字代码。SMTP在TCP协议25号端口监听持续请求</li><li>连接和发送过程如下:<ul><li>建立TCP连接</li><li>客户端发送HELO命令以标识发件人自己的身份，然后客户端发送MAIL命令；服务器端正希望以OK作为响应，表明准备接受</li><li>客户端发送PCRT命令，以标识该电子邮件的计划接受人，可以有多个RCPT行；服务器端则标识是否愿意为收件人接收邮件。</li><li>协商结束，发送邮件，用命令DATA发送</li><li>以“.”号表示结束输入内容一起发送过去，结束此次发送，用QUIT命令退出</li></ul></li></ul></li><li><p><img src="http://image.blissseven.top/blog/20190414/EPvrmVJCCyLs.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190414/9lolhN7W8puo.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190414/i6qALcY9vXnt.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190414/rkIjROF4E5uN.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190414/WFC6uGFEqqBJ.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190414/Ok2VEVcYy81G.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190414/SNanmbVatWxu.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190414/yb1SLLsn0NK6.png?imageslim" alt="mark"></p></li><li></li></ul><p><img src="http://image.blissseven.top/blog/20190414/DqrGeehaSfkz.png?imageslim" alt="mark"></p><ul><li><p><img src="http://image.blissseven.top/blog/20190414/jrUHTXUYCSQK.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190414/Dpy0CmIfYy96.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190414/SIGdHS5NTzct.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190414/X7vR5QxOpniU.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190414/IxGPcmcoen5l.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190414/uYuEzcY6M2IS.png?imageslim" alt="mark"></p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">E:\tools\netcat-win32<span class="number">-1.12</span>&gt;nc smtp<span class="number">.163</span>.com <span class="number">25</span></span><br><span class="line"><span class="number">220</span> <span class="number">163.</span>com Anti-<span class="function">spam GT <span class="keyword">for</span> Coremail <span class="title">System</span> <span class="params">(<span class="number">163</span>com[<span class="number">20141201</span>])</span></span></span><br><span class="line">EHLO smtp.163.com</span><br><span class="line"><span class="number">250</span>-mail</span><br><span class="line"><span class="number">250</span>-PIPELINING</span><br><span class="line"><span class="number">250</span>-AUTH LOGIN PLAIN</span><br><span class="line"><span class="number">250</span>-AUTH=LOGIN PLAIN</span><br><span class="line"><span class="number">250</span>-coremail <span class="number">1U</span>xr2xKj7kG0xkI17xGrU7I0s8FY2U3Uj8Cz28x1UUUUU7Ic2I0Y2UFcv1ZcUCa0xDrUUUUj</span><br><span class="line"><span class="number">250</span>-STARTTLS</span><br><span class="line"><span class="number">250</span> <span class="number">8B</span>ITMIME</span><br><span class="line">AUTH LOGIN</span><br><span class="line"><span class="number">334</span> dXNlcm5hbWU6</span><br><span class="line">YTEyM2RlNw==</span><br><span class="line"><span class="number">334</span> UGFzc3dvcmQ6</span><br><span class="line">QWExNTczODUxMzg1MA==</span><br><span class="line"><span class="number">235</span> Authentication successful</span><br><span class="line">MAIL FROM:&lt;a123de7@<span class="number">163.</span>com&gt;</span><br><span class="line"><span class="number">250</span> Mail OK</span><br><span class="line">RCPT TO:&lt;a123de7@<span class="number">163.</span>com&gt;</span><br><span class="line"><span class="number">250</span> Mail OK</span><br><span class="line">DATA</span><br><span class="line"><span class="number">354</span> End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;</span><br><span class="line">test</span><br><span class="line">test</span><br><span class="line">test</span><br><span class="line">test</span><br><span class="line">mail use nc</span><br><span class="line">TO:a123de7@<span class="number">163.</span>com</span><br><span class="line">From:qweqwe@<span class="number">163.</span>com</span><br><span class="line">SUBJECT:testtest</span><br><span class="line">.</span><br><span class="line"><span class="number">250</span> Mail OK queued as smtp7,C8CowADXxVp7oLJcq0O1AA-<span class="number">-.46051</span>S2 <span class="number">1555210727</span></span><br></pre></td></tr></table></figure></li><li><p><img src="http://image.blissseven.top/blog/20190414/mIGsBdksemXy.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190414/APofJd3cXb03.png?imageslim" alt="mark"></p></li><li><p>POP3,(Post Office Protocol-Version3)即，邮局协议版本3.TCP/IP协议的一员。主要支持使用客户端远程管理在服务器上的电子邮件。提供了SSL加密的POP3成为POP3S</p></li><li><p>POP协议支持“离线”邮件处理。具体过程为：邮件发送到服务器上，电子邮件客户端调用邮件客户机程序以连接服务器，并下载所有未阅读的电子邮件。这种离线访问模式是一种存储转发服务，将邮件从邮件服务器端发送到个人终端。一旦邮件发送到PC上，邮件服务器上的邮件就会被删除。但目前的POP3邮件服务器大都可以只下载邮件并不删除，也就是改进的POP3协议</p></li><li><p><strong>TCP/110</strong></p></li><li><p><img src="http://image.blissseven.top/blog/20190414/6AUw7ytrx6Y5.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190414/w1t1KYVYx3Fb.png?imageslim" alt="mark"></p></li><li><p><img src="http://image.blissseven.top/blog/20190414/KUhFkaT8u5Uj.png?imageslim" alt="mark"></p></li></ul><h4 id="6-5-SSL（secure-socket-layer）"><a href="#6-5-SSL（secure-socket-layer）" class="headerlink" title="6.5 SSL（secure socket layer）"></a>6.5 SSL（secure socket layer）</h4><ul><li>安全套接层用于保障World Wide Web通讯的安全。 私有</li><li>TLS Transport Layer Security 公有</li><li>不依赖于平台和应用程序的协议，用于保障TCP-based运用安全，SSL在TCP层和运用层之间，就像运用层连接到TCP连接的一个插口</li><li><img src="http://image.blissseven.top/blog/20190414/kXt0QJwR01n8.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190414/a4d606GNEzWz.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190414/sO7YGkdn10i4.png?imageslim" alt="mark"></li><li><img src="http://image.blissseven.top/blog/20190414/n3UPG4G9RPpT.png?imageslim" alt="mark"></li><li>PC说我支持很多算法，并发送给服务器，服务器选择一个算法并通知PC。服务器将服务器证书发送给PC（里有公钥），PC用那个算法加密这个公钥得到密钥包并发送给服务器，服务器的私钥去解这个</li><li>多个功能可能在一个包中</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11 多线程编程2</title>
      <link href="/2019/01/17/concurrency-in-cpp11-2/"/>
      <url>/2019/01/17/concurrency-in-cpp11-2/</url>
      
        <content type="html"><![CDATA[<ul><li>用作thread_note的补充，主要以Cpp-Concurrency-In-Action 为例</li></ul><a id="more"></a><h2 id="3-线程间共享数据"><a href="#3-线程间共享数据" class="headerlink" title="3 线程间共享数据"></a>3 线程间共享数据</h2><ul><li><p>保护很少更新的数据结构</p></li><li><p>一个作者线程独占访问，多个读者线程并发访问</p></li><li><p>频率很低的数据要更新，需要一个写线程独占互斥量，多个读线程共享互斥量</p></li><li><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）当读写锁是写加锁状态时，在这个锁被解锁之前，所有试图对这个锁加锁的线程都会被阻塞。（交叉互斥）</span><br><span class="line">（2）当读写锁在读加锁状态时，所有试图以读模式对它进行加锁的线程都可以得到访问权，但是以写模式对它进行加锁的线程将会被阻塞。（读共享，交叉互斥）</span><br><span class="line">（3）当读写锁在读模式的锁状态时，如果有另外的线程试图以写模式加锁，读写锁通常会阻塞随后的读模式锁的请求，这样可以避免读模式锁长期占用，而等待的写模式锁请求则长期阻塞。（写优先）</span><br></pre></td></tr></table></figure></li><li><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">dns_entry</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dns_cache</span>&#123;</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,dns_entry&gt; entries;</span><br><span class="line">    <span class="keyword">mutable</span> shared_mutex entry_mutex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">dns_entry <span class="title">find_entry</span><span class="params">(<span class="built_in">string</span> <span class="keyword">const</span>&amp; domain)</span> <span class="keyword">const</span><span class="comment">//读线程</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        shared_lock&lt;shared_mutex&gt; lk(entry_mutex);</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>,dns_entry&gt;::const_iterator <span class="keyword">const</span> it=</span><br><span class="line">                entries.find(domain);</span><br><span class="line">        <span class="keyword">return</span> (it==entries.end())? dns_entry():it-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update_or_add_entry</span><span class="params">(<span class="built_in">string</span> <span class="keyword">const</span>&amp; domain,dns_entry <span class="keyword">const</span>&amp; dns_detail)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        lock_guard&lt;shared_mutex&gt; lk(entry_mutex);</span><br><span class="line">        entries[domain]=dns_detail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="4-同步并发"><a href="#4-同步并发" class="headerlink" title="4 同步并发"></a>4 同步并发</h2><ul><li><p>等待条件完成</p></li><li><p>必须要用unique_lock,不能用Lock_guard，因为wait时，可能会解锁</p></li><li><p>wait 先检查条件，如果满足，直接返回。否则，解锁，处于等待状态。</p></li><li><p>当被唤醒时，加锁，检查条件，如果条件不满足，解锁，继续睡眠，条件满足，返回</p></li><li><p>虚假唤醒：被唤醒，但是条件不满足</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex mut;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;data_chunk&gt; data_queue; <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">std</span>::condition_variable data_cond;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">data_preparation_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"> <span class="keyword">while</span>(more_data_to_prepare())</span><br><span class="line"> &#123;</span><br><span class="line"> data_chunk <span class="keyword">const</span> data=prepare_data();</span><br><span class="line"> <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);</span><br><span class="line"> data_queue.push(data); <span class="comment">// 2</span></span><br><span class="line"> data_cond.notify_one(); <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">data_processing_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"> <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(mut); <span class="comment">// 4</span></span><br><span class="line">     data_cond.wait(</span><br><span class="line">     lk,[]&#123;<span class="keyword">return</span> !data_queue.empty();&#125;); <span class="comment">// 5</span></span><br><span class="line">     data_chunk data=data_queue.front();</span><br><span class="line">     data_queue.pop();</span><br><span class="line">     lk.unlock(); <span class="comment">// 6</span></span><br><span class="line">     process(data);</span><br><span class="line">     <span class="keyword">if</span>(is_last_chunk(data))</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>,<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp;)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">bar</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">X x;</span><br><span class="line"><span class="keyword">auto</span> f1=<span class="built_in">std</span>::async(&amp;X::foo,&amp;x,<span class="number">42</span>,<span class="string">"hello"</span>); <span class="comment">// 调用p-&gt;foo(42,"hello")，p是指向x的指针</span></span><br><span class="line"><span class="keyword">auto</span> f2=<span class="built_in">std</span>::async(&amp;X::bar,x,<span class="string">"goodbye"</span>); <span class="comment">// 调用tmpx.bar("goodbye")， tmpx是x的拷贝副本</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Y</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Y y;</span><br><span class="line"><span class="keyword">auto</span> f3=<span class="built_in">std</span>::async(Y(),<span class="number">3.141</span>); <span class="comment">// 调用tmpy(3.141)，tmpy通过Y的移动构造函数得到</span></span><br><span class="line"><span class="keyword">auto</span> f4=<span class="built_in">std</span>::async(<span class="built_in">std</span>::ref(y),<span class="number">2.718</span>); <span class="comment">// 调用y(2.718)</span></span><br><span class="line"></span><br><span class="line"><span class="function">X <span class="title">baz</span><span class="params">(X&amp; test)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"><span class="built_in">std</span>::async(baz,<span class="built_in">std</span>::ref(x)); <span class="comment">// 调用baz(x)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">move_only</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">    move_only();</span><br><span class="line">    move_only(move_only&amp;&amp;)</span><br><span class="line">    move_only(move_only <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    move_only&amp; <span class="keyword">operator</span>=(move_only&amp;&amp;);</span><br><span class="line">    move_only&amp; <span class="keyword">operator</span>=(move_only <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> f5=<span class="built_in">std</span>::async(move_only()); <span class="comment">// 调用tmp()，tmp是通过</span></span><br><span class="line"><span class="built_in">std</span>::move(move_only())构造得到</span><br><span class="line"><span class="comment">//当参数为右值(rvalues)时，拷贝操作将使用移动的方式转移原始数据</span></span><br></pre></td></tr></table></figure></li><li></li><li></li><li><p>wait_for wait_until</p><ul><li><table><thead><tr><th>std::this_thread namespace</th><th>sleep_for(duration) sleep_until (time_point)</th><th>N/A</th></tr></thead><tbody><tr><td>std::condition_ variable or std::condition_ variable_any</td><td>wait_for(lock, duration) wait_until(lock, time_point)</td><td>std::cv_status:: timeout or std::cv_status:: no_timeout</td></tr><tr><td>wait_for(lock, duration, predicate) wait_until(lock, time_point, predicate)</td><td>bool—the return value of the predicate when awakened</td><td></td></tr><tr><td>std::timed_mutex or std::recursive_ timed_mutex</td><td>try_lock_for (duration) try_lock_until (time_point)</td><td>bool—true if the lock was acquired, false otherwise</td></tr><tr><td>std::unique_ lock<timedlockable></timedlockable></td><td>unique_lock(lockable, duration) unique_lock(lockable, time_point)</td><td>N/A—owns_lock() on the newly constructed object; returns true if the lock was acquired, false otherwise</td></tr><tr><td>try_lock_for(duration) try_lock_until (time_point)</td><td>bool—true if the lock was acquired, false otherwise</td><td></td></tr><tr><td>std::future<valuetype> or std::shared_ future<valuetype></valuetype></valuetype></td><td>wait_for(duration) wait_until (time_point)</td><td>std::future_status:: timeout if the wait timed out, std::future_ status::ready if the future is ready, or std::future_status:: deferred if the future holds a deferred function that hasn’t yet started</td></tr></tbody></table></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Concurrency </tag>
            
            <tag> C++11 </tag>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11 多线程编程</title>
      <link href="/2019/01/03/concurrency-in-cpp11/"/>
      <url>/2019/01/03/concurrency-in-cpp11/</url>
      
        <content type="html"><![CDATA[<ul><li>C++11 多线程编程</li><li>C++ Concurrency in Action </li></ul><a id="more"></a><p>线程是用来运行程序的，而进程不是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myclass</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> &amp;myint;</span><br><span class="line">    myclass(<span class="keyword">int</span> &amp;m_i)</span><br><span class="line">        :myint(m_i)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"sub thread operator()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">7</span>;</span><br><span class="line"><span class="function">myclass <span class="title">mc</span><span class="params">(num)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">mythread</span><span class="params">(mc)</span></span>;</span><br><span class="line">mythread.detach();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"main  thread is going to over!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//当主线程结束时，将销毁自动变量num，子线程仍然在使用num</span></span><br><span class="line"><span class="comment">//调用myclass的拷贝构造函数，复制到mythread该线程</span></span><br></pre></td></tr></table></figure><h2 id="3-线程传参，detach坑，成员函数作为线程函数"><a href="#3-线程传参，detach坑，成员函数作为线程函数" class="headerlink" title="3 线程传参，detach坑，成员函数作为线程函数"></a>3 线程传参，detach坑，成员函数作为线程函数</h2><h3 id="1-传递临时对象作为线程参数"><a href="#1-传递临时对象作为线程参数" class="headerlink" title="1.传递临时对象作为线程参数"></a>1.传递临时对象作为线程参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myprint</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;i,<span class="keyword">char</span>* pmybuff)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"><span class="keyword">int</span> myvar=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;myvary=myvar;</span><br><span class="line"><span class="keyword">char</span> mybuf[]=<span class="string">"test"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">thread <span class="title">mytobj</span><span class="params">(myprint,myvar,mybuf)</span></span>;</span><br><span class="line">mytobj.join();</span><br><span class="line"><span class="comment">////</span></span><br><span class="line">mytobj.detach();</span><br><span class="line"><span class="comment">//myprint 中 myvar 复制给i,&amp;i != &amp;myvar,实际值传递 detach时i使用没问题</span></span><br><span class="line"><span class="comment">//pmybuff= mybuf</span></span><br><span class="line"><span class="comment">//指针在detach子线程时，有问题</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myprint</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;i,<span class="keyword">const</span> <span class="built_in">string</span>&amp; pmybuff)</span><span class="comment">// 依靠自动类型转换,生成临时变量 detach时没问题</span></span></span><br><span class="line"><span class="function"><span class="comment">//mybuf 有可能在main执行完被回收后才转为string</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line">thread mytobj(myprint,myvar,string(mybuf))；///！！！！！！！！！！！！！！</span><br><span class="line">    <span class="comment">//传递一个临时对象给myprint</span></span><br><span class="line"><span class="comment">//在创建线程的同时，创建临时对象是可行的。，在主线程结束之前被构造出来</span></span><br></pre></td></tr></table></figure><ul><li><p>只要 通过构造临时A对象作为参数传递给线程，那么就一定能够在主线程执行完毕前将线程函数的第二个参数构造出来。</p></li><li><p>若直接Int简单类型，直接值传递</p></li><li><p><strong>如果class对象，避免隐式类型转换，在创建线程的同时，创建临时对象，线程函数参数用引用，否则，会再拷贝构造一次对象</strong></p></li><li><p>局部变量失效导致线程对内存的非法引用问题</p></li></ul><h3 id="2-临时对象作为线程参数继续讲"><a href="#2-临时对象作为线程参数继续讲" class="headerlink" title="2.临时对象作为线程参数继续讲"></a>2.临时对象作为线程参数继续讲</h3><p>线程int id  this_thread::get_id();</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//void myprint(1,"123") 隐式转换在子线程中 转换</span></span><br><span class="line"><span class="comment">//void myprint(1,string("123"))临时对象在主线程中 被构造，构造函数，拷贝构造都在主线程</span></span><br></pre></td></tr></table></figure><ul><li><img src="http://image.blissseven.top/19-1-9/35245265.jpg" alt></li></ul><ul><li><img src="http://image.blissseven.top/19-1-9/31076679.jpg" alt></li></ul><ul><li></li><li><img src="http://image.blissseven.top/19-1-9/29432979.jpg" alt></li></ul><h3 id="3-传递类对象、智能指针作为线程参数"><a href="#3-传递类对象、智能指针作为线程参数" class="headerlink" title="3.传递类对象、智能指针作为线程参数"></a>3.传递类对象、智能指针作为线程参数</h3><ul><li><p>thread mytobj(myprint2,myobj)尽管引用，调用的是拷贝构造函数，所以线程改变参数时，无法影响main函数</p></li><li><p>myprint2(const A&amp; pybuff)   //传递不是引用时，必须加const,否则报错</p></li><li><p>std::ref()  传递引用参数，可以去掉const，不会调用拷贝构造函数</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myprint2</span><span class="params">(<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pzn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; myp(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>));</span><br><span class="line">  <span class="function">thread <span class="title">mytobj</span><span class="params">(myprint2,<span class="built_in">std</span>::move(myp))</span></span>;</span><br><span class="line">  mytobj.join()<span class="comment">//不能detach，new int(100) 释放，而线程仍指向该内存 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><pre><code>### 4.用成员函数指针作为线程参数</code></pre>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">thread_work</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A <span class="title">myobj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">thread mytobj(&amp;A::thread_work,myobj,15)；// 调拷贝构造myobj</span><br><span class="line">thread mytobj(&amp;A::thread_work,ref(myobj),15)；====thread mytobj(&amp;A::thread_work,&amp;myobj,15)；    //两种模式相同，不调用拷贝构造，detach不安全</span><br><span class="line">mytobj.join();</span><br></pre></td></tr></table></figure><ul><li></li></ul><h2 id="4-创建多个线程、数据共享问题分析"><a href="#4-创建多个线程、数据共享问题分析" class="headerlink" title="4 创建多个线程、数据共享问题分析"></a>4 创建多个线程、数据共享问题分析</h2><h3 id="1-创建和等待多个线程"><a href="#1-创建和等待多个线程" class="headerlink" title="1.创建和等待多个线程"></a>1.创建和等待多个线程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myprint</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;thread&gt; mythreads;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    mythreads.push(thread(myprint,i));<span class="comment">//创建同时，已在执行</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter=mythreads.begin();iter!=mythreads.end();++iter)</span><br><span class="line">    iter-&gt;join();/</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"end"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//所有子线程结束后，主线程才结束</span></span><br></pre></td></tr></table></figure><h3 id="2-数据共享问题分析"><a href="#2-数据共享问题分析" class="headerlink" title="2.数据共享问题分析"></a>2.数据共享问题分析</h3><ul><li>只读数据没问题</li><li>有读有写</li></ul><h3 id="3-共享数据的保护案例代码"><a href="#3-共享数据的保护案例代码" class="headerlink" title="3.共享数据的保护案例代码"></a>3.共享数据的保护案例代码</h3><ul><li><p>一个线程收集玩家命令，写入到队列中</p></li><li><p>从队列中取出命令</p></li><li><p>list 频繁按顺序插入删除数据  vector 随机插入删除</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">inMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000000</span>;i++)</span><br><span class="line">            msgRecvQueue.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">outMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000000</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!msgRecvQueue.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> cmd=msgRecvQueue.front();</span><br><span class="line">                msgRecvQueue.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"list empty"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; msgRecvQueue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multithread_read_write_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A myobj;</span><br><span class="line">    <span class="function">thread <span class="title">myoutobj</span><span class="params">(&amp;A::outMsgRecvQueue,&amp;myobj)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">myinobj</span><span class="params">(&amp;A::inMsgRecvQueue,&amp;myobj)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    myinobj.join();</span><br><span class="line">     myoutobj.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-互斥量概念、用法、死锁"><a href="#5-互斥量概念、用法、死锁" class="headerlink" title="5.互斥量概念、用法、死锁"></a>5.互斥量概念、用法、死锁</h2><h3 id="互斥量基本概念"><a href="#互斥量基本概念" class="headerlink" title="互斥量基本概念"></a>互斥量基本概念</h3><ul><li><p>一个类对象，多个线程可尝试Lock成员函数加锁，只有一个可以锁成功，标志时Lock函数返回。如果没有锁成功，会卡在lock这里，并不断尝试，原则是只保护 需要保护的数据</p></li><li><p>if 多个分支 一个lock对应一个unlock</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MUTEX_DEADLOCK_HPP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MUTEX_DEADLOCK_HPP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span>  mutex_deadlock&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; msgRecvQueue;</span><br><span class="line">    mutex mymutex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"insert a number"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            mymutex.lock();</span><br><span class="line">            msgRecvQueue.push_back(i);</span><br><span class="line">            mymutex.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">outMsgProc</span><span class="params">(<span class="keyword">int</span>&amp; command)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">          mymutex.lock();</span><br><span class="line">        <span class="keyword">if</span>(!msgRecvQueue.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            command=msgRecvQueue.front();</span><br><span class="line">            msgRecvQueue.pop_front();</span><br><span class="line">            mymutex.unlock();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mymutex.unlock();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">outMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)</span><br><span class="line">       &#123;</span><br><span class="line">            <span class="keyword">int</span> cmd=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">bool</span> result=outMsgProc(cmd);</span><br><span class="line">           <span class="keyword">if</span>(result)</span><br><span class="line">           &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"pop a number:: "</span>&lt;&lt;cmd&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               <span class="built_in">cout</span>&lt;&lt;<span class="string">"list empty..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mutex_deadlock_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A myobj;</span><br><span class="line">    <span class="function">thread <span class="title">myoutobj</span><span class="params">(&amp;A::outMsgRecvQueue,&amp;myobj)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">myinobj</span><span class="params">(&amp;A::inMsgRecvQueue,&amp;myobj)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    myinobj.join();</span><br><span class="line">    myoutobj.join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MUTEX_DEADLOCK_HPP</span></span></span><br></pre></td></tr></table></figure></li><li><p>lock_guard 的类模板，自动unlock,替代lock和unlock,在构造函数调用lock，析构函数一般在return调用unlock，或者加一个作用域标识符{}</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mymutex.lock();<span class="comment">//</span></span><br><span class="line">lock_guard&lt;mutex&gt; lguard(my_mutex);</span><br></pre></td></tr></table></figure></li></ul><h3 id="互斥量用法"><a href="#互斥量用法" class="headerlink" title="互斥量用法"></a>互斥量用法</h3><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li><p>一个互斥量一把锁，死锁问题 至少两把锁，至少两个互斥量，</p></li><li><p>线程A，先锁lockA, 成功，在锁lockB时，线程切换</p></li><li><p>线程B，先锁lockB，成功，等待锁lockA，线程A等待锁lockB</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//threadA：</span></span><br><span class="line">mutex1.lock();</span><br><span class="line">mutex2.lock();</span><br><span class="line"></span><br><span class="line">mutex2.unlock();</span><br><span class="line">mutex1.unlock();</span><br><span class="line"></span><br><span class="line"><span class="comment">//threadB:</span></span><br><span class="line">mutex2.lock();</span><br><span class="line">mutex1.lock();</span><br><span class="line"></span><br><span class="line">mutex2.unlock();</span><br><span class="line">mutex1.unlock();</span><br></pre></td></tr></table></figure></li><li><p>deadlock解决</p><ul><li>保证互斥量上锁顺序一致，lock_guard上锁顺序一致</li></ul></li><li><p>lock 函数模板</p><ul><li><p>一次至少锁两个互斥量。同一时刻锁祝多个互斥量，不存在上锁顺序不一致时导致的死锁。</p></li><li><p>如果有一个没有锁住，就释放已经锁住的锁，否则全部锁住才返回。要么都锁住，要么都不锁住，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lock(mutex1,mutex2);</span><br><span class="line">mutex1.unlock();</span><br><span class="line">mutex2.unlock();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>lock_guard</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lock(mutex1,mutex2);</span><br><span class="line">lock_guard&lt;mutex&gt; guard1(mutex1,adopt_lock);<span class="comment">//不上锁</span></span><br><span class="line">lock_guard&lt;mutex&gt; guard2(mutex2,adopt_lock);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>adopt_lock 标识互斥量已经上锁</p></li></ul><h2 id="6-unique-lock"><a href="#6-unique-lock" class="headerlink" title="6.unique_lock"></a>6.unique_lock</h2><h3 id="unique-lock取代lock-guard"><a href="#unique-lock取代lock-guard" class="headerlink" title="unique_lock取代lock_guard"></a>unique_lock取代lock_guard</h3><ul><li>类模板，一般lock_guard足够，lock_guard 构造加锁，析构解锁</li><li>unique_lock 效率差，内存多，灵活性高</li></ul><h3 id="unique-lock第二个参数"><a href="#unique-lock第二个参数" class="headerlink" title="unique_lock第二个参数"></a>unique_lock第二个参数</h3><ul><li><p>adopt_lock 标记已上锁（所以必须提前lock,否则异常），无需再上锁，假设调用方 线程 已经拥有了互斥的所有权</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mymutex1.lock();</span><br><span class="line">unique_lock&lt;mutex&gt; guard1(mymutex1,adopt_lock);</span><br></pre></td></tr></table></figure></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::chrono::<span class="function">millseconds <span class="title">dura</span><span class="params">(<span class="number">20000</span>)</span></span>;<span class="comment">//20s</span></span><br><span class="line">this_thread.sleep_for(dura);</span><br></pre></td></tr></table></figure></li><li><p>try_to_lock 尝试用mutex的lock锁Mutex，如果没有成功，也会立即返回。前提是,不能上锁</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">unique_lock&lt;mutex&gt; guard1(mymutex1,try_to_lock);</span><br><span class="line"><span class="keyword">if</span>(guard1.owns_lock())<span class="comment">//如果拿到锁</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>defer_lock 前提 不能lock，否则异常，初始化 一个不加锁的mutex</p></li><li></li></ul><h3 id="unique-lock-成员函数"><a href="#unique-lock-成员函数" class="headerlink" title="unique_lock 成员函数"></a>unique_lock 成员函数</h3><ul><li><p>lock</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">unqiue_lock&lt;mutex&gt; guard1(mymutex1,defer_lock);<span class="comment">//将mymutex1 绑定guard1</span></span><br><span class="line">guard1.lock(); <span class="comment">//不用担心unlock</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理共享代码</span></span><br><span class="line">guard2.unlock()</span><br><span class="line"><span class="comment">//处理 非 共享代码</span></span><br><span class="line">guard1.lock()</span><br></pre></td></tr></table></figure></li><li></li></ul></li><li><p>unlock</p><ul><li>析构时就不会unlock,lock锁住的代码段越少，效率也高。锁的粒度–锁住的代码多少</li><li>锁力度细，锁住的代码少，效率高</li></ul></li><li><p>try_lock</p><ul><li>尝试加锁，如果拿到锁，返回true,否则false,不阻塞</li></ul></li><li><p>release</p><ul><li><p>返回所管理的mutex对象指针，并返回所有权，unique和mutex不再有联系</p></li><li><p>如果原来Mutex已加锁，就要负责自己unlock</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mutex *ptx=guard1.release();</span><br><span class="line"><span class="comment">//之后需要自己解锁mymutex</span></span><br><span class="line"><span class="comment">//.....</span></span><br><span class="line">ptx-&gt;unlock();</span><br></pre></td></tr></table></figure></li><li></li></ul></li></ul><h3 id="unique-lock所有权传递"><a href="#unique-lock所有权传递" class="headerlink" title="unique_lock所有权传递"></a>unique_lock所有权传递</h3><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">unqiue_lock&lt;mutex&gt; guard1(mymutex1）;</span><br><span class="line"><span class="comment">//guard1拥有mymutex1的所有权   </span></span><br><span class="line">unqiue_lock&lt;mutex&gt; guard2(<span class="built_in">std</span>::move(mymutex1)）;</span><br><span class="line">                          </span><br><span class="line">                          </span><br><span class="line">unique_lock&lt;mutex&gt; trn_unique_lock()</span><br><span class="line">&#123;</span><br><span class="line">   unique_lock&lt;mutex&gt; tmpguard(mymutex1);</span><br><span class="line">   <span class="keyword">return</span> tmpguard;<span class="comment">//从函数返回一个局部的Unique_lock对象可以，移动构造函数</span></span><br><span class="line">&#125;</span><br><span class="line">unqiue_lock&lt;mutex&gt; guard3= trn_unique_lock()；<span class="comment">//从函数返回一个局部的Unique_lock对象可以，移动构造函数</span></span><br></pre></td></tr></table></figure></li><li><p>所有权可以转移，不可复制</p></li><li><p>move</p></li><li><p>返回一个局部对象unique_lock<mutex></mutex></p></li></ul><h2 id="7-单例设计模式共享数据分析、解决，call-once"><a href="#7-单例设计模式共享数据分析、解决，call-once" class="headerlink" title="7.单例设计模式共享数据分析、解决，call_once"></a>7.单例设计模式共享数据分析、解决，call_once</h2><h3 id="1设计模式"><a href="#1设计模式" class="headerlink" title="1设计模式"></a>1设计模式</h3><ul><li>&lt;<head first><meta name="generator" content="Hexo 3.9.0">&gt;</head></li></ul><h3 id="2-单例设计模式"><a href="#2-单例设计模式" class="headerlink" title="2 单例设计模式"></a>2 单例设计模式</h3><ul><li><p>一个类的实例只有一个</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mycas</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    mycas()&#123;&#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> mycas* m_instance;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> mycas* <span class="title">getinstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_instance==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_instance=<span class="keyword">new</span> mycas();</span><br><span class="line">            <span class="keyword">static</span> cgarrecycle cl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">cgarrecycle</span>// 类中类，用来释放对象</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~cgarrecycle()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mycas::m_instance)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span> mycas::m_instance;</span><br><span class="line">                mycas::m_instance=<span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li></li></ul><h3 id="3-单例设计模式共享数据问题分析、解决"><a href="#3-单例设计模式共享数据问题分析、解决" class="headerlink" title="3 单例设计模式共享数据问题分析、解决"></a>3 单例设计模式共享数据问题分析、解决</h3><ul><li><p>建议再主线程创建单例，（在创建子线程之前），之后创建子线程。</p></li><li><p>问题：</p><ul><li><p>需要再自己创建的线程（非主线程）创建mycas实例，这种线程可能不止一个。</p></li><li><p>getinstance() 需要互斥,否则有可能创建多个实例</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> mycas* <span class="title">getinstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unique_lock&lt;mutex&gt; mymutex(resource_mutex);<span class="comment">//可以 但 效率低</span></span><br><span class="line">    <span class="keyword">if</span>(m_instance==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_instance=<span class="keyword">new</span> mycas();</span><br><span class="line">        <span class="keyword">static</span> cgarrecycle cl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// if(m_instance!=NULL) 表示m_instance已经被new</span></span><br><span class="line"><span class="comment">// if(m_instance==NULL) 不表示m_instance一定没被new过，不加mutex</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> mycas* <span class="title">getinstance2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_instance==<span class="literal">NULL</span>)<span class="comment">// 双重锁定</span></span><br><span class="line">    &#123;</span><br><span class="line">        unique_lock&lt;mutex&gt; mymutex(resource_mutex);<span class="comment">//可以 但 效率低</span></span><br><span class="line">        <span class="keyword">if</span>(m_instance==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_instance=<span class="keyword">new</span> mycas();</span><br><span class="line">            <span class="keyword">static</span> cgarrecycle cl;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////</span></span><br><span class="line"><span class="built_in">std</span>::once_flat g_flag;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createinstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      m_instance=<span class="keyword">new</span> mycas();</span><br><span class="line">            <span class="keyword">static</span> cgarrecycle cl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> mycas* <span class="title">getinstance3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//两个线程同时执行到这里，一个线程须等待另一个线程执行完毕createinstance后，才</span></span><br><span class="line"><span class="comment">//阻塞</span></span><br><span class="line">    <span class="built_in">std</span>::call_once(g_flag,createinstance);</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mythread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"mythrad "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    mycas *pa=mycas::getinstance();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">singleton_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//mycas *pa=mycas::getinstance();</span></span><br><span class="line"></span><br><span class="line">    <span class="function">thread <span class="title">thread1</span><span class="params">(mythread)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">thread2</span><span class="params">(mythread)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li></li></ul></li></ul><h3 id="4-std-call-once"><a href="#4-std-call-once" class="headerlink" title="4 std::call_once()"></a>4 std::call_once()</h3><ul><li>第二个参数为函数名A</li><li>保证函数A只被调用一次</li><li>具备互斥量能力，比mutex更高效</li><li>需要与一个标记使用，std::once_flag一个结构体，通过结构体决定A()是否执行</li><li>调用call_once成功，就把这个标记设置为以调用状态，下次调用call_once A（）不会执行</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> once_flag g_flag;   </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createinstance</span><span class="params">()</span><span class="comment">//只被调用一次</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"createinstance  once"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        m_instance=<span class="keyword">new</span> mycas();</span><br><span class="line">        <span class="keyword">static</span> cgarrecycle cl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> mycas* <span class="title">getinstance2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;<span class="string">"getinstance2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">       call_once(g_flag,createinstance);<span class="comment">//两个线程同时执行到这里，一个线程须等待另一个线程执行完毕createinstance后，才</span></span><br><span class="line">       <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>call_once 用在成员函数时</li><li>this，作为call_once 第二个参数 成员函数的参数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">connection_info connection_details;</span><br><span class="line">connection_handle connection;</span><br><span class="line"><span class="built_in">std</span>::once_flag connection_init_flag;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open_connection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">connection=connection_manager.open(connection_details);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">X(connection_info <span class="keyword">const</span>&amp; connection_details_):</span><br><span class="line">connection_details(connection_details_)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_data</span><span class="params">(data_packet <span class="keyword">const</span>&amp; data)</span> <span class="comment">// 1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::call_once(connection_init_flag,&amp;X::open_connection,<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    connection.send_data(data);</span><br><span class="line">&#125; </span><br><span class="line">    <span class="function">data_packet <span class="title">receive_data</span><span class="params">()</span> <span class="comment">// 3</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::call_once(connection_init_flag,&amp;X::open_connection,<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> connection.receive_data();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-condition-variable-wait-notify-one-notify-all"><a href="#8-condition-variable-wait-notify-one-notify-all" class="headerlink" title="8 condition_variable wait notify_one notify_all"></a>8 condition_variable wait notify_one notify_all</h2><h3 id="1-条件变量condition-variable-wait-norify-one"><a href="#1-条件变量condition-variable-wait-norify-one" class="headerlink" title="1 条件变量condition_variable wait() norify_one()"></a>1 条件变量condition_variable wait() norify_one()</h3><ul><li>线程A等待一个条件满足，从等待代码出，继续执行，阻塞</li><li>线程B往消息队列中扔消息（数据）</li><li>condition_variable  一个和条件相关的类，等待一个条件满足，需要和互斥量配合工作</li><li>用时，需要生成对象</li></ul><h2 id="2-条件变量导致的问题"><a href="#2-条件变量导致的问题" class="headerlink" title="2 条件变量导致的问题"></a>2 条件变量导致的问题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONDITION_VARIABLE8_HPP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONDITION_VARIABLE8_HPP</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> condition_variable_test</span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; msgRecvQueue;</span><br><span class="line">    mutex mymutex1;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            unique_lock&lt;mutex&gt; ulock(mymutex1);</span><br><span class="line">            msgRecvQueue.push_back(i);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"send a msg: "</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">outMsgProc</span><span class="params">(<span class="keyword">int</span>&amp; command)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 双重锁定</span></span><br><span class="line">        <span class="keyword">if</span>(!msgRecvQueue.empty())&#123;</span><br><span class="line">            </span><br><span class="line">             unique_lock&lt;mutex&gt; ulock2(mymutex1);</span><br><span class="line">             <span class="keyword">if</span>(!msgRecvQueue.empty())</span><br><span class="line">             &#123;</span><br><span class="line">                 command=msgRecvQueue.front();</span><br><span class="line">                 msgRecvQueue.pop_front();</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">outMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cmd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span>(outMsgProc(cmd))</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="built_in">cout</span>&lt;&lt;<span class="string">"receive a msg "</span>&lt;&lt;cmd&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   <span class="built_in">cout</span>&lt;&lt;<span class="string">"list empty"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">condition_variable_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        A myobj;</span><br><span class="line">        <span class="function">thread <span class="title">myoutobj</span><span class="params">(&amp;A::outMsgRecvQueue,&amp;myobj)</span></span>;</span><br><span class="line">        <span class="function">thread <span class="title">myinobj</span><span class="params">(&amp;A::inMsgRecvQueue,&amp;myobj)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        myinobj.join();</span><br><span class="line">        myoutobj.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// CONDITION_VARIABLE8_HPP</span></span></span><br></pre></td></tr></table></figure><ul><li><p>condition_variable.wait</p><ul><li><p>如果第二个lambda表达式返回值false,wait 解锁互斥量，并阻塞到本行，一直到其他某个线程norify_One()成员函数</p></li><li><p>返回true，wait直接返回</p></li><li><p>如果没有第二个参数，就和第二个参数返回false效果一样</p><ul><li>wait 被notify_one 唤醒后，wait 不断尝试获得锁，加锁如果获取不到，阻塞，如果获取到，就继续</li><li>唤醒后如果有第二个参数，如果false，解锁，再次休眠，等待再次被notify_one唤醒</li><li>如果为true，返回，此时互斥量被锁</li><li>如果没有第二个参数，wait返回</li></ul></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(unique_lock&lt;mutex&gt;&amp; _Lck)</span></span></span><br><span class="line"><span class="function">  </span>&#123;<span class="comment">// wait for signal</span></span><br><span class="line">  _Cnd_waitX(_Mycnd(), _Lck.mutex()-&gt;_Mymtx());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><pre><code>template&lt;class _Predicate&gt;    void wait(unique_lock&lt;mutex&gt;&amp; _Lck, _Predicate _Pred)    {    // wait for signal and test predicate    while (!_Pred())        wait(_Lck);    }</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outMsgRecvQueue2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cmd=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            unique_lock&lt;mutex&gt; ulock(mymutex1);</span><br><span class="line">            mycond.wait(ulock,[<span class="keyword">this</span>]&#123;</span><br><span class="line">                <span class="keyword">if</span>(!msgRecvQueue.empty())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">              cmd=msgRecvQueue.front();</span><br><span class="line">            msgRecvQueue.pop_front();</span><br><span class="line">            ulock.unlock();<span class="comment">//提前unlock</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"recvive a msg : "</span>&lt;&lt;cmd&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="comment">///wait//</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            unique_lock&lt;mutex&gt; ulock(mymutex1);</span><br><span class="line">            msgRecvQueue.push_back(i);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"send a msg: "</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            mycond.notify_one();<span class="comment">//尝试wait 线程唤醒</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>wait 唤醒后获得锁，和inMsgRecvQueue中获得锁，抢占资源，有可能send 多个消息，只有一个通知</li><li>唤醒后，如果不是卡在wait等待状态，丢失消息</li><li>不一定in 执行一次，Out执行一次</li><li>in限流，out多个线程取出数据</li><li>如果in先执行，out后执行，in先获得锁，Out不能获得锁，不会进行到wait</li></ul><h2 id="3-notify-all"><a href="#3-notify-all" class="headerlink" title="3 notify_all()"></a>3 notify_all()</h2><ul><li>notify_one只能通知一个线程，通知哪个不确定</li><li>醒着获得锁失败于是阻塞</li><li>notify_all 唤醒所有正在wait的线程</li></ul><h2 id="9-async-future-packaged-task-promise"><a href="#9-async-future-packaged-task-promise" class="headerlink" title="9 async future packaged_task promise"></a>9 async future packaged_task promise</h2><h3 id="1-asyc-future-创建后台任务并返回值"><a href="#1-asyc-future-创建后台任务并返回值" class="headerlink" title="1 asyc future 创建后台任务并返回值"></a>1 asyc future 创建后台任务并返回值</h3><ul><li>希望线程返回一个结果</li><li>asyc  函数模板，启动一个异步任务，返回future对象，一个类模板</li><li>异步任务—自动创建一个线程并开始自动执行对应的线程入口函数，返回的future对象中包含了线程入口函数返回的结果，即线程返回的结果，调用future对象成员函数get返回</li><li>future 提供一种访问异步操作结果的机制<ul><li><strong>当get时，会卡在get代码处</strong>，get等待线程结束 返回结果，get只能获得一次，</li><li>result.wait()等待线程返回，不返回结果</li><li><strong>当没有get时，卡在主线程的return处</strong>，在主线程最后运行子线程</li></ul></li><li>向async传递一个参数，参数类型std::launch类型<ul><li>std::launch::defered 表示线程入口函数调用被延迟到std::future的wait或者get()函数调用时才执行</li><li>如果wait get没有被调用，则不会执行该线程（），实际上，根本没有创建线程</li><li>std::launch::defered  实际上并没有创建线程，在主线程中执行线程入口函数</li><li></li><li>std::launch::async 在调用async函数的时候 开始创建线程</li><li>std::launch::async|std::launch::defered 默认参数， 或者std::launch::async 或者std::launch::defered</li></ul></li></ul><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X x;</span><br><span class="line">async(&amp;X::foo,&amp;x,<span class="number">1</span>,<span class="string">"test"</span>);<span class="comment">//1 次构造</span></span><br><span class="line">async(&amp;X::foo,x,<span class="number">2</span>,<span class="string">"test2"</span>);<span class="comment">//3 次复制构造</span></span><br></pre></td></tr></table></figure></li><li></li></ul><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mythread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"child thread id "</span>&lt;&lt;this_thread::get_id()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    chrono::<span class="function">microseconds <span class="title">dura</span><span class="params">(<span class="number">5000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    this_thread::sleep_for(dura);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">asyc_future_packaged_task_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"asyc_future_packaged_task_test"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"main thread id :"</span>&lt;&lt;this_thread::get_id()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    future&lt;<span class="keyword">int</span>&gt; result=async(mythread);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"continue...."</span>&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//不会卡在这里</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result= "</span>&lt;&lt;result.get()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//当取get时，会卡在这里</span></span><br><span class="line"><span class="comment">//result.get()// 只能调用一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">future&lt;<span class="keyword">int</span> &gt;result2=async(&amp;A::mythread,&amp;a,temp);</span><br><span class="line"><span class="comment">//&amp;a引用,确保 传递的是同一个a</span></span><br></pre></td></tr></table></figure></li><li></li></ul><h3 id="2-packaged-task"><a href="#2-packaged-task" class="headerlink" title="2 packaged_task"></a>2 packaged_task</h3><ul><li><p>打包任务，把任务打包起来，类模板，<strong>模板参数为可调用对象</strong>，把各种可调用对象包装起来，方便作为线程入口函数</p></li><li><p><strong>包装可调用对象为一个类模板对象</strong>，传递给thread 时引用ref</p></li><li><p>packaged_task 包装起来的可调用对象，还可以直接调用，pacaged_task也是一个可调用对象</p></li><li><p>以便通过get_future获得线程返回值</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">mythread2</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"child thread id "</span>&lt;&lt;this_thread::get_id()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    chrono::<span class="function">milliseconds <span class="title">dura</span><span class="params">(<span class="number">5000</span>)</span></span>;</span><br><span class="line">this_thread::sleep_for(dura);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"child thread end  num: "</span>&lt;&lt;num&lt;&lt;<span class="string">"id "</span>&lt;&lt;this_thread::get_id()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::packaged_task&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt;mypt(mythread2);<span class="comment">//把函数mythread 包装</span></span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(ref(mypt),<span class="number">1</span>)</span></span>;<span class="comment">//1 作为mythread的参数</span></span><br><span class="line">t1.join();</span><br><span class="line">future&lt;<span class="keyword">int</span>&gt; result4=mypt.get_future();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"result4= "</span>&lt;&lt;result4.get()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//立即拿到值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 借助于lambda 实现packaged_task</span></span><br><span class="line"> packaged_task&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; mypt2([](<span class="keyword">int</span> mypar)</span><br><span class="line">    &#123;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"child thread id "</span>&lt;&lt;this_thread::get_id()&lt;&lt;<span class="built_in">endl</span>;                    chrono::milliseconds dura(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">   this_thread::sleep_for(dura);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"child thread end  num: "</span>&lt;&lt;mypar&lt;&lt;<span class="string">"id "</span>&lt;&lt;this_thread::get_id()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> mypar;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(ref(mypt2),<span class="number">2</span>)</span></span>;<span class="comment">//1 作为mythread的参数</span></span><br><span class="line">t2.join();</span><br><span class="line">future&lt;<span class="keyword">int</span>&gt; result5=mypt2.get_future();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"result4= "</span>&lt;&lt;result5.get()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//立即拿到值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mypt55(<span class="number">105</span>);<span class="comment">//直接调用</span></span><br><span class="line"> future&lt;<span class="keyword">int</span>&gt; result6=mypt55.get_future();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"result4= "</span>&lt;&lt;result6.get()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//立即拿到值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;<span class="string">"packaged_task in vector "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::packaged_task&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt;mypt4(mythread2);</span><br><span class="line"><span class="built_in">vector</span> &lt;packaged_task&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt;&gt; mytasks;</span><br><span class="line">mytasks.push_back(move(mypt4)); <span class="comment">//移动语义</span></span><br><span class="line"><span class="keyword">auto</span> iter=mytasks.begin();</span><br><span class="line"><span class="built_in">std</span>::packaged_task&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt;mypt5=move(*iter);</span><br><span class="line">mytasks.erase(iter);<span class="comment">//删除之后，iter之后失效，后续代码不可以再用iter,iter为野指针</span></span><br><span class="line"></span><br><span class="line">mypt5(<span class="number">4</span>);</span><br><span class="line">result6=mypt5.get_future();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"result7= "</span>&lt;&lt;result6.get()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//立即拿到值</span></span><br></pre></td></tr></table></figure><ul><li><h3 id="3-promise"><a href="#3-promise" class="headerlink" title="3 promise"></a>3 promise</h3></li><li><p>在某个线程中给它赋值，在其他线程中取出来</p></li><li><p>通过promise 保存一个值，在将来某个时刻通过把一个future绑定到promise中来得到这个绑定的值</p></li><li><p>没有join时，卡在get处，但是还是会有异常，所以thread –join</p></li><li><p>promise 和future 匹配 可实现在两个线程间传递数据</p></li><li><p>当“承诺”的值已经设置完毕(使用set_value()成员函数)，对应“期望”的状态变为“就绪”，并且可用于检索已存储的值。当你在设置值之前销毁 std::promise ，将会存储一个异常 </p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">promise_thread</span><span class="params">(promise&lt;<span class="keyword">int</span>&gt;&amp; tmp,<span class="keyword">int</span> calc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    calc++;</span><br><span class="line">    calc*=<span class="number">10</span>;</span><br><span class="line">    chrono::<span class="function">milliseconds <span class="title">dura</span><span class="params">(<span class="number">5000</span>)</span></span>;</span><br><span class="line">    this_thread::sleep_for(dura);</span><br><span class="line">    <span class="keyword">int</span> result=calc;</span><br><span class="line">    tmp.set_value(result);<span class="comment">// 结果保存在promise tmp中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> promise&lt;<span class="keyword">int</span>&gt; myprom;</span><br><span class="line"> <span class="function">thread <span class="title">t11</span><span class="params">(promise_thread,ref(myprom),<span class="number">123</span>)</span></span>;</span><br><span class="line">  t11.join();</span><br><span class="line">future&lt;<span class="keyword">int</span>&gt; fut=myprom.get_future();<span class="comment">// promise 和future绑定 获取线程返回值</span></span><br><span class="line"><span class="keyword">auto</span> result_pro=fut.get();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"result_pro: "</span>&lt;&lt;result_pro&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">///</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">promise_thread2</span><span class="params">(future&lt;<span class="keyword">int</span>&gt;&amp; tmp)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result=tmp.get();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"promise_thread2 get value "</span>&lt;&lt;result&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">thread <span class="title">t12</span><span class="params">(promise_thread2,ref(fut))</span></span>;</span><br><span class="line">t12.join();</span><br></pre></td></tr></table></figure><ul><li><p>promise 存储异常</p></li><li><p>会在future.get时抛出</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">promise_thread_square</span><span class="params">(promise&lt;<span class="keyword">double</span>&gt;&amp; pr,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">"x&lt;0"</span>);</span><br><span class="line">  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"promise_thread_square  try...."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        pr.set_value(<span class="built_in">sqrt</span>(x));</span><br><span class="line">  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"promise_thread_square  catch...."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        pr.set_exception(<span class="built_in">std</span>::current_exception());</span><br><span class="line">        <span class="comment">//pr.set_exception(make_exception_ptr(std::logic_error("sqrt x error")));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  promise&lt;<span class="keyword">double</span>&gt; myprom2;</span><br><span class="line">  future&lt;<span class="keyword">double</span>&gt; fut2=myprom2.get_future();</span><br><span class="line">  <span class="function">thread <span class="title">t21</span><span class="params">(promise_thread_square,ref(myprom2),<span class="number">-1</span>)</span></span>;</span><br><span class="line">  t21.join();</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"promise thread over!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">double</span> res=fut2.get();</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"promise store exception over res= "</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4 小结"></a>4 小结</h3><ul><li>通过future.get() 获得线程返回值，<ul><li>主线程中 asyc函数模板 直接返回future 对象<ul><li>第一个参数 launch::defered ,线程延迟到future::wait /get执行 ，否则不执行，且在主线程中执行</li><li>默认第一个参数launch::async，线程立即执行</li></ul></li><li>主线程中  packaged_task 类模板，packaged_task::get_future获得future 对象<ul><li>可直接调用</li><li>thread时，  thread t2(ref(mypt2),2);  //1 作为mythread的参数 </li><li>future<int> result5=mypt2.get_future();  thread t2(move(mypt2),2); move之前获得future</int></li></ul></li><li>主/另一个子线程 中 promise 类模板  promise.set_value保存值，myprom.get_future()在另一个线程中获得值<ul><li>可用于两个线程间交互数据</li></ul></li></ul></li></ul><h2 id="10-future其他成员函数-shared-future-atomic"><a href="#10-future其他成员函数-shared-future-atomic" class="headerlink" title="10 future其他成员函数 shared_future atomic"></a>10 future其他成员函数 shared_future atomic</h2><h3 id="0-时钟"><a href="#0-时钟" class="headerlink" title="0 时钟"></a>0 时钟</h3><ul><li><p>时钟 当前时间可以通过调用静态成员函数now()从时钟类中获取 </p><ul><li>std::chrono::system_clock  系统时钟 </li><li>std::chrono::steady_clock   稳定时钟 </li><li>std::chrono::high_resolution_clock 标准库中提供的具有最小节拍周期(因此具有最高的精度[分辨率])的时钟  </li></ul></li><li><p>时延</p><ul><li><p>连续时间用duration&lt;long long, ratio&lt;1,1000&gt; &gt;  //第一个模板参数是一个类型<br>表示(比如，int，long或double)   第二个模板参数ratio&lt;1,1000&gt;  每一个单元所用秒数</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> ratio&lt;<span class="number">1</span>, <span class="number">1000</span>&gt; milli;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> duration&lt;<span class="keyword">long</span> <span class="keyword">long</span>, nano&gt; nanoseconds;</span><br><span class="line"><span class="keyword">typedef</span> duration&lt;<span class="keyword">long</span> <span class="keyword">long</span>, micro&gt; microseconds;</span><br><span class="line"><span class="keyword">typedef</span> duration&lt;<span class="keyword">long</span> <span class="keyword">long</span>, milli&gt; milliseconds;</span><br><span class="line"><span class="keyword">typedef</span> duration&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; seconds;</span><br><span class="line"><span class="keyword">typedef</span> duration&lt;<span class="keyword">int</span>, ratio&lt;<span class="number">60</span>&gt; &gt; minutes;</span><br><span class="line"><span class="keyword">typedef</span> duration&lt;<span class="keyword">int</span>, ratio&lt;<span class="number">3600</span>&gt; &gt; hours;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::chrono::<span class="function">milliseconds <span class="title">ms</span><span class="params">(<span class="number">54802</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::chrono::seconds s=</span><br><span class="line"><span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::seconds&gt;(ms);<span class="comment">//截断为 54s</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::chrono::milliseconds(<span class="number">1234</span>).count()<span class="comment">//时延中可以通过count()成员函数获得单位时间的数量 1234</span></span><br></pre></td></tr></table></figure></li><li></li></ul></li><li><p>时间点</p><ul><li>时间点可以用 std::chrono::time_point&lt;&gt; 的类型模板实例来表示，实例的第一个参数<br>用来指定所要使用的时钟，第二个函数参数用来表示时间的计量单位(特化<br>的 std::chrono::duration&lt;&gt; ) </li></ul></li><li><p>wait_for wait_until</p></li><li><table><thead><tr><th>std::this_thread namespace</th><th>sleep_for(duration) sleep_until (time_point)</th><th>N/A</th></tr></thead><tbody><tr><td>std::condition_ variable or std::condition_ variable_any</td><td>wait_for(lock, duration) wait_until(lock, time_point)</td><td>std::cv_status:: timeout or std::cv_status:: no_timeout</td></tr><tr><td></td><td>wait_for(lock, duration, predicate) wait_until(lock, time_point, predicate)</td><td>bool—唤醒时，返回谓词结果</td></tr><tr><td>std::timed_mutex or std::recursive_ timed_mutex</td><td>try_lock_for (duration) try_lock_until (time_point)</td><td>bool—获取锁，返回true，否则false</td></tr><tr><td>std::unique_ lock<timedlockable></timedlockable></td><td>unique_lock(lockable, duration) unique_lock(lockable, time_point)</td><td>N/A—对新构建的对 像调用owns_lock() returns true if the lock was acquired, false otherwise</td></tr><tr><td></td><td>try_lock_for(duration) try_lock_until (time_point)</td><td>bool—获取锁，返回true，否则false</td></tr><tr><td>std::future<valuetype> or std::shared_ future<valuetype></valuetype></valuetype></td><td>wait_for(duration) wait_until (time_point)</td><td>std::future_status:: timeout if the wait timed out, std::future_ status::ready if the future is ready, or std::future_status:: deferred if the future holds a deferred function that hasn’t yet started</td></tr></tbody></table></li></ul><h3 id="1-future其他成员函数"><a href="#1-future其他成员函数" class="headerlink" title="1 future其他成员函数"></a>1 future其他成员函数</h3><ul><li><p>future_status 枚举状态</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">future_status</span> &#123;</span><span class="comment">// names for timed wait function returns</span></span><br><span class="line">  ready,</span><br><span class="line">  timeout,</span><br><span class="line">  deferred</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><ul><li><p>timeout  线程执行时间超时，线程还没执行完，</p></li><li><p>ready 线程成功返回</p></li><li><p>defered 延迟，如果async第一个参数设置为std::launch::async满足条件</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mythread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"mythread start id "</span>&lt;&lt;this_thread::get_id()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    chrono::<span class="function">milliseconds <span class="title">dura</span><span class="params">(<span class="number">2500</span>)</span></span>;</span><br><span class="line">    this_thread::sleep_for(dura);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"mythread stop id "</span>&lt;&lt;this_thread::get_id()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">future_member_func_atomic_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"future_member_func_atomic_test id "</span>&lt;&lt;this_thread::get_id()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">       <span class="comment">// future&lt;int&gt; result=async(mythread);</span></span><br><span class="line">        future&lt;<span class="keyword">int</span>&gt; result=async(launch::deferred,mythread);</span><br><span class="line">       <span class="comment">// cout&lt;&lt;"result: "&lt;&lt;result.get()&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">        future_status status=result.wait_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">3500</span>));<span class="comment">//1000 ms时，timeout</span></span><br><span class="line">        <span class="keyword">if</span>(status==future_status::timeout)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"status timeout! thread not over"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(status==future_status::ready)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"status ready! thread  over "</span>&lt;&lt;result.get()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(status==future_status::deferred)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"status deferred! thread  delay to execute "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"result.get(): "</span>&lt;&lt;result.get()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li></li></ul></li></ul><h3 id="2-shared-future"><a href="#2-shared-future" class="headerlink" title="2  shared_future"></a>2  shared_future</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mythread2</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"mythread2 start id "</span>&lt;&lt;this_thread::get_id()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    chrono::<span class="function">milliseconds <span class="title">dura</span><span class="params">(<span class="number">2500</span>)</span></span>;</span><br><span class="line">    this_thread::sleep_for(dura);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"mythread2 stop id "</span>&lt;&lt;this_thread::get_id()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mythread22</span><span class="params">(future&lt;<span class="keyword">int</span>&gt;&amp; ft)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">"mythread22 start id "</span>&lt;&lt;this_thread::get_id()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> cmd=ft.get();</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">"mythread22 stop  cmd "</span>&lt;&lt;cmd&lt;&lt;<span class="string">" id "</span>&lt;&lt;this_thread::get_id()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">  packaged_task&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; mypt(mythread2);</span><br><span class="line">    future&lt;<span class="keyword">int</span>&gt; result2=mypt.get_future();</span><br><span class="line"></span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(ref(mypt),<span class="number">12</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line"></span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(mythread22,ref(result2))</span></span>;</span><br><span class="line">    t2.join();</span><br></pre></td></tr></table></figure><ul><li><p>future get两次会异常，get函数的设计是一个移动语义</p></li><li><p>多个线程 获得值时,遇到问题</p></li><li><p>shared_future 类模板，get 函数设计复制数据</p></li><li><p>result.valid() ，检测当前future对象，能否get到数据</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mythread2</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"mythread2 start id "</span>&lt;&lt;this_thread::get_id()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    chrono::<span class="function">milliseconds <span class="title">dura</span><span class="params">(<span class="number">2500</span>)</span></span>;</span><br><span class="line">    this_thread::sleep_for(dura);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"mythread2 stop id "</span>&lt;&lt;this_thread::get_id()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mythread222</span><span class="params">(shared_future&lt;<span class="keyword">int</span>&gt;&amp; ft)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">"mythread222 shared_future start id "</span>&lt;&lt;this_thread::get_id()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> cmd=ft.get();</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">"mythread222 shared_future stop  cmd "</span>&lt;&lt;cmd&lt;&lt;<span class="string">" id "</span>&lt;&lt;this_thread::get_id()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">packaged_task&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; mypt2(mythread2);</span><br><span class="line">future&lt;<span class="keyword">int</span>&gt; result_temp=mypt2.get_future();</span><br><span class="line"></span><br><span class="line">shared_future&lt;<span class="keyword">int</span>&gt; shared_result(move(result_temp));<span class="comment">//右值</span></span><br><span class="line"><span class="comment">//shared_future&lt;int&gt; shared_result2(result_temp.share());//右值</span></span><br><span class="line"><span class="comment">//shared_future&lt;int&gt; shared_result3(mypt2.get_future());// 通过future 构造shared_future</span></span><br><span class="line"><span class="keyword">if</span>(!result_temp.valid())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result_temp  invalid"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">thread <span class="title">t3</span><span class="params">(ref(mypt2),<span class="number">13</span>)</span></span>;</span><br><span class="line">t3.join();</span><br><span class="line"><span class="comment">// cout&lt;&lt;"shared_result: "&lt;&lt;shared_result.get()&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line"><span class="function">thread <span class="title">t4</span><span class="params">(mythread222,ref(shared_result))</span></span>;</span><br><span class="line">t4.join();</span><br></pre></td></tr></table></figure></li><li></li></ul><h3 id="3-atomic原子操作"><a href="#3-atomic原子操作" class="headerlink" title="3 atomic原子操作"></a>3 atomic原子操作</h3><ul><li><p>互斥量 多线程编程中，保护共享数据</p></li><li><p>两个线程，对一个变量操作，一个写，一个读</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> atomvalue=<span class="number">5</span>;</span><br><span class="line"><span class="comment">//read</span></span><br><span class="line"><span class="keyword">int</span> tmpvalue=atomvalue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//write</span></span><br><span class="line">atomvalue=<span class="number">6</span>;</span><br></pre></td></tr></table></figure></li><li><p>有可能读到的是 5 6 “之间” 的值</p></li><li><p>加法没有被执行完毕，就被其他线程打断，</p></li><li><p>可通过加锁解决，但是效率慢</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g_mycout=<span class="number">0</span>;</span><br><span class="line">mutex g_mymutex;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">atomic_write</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000000000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//g_mymutex.lock();</span></span><br><span class="line">        g_mycout++;</span><br><span class="line">        <span class="comment">//g_mymutex.unlock();</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="function">thread <span class="title">mytob1</span><span class="params">(atomic_write)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">mytob2</span><span class="params">(atomic_write)</span></span>;</span><br><span class="line">    mytob1.join();</span><br><span class="line">    mytob2.join();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"thread 1 2 over g_mycout: "</span>&lt;&lt;g_mycout&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li><li><p>原子操作，无锁技术不用互斥量，的多线程并发，在多线程中不会被打断的程序执行片段</p></li><li><p>原子操作效率更高</p></li><li><p>互斥量加锁一般针对一个代码段（几行代码），原子操作针对的是一个变量</p></li><li><p>原子操作–不可分割的操作，要么完成，要么没有完成，不可能中间状态</p></li><li><p>std::atomic 一个类模板，用来封装某个类型的值</p></li><li><p>atomic 赋值构造函数删除了！！！！！</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; g_mycout2(<span class="number">0</span>);</span><br><span class="line">atomic&lt;<span class="keyword">int</span>&gt; g_mycout2=<span class="number">0</span>;<span class="comment">/////error!!!!</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">atomic_write2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        g_mycout2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">thread <span class="title">mytob11</span><span class="params">(atomic_write2)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">mytob21</span><span class="params">(atomic_write2)</span></span>;</span><br><span class="line">mytob11.join();</span><br><span class="line">mytob21.join();</span><br></pre></td></tr></table></figure></li><li></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">atomic_bool_read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    chrono::<span class="function">milliseconds <span class="title">dura</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(g_ifend==<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"id "</span>&lt;&lt;this_thread::get_id()&lt;&lt;<span class="string">" is running !"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        this_thread::sleep_for(dura);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"id "</span>&lt;&lt;this_thread::get_id()&lt;&lt;<span class="string">" has exited! "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">thread <span class="title">mytob00</span><span class="params">(atomic_bool_read)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">mytob01</span><span class="params">(atomic_bool_read)</span></span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    this_thread::sleep_for(chrono::milliseconds(<span class="number">5000</span>));</span><br><span class="line">    g_ifend=<span class="literal">true</span>;</span><br><span class="line">    mytob00.join();</span><br><span class="line">    mytob01.join();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"atomic write end!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li><li><p>原子操作一般用于统计，计数</p></li><li><p>atomic作为成员变量时，std::atomic<int> g_mycout2(0)；error？？？？</int></p></li><li><p>作为全局变量时，std::atomic<int> g_mycout2(0) ok</int></p></li></ul><h2 id="11atomic-again，async-again"><a href="#11atomic-again，async-again" class="headerlink" title="11atomic-again，async-again"></a>11atomic-again，async-again</h2><h3 id="1-atomic-again"><a href="#1-atomic-again" class="headerlink" title="1 atomic-again"></a>1 atomic-again</h3><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">atomic&lt;<span class="keyword">int</span>&gt; g_mycount(<span class="number">0</span>);</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">atomic_int_write</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000000</span>;i++)</span><br><span class="line"> &#123;</span><br><span class="line">     g_mycount+=<span class="number">1</span>;</span><br><span class="line">     g_mycount++;</span><br><span class="line">     g_mycount=g_mycount+<span class="number">1</span>;<span class="comment">// error</span></span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(atomic_int_write)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(atomic_int_write)</span></span>;</span><br><span class="line">t1.join();</span><br><span class="line"> t2.join();</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;<span class="string">"g_mycount: "</span>&lt;&lt;g_mycount&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><ul><li></li><li>一般atomic原子操作针对++   –    +=    -=    &amp;=    |=支持，单目运算符。其他可能不支持</li></ul><h3 id="2-async-again"><a href="#2-async-again" class="headerlink" title="2 async-again"></a>2 async-again</h3><ul><li><p>async参数</p><ul><li>launch::defered 延迟调用线程函数到future::wait future::get，且不创建子线程，直接在主线程调用，如果没有调用future::wait future::get，线程入口函数不执行</li><li>launch::async  默认参数，强制创建线程，线程入口函数在新线程中运行</li><li>系统资源紧张时，创建线程失败，执行thread()时，整个程序可能崩溃</li><li>async（）一般不叫创建线程，（尽管也可以创建了线程），叫创建异步任务</li><li>同时 launch::async()  | launch::defered 时 ，创建新线程，async可能 launch::async()  或者 launch::defered，是否创建线程不确定，系统自行决定异步或同步方式运行</li><li><strong>默认参数  launch::async()  | launch::defered</strong> 。</li></ul></li><li><p>async和thread区别</p><ul><li>thread 创建线程，如果系统资源紧张，创建线程失败，崩溃</li><li>thread创建线程的方式，拿到线程返回值，需要全局变量或。。。。</li><li>async 创建异步任务，可创建也可不创建线程，可通过直接返回future对象拿到线程返回值</li><li>系统资源紧张，async 默认参数就会不创建线程以同步方式 在调用get,wait函数的线程 运行线程函数</li><li>可通过参数launch::async强制创建线程</li><li></li></ul></li><li><p>async不确定问题的解决</p><ul><li><p>future<int> result=async(mythread) ,整个异步任务是否有没被推迟执行</int></p></li><li><p>async有没有被创建新线程</p></li><li><p>通过futrue_status status=result.wait_for(0s); <strong>通过future等待0s获得future_status</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">future&lt;<span class="keyword">int</span> &gt;result=async(mythread);</span><br><span class="line">       future_status status=result.wait_for(<span class="number">0</span>s);</span><br><span class="line">       <span class="keyword">if</span>(status==future_status::deferred)<span class="comment">//未创建线程</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">cout</span>&lt;&lt;<span class="string">"deferred"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">           <span class="built_in">cout</span>&lt;&lt;<span class="string">"result.get(): "</span>&lt;&lt;result.get()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(status==future_status::ready)<span class="comment">//线程已经执行完毕</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">cout</span>&lt;&lt;<span class="string">"ready"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">           <span class="built_in">cout</span>&lt;&lt;<span class="string">"result.get(): "</span>&lt;&lt;result.get()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(status==future_status::timeout)<span class="comment">//线程还未执行完毕</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">cout</span>&lt;&lt;<span class="string">"timeout"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">           <span class="built_in">cout</span>&lt;&lt;<span class="string">"result.get(): "</span>&lt;&lt;result.get()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li><li></li><li><table><thead><tr><th>future_status::deferred</th><th>The function to calculate the result has not been started yet</th><th>线程函数延迟执行</th></tr></thead><tbody><tr><td>future_status::ready</td><td>The result is ready</td><td>线程已经执行完毕结果</td></tr><tr><td>future_status::timeout</td><td>The timeout has expired</td><td>线程仍在执行</td></tr></tbody></table></li></ul></li></ul><h2 id="12-windows临界区，其他各种Mutex互斥量"><a href="#12-windows临界区，其他各种Mutex互斥量" class="headerlink" title="12 windows临界区，其他各种Mutex互斥量"></a>12 windows临界区，其他各种Mutex互斥量</h2><h3 id="1-windows-临界区"><a href="#1-windows-临界区" class="headerlink" title="1 windows 临界区"></a>1 windows 临界区</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __WINDOWS__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> other_mutex &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span> &gt; msgRecvQueue;</span><br><span class="line">    mutex mymutex;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  __WINDOWS__</span></span><br><span class="line">    CRITICAL_SECTION mywinsec;<span class="comment">// windows临界区，用之前必须初始化</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __WINDOWS__</span></span><br><span class="line">    InitializeCriticalSection(&amp;mywinsec);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">msgRecvProc</span><span class="params">(<span class="keyword">int</span>&amp; cmd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> res;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __WINDOWS__</span></span><br><span class="line">        EnterCriticalSection(&amp;mywinsec);<span class="comment">//进入临界区 --加锁</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        mymutex.lock();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span>(msgRecvQueue.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            res= <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cmd= msgRecvQueue.front();</span><br><span class="line">            msgRecvQueue.pop_front();</span><br><span class="line">            res= <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __WINDOWS__</span></span><br><span class="line">        LeaveCriticalSection(&amp;mywinsec);<span class="comment">//离开临界区  解锁</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">         mymutex.unlock();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">outMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cmd;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(msgRecvProc(cmd))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"rec a msg cmd: "</span>&lt;&lt;cmd&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"list empty"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __WINDOWS__</span></span><br><span class="line">            EnterCriticalSection(&amp;mywinsec);<span class="comment">//进入临界区 加锁</span></span><br><span class="line">            EnterCriticalSection(&amp;mywinsec);<span class="comment">//可以多次进入</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">           mymutex.lock();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            msgRecvQueue.push_back(i);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __WINDOWS__</span></span><br><span class="line">            LeaveCriticalSection(&amp;mywinsec);<span class="comment">//离开临界区 解锁</span></span><br><span class="line">            LeaveCriticalSection(&amp;mywinsec);<span class="comment">//多次进入，多次离开</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            mymutex.unlock();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"send a msg "</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">other_mutex_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"other_mutex test id "</span>&lt;&lt;this_thread::get_id()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        A a;</span><br><span class="line">        <span class="function">thread <span class="title">read_thread</span><span class="params">(&amp;A::outMsgRecvQueue,&amp;a)</span></span>;</span><br><span class="line">        <span class="function">thread <span class="title">write_thread</span><span class="params">(&amp;A::inMsgRecvQueue,&amp;a)</span></span>;</span><br><span class="line"></span><br><span class="line">        read_thread.join();</span><br><span class="line">        write_thread.join();</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-多次进入临界区试验"><a href="#2-多次进入临界区试验" class="headerlink" title="2 多次进入临界区试验"></a>2 多次进入临界区试验</h3><ul><li>同一个线程中，多次进去同一个临界区变量代表的临界区 可以，不会等待</li><li>但是，几次进去，就要几次离开</li><li>而C++11不允许同一个线程中同一个mutex多次加锁</li></ul><h3 id="3-自动析构技术"><a href="#3-自动析构技术" class="headerlink" title="3 自动析构技术"></a>3 自动析构技术</h3><ul><li>lock_guard<mutex> sbguard<mymutex>; unque_lock<mutex> sbfuard<mymutex>;</mymutex></mutex></mymutex></mutex></li><li>RAII 类 (resource acquisition is initialization) 资源获取即初始化</li><li>类似的有 智能指针，容器</li></ul><h3 id="4-recursive-mutex递归的独占互斥量"><a href="#4-recursive-mutex递归的独占互斥量" class="headerlink" title="4 recursive_mutex递归的独占互斥量"></a>4 recursive_mutex递归的独占互斥量</h3><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可能存在情况</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   lock_guard&lt;mutex&gt; sbguard(mymutex); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     lock_guard&lt;mutex&gt; sbguard(mymutex); </span><br><span class="line">     test1(); <span class="comment">//锁了两次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li></li><li><p>mutex 独占互斥量，只有一个线程可以拿到锁</p></li><li><p>recursive_mutex 递归的独占互斥量 ，允许同一个线程，同一个互斥量，多次lock</p></li><li><p>和mutex 用法相同，recursive_mutex 效率低</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock_guard&lt;recursive_mutex&gt; lg(mymutex);</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-带超时的互斥量-std-timed-mutex-recursive-timed-mutex"><a href="#5-带超时的互斥量-std-timed-mutex-recursive-timed-mutex" class="headerlink" title="5 带超时的互斥量 std::timed_mutex recursive_timed_mutex"></a>5 带超时的互斥量 std::timed_mutex recursive_timed_mutex</h3><ul><li><p>std::timed_mutex 超时的独占互斥量，不会一直阻塞</p><ul><li><p>try_lock_for  参数为时间，等待一段时间，如果拿到锁，或者等待超时时间没拿到锁，就返回</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">chrono::<span class="function">milliseconds <span class="title">timeout</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">           <span class="keyword">if</span>(mymutex.try_lock_for(timeout))</span><br><span class="line">           &#123;<span class="comment">//100ms之内拿到锁</span></span><br><span class="line">               msgRecvQueue.push_back(i);</span><br><span class="line">               mymutex.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="comment">//100ms 没有拿到锁</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="built_in">cout</span>&lt;&lt;<span class="string">" has not obtain lock!!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">               chrono::<span class="function">milliseconds <span class="title">sleep</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">               this_thread::sleep_for(sleep);</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure></li><li></li><li><p>try_lock_until 参数为未来的一个时间点，未来的时间没到的时间段内，如果拿到锁，流程就走下来，如果时间到，没有拿到锁，流程也走下来</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">chrono::<span class="function">milliseconds <span class="title">timeout</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">          <span class="comment">//if(mymutex.try_lock_for(timeout))</span></span><br><span class="line">          <span class="keyword">if</span>(mymutex.try_lock_until(chrono::steady_clock::now()+timeout))</span><br><span class="line">          &#123;<span class="comment">//100ms之内拿到锁</span></span><br><span class="line">              msgRecvQueue.push_back(i);</span><br><span class="line">               <span class="built_in">cout</span>&lt;&lt;<span class="string">"send a msg "</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">             mymutex.unlock();</span><br><span class="line">  </span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="comment">//100ms 没有拿到锁</span></span><br><span class="line">          &#123;</span><br><span class="line">              <span class="built_in">cout</span>&lt;&lt;<span class="string">" has not obtain lock!!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">              chrono::<span class="function">milliseconds <span class="title">sleep</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">              this_thread::sleep_for(sleep);</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li></ul></li><li><p>recursive_timed_mutex 带超时功能的递归独占互斥量（允许同一个线程多次获取同一个互斥量）</p></li></ul><h2 id="13-补充，线程池、线程数量、总结"><a href="#13-补充，线程池、线程数量、总结" class="headerlink" title="13 补充，线程池、线程数量、总结"></a>13 补充，线程池、线程数量、总结</h2><h3 id="1-补充"><a href="#1-补充" class="headerlink" title="1 补充"></a>1 补充</h3><ul><li><p>condition_variable::wait</p><ul><li>如果pred为真，直接返回</li><li>如果pred为假，解锁互斥量，并阻塞到本行，一直到其他某个线程norify_One()成员函数</li><li>没有Pred，和Pred为假相同</li><li>如果唤醒，<ul><li>尝试获得锁，失败则阻塞</li><li>如果获得锁成功，但是Pred 为假，则解锁，等待被再次唤醒</li><li>没有第二个参数，直接返回</li></ul></li><li>wait执行完毕，一定是 加锁+被唤醒</li></ul></li><li><p>虚假唤醒</p><ul><li>存在队列中没有数据，被唤醒  —–唤醒但是Pred为假</li><li>当多个notify_one迭代一起时</li><li>所以要用第二个参数Pred，再次确认，唤醒后，能否执行一系列动作</li><li>wait中第二个参数Pred，判断公共数据是否存在</li></ul></li><li><p>atomic</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读atm是个原子操作，但是整个一行代码不是原子操作</span></span><br><span class="line"><span class="comment">//atm的值可能是之前的值</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;atm&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//</span></span><br></pre></td></tr></table></figure></li><li><p>原子操作不能赋值</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以原子方式读atm值</span></span><br><span class="line">atmoic&lt;<span class="keyword">int</span>&gt; atm2(atm.load());</span><br><span class="line"><span class="comment">//原子操作写值</span></span><br><span class="line">atm2.store(<span class="number">12</span>);</span><br></pre></td></tr></table></figure></li><li></li></ul></li></ul><h3 id="2-线程池"><a href="#2-线程池" class="headerlink" title="2 线程池"></a>2 线程池</h3><ul><li>场景<ul><li>每来一个客户端，就创建一个线程为该客户端提供服务</li><li>客户端过多时？？？？？？</li><li>程序偶尔创建一个线程，稳定性不高</li><li>统一调度一堆线程，统一管理，循环利用</li></ul></li><li>实现方式<ul><li>程序启动时，一次性创建好一定数量的线程</li><li></li></ul></li></ul><h3 id="3-线程数量"><a href="#3-线程数量" class="headerlink" title="3 线程数量"></a>3 线程数量</h3><ul><li>数量极限问题，2000个？？？</li><li>开放商的建议</li><li>创建多个线程完成业务，一个线程一条通路，100个要充值，创建110个线程</li></ul><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h3><ul><li>C++多线程 真的 变态。。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Concurrency </tag>
            
            <tag> C++11 </tag>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11 新特性</title>
      <link href="/2018/12/17/C-11-note/"/>
      <url>/2018/12/17/C-11-note/</url>
      
        <content type="html"><![CDATA[<ul><li>C++11的新特性</li></ul><a id="more"></a><h1 id="C-2-0新特性"><a href="#C-2-0新特性" class="headerlink" title="C++ 2.0新特性"></a>C++ 2.0新特性</h1><ul><li>语言+标准库</li></ul><h2 id="1-演进、环境与资源"><a href="#1-演进、环境与资源" class="headerlink" title="1.演进、环境与资源"></a>1.演进、环境与资源</h2><ul><li>Variadic template</li><li>move semantics</li><li>auto</li><li>ininializer list</li><li>lambdas</li><li>type_traits</li><li>forward_list</li><li>array</li><li>tuple</li></ul><h2 id="2-Variadic-Templates"><a href="#2-Variadic-Templates" class="headerlink" title="2.Variadic Templates"></a>2.Variadic Templates</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printx</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printx</span><span class="params">(<span class="keyword">const</span> T&amp; first,<span class="keyword">const</span> Types&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;first&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    printx(args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">sizeof</span>...(args) <span class="comment">//元素个数</span></span><br></pre></td></tr></table></figure><ul><li>sizeof…(args) //元素个数</li></ul><p><img src="http://image.blissseven.top/18-12-17/99522903.jpg" alt></p><p><img src="http://image.blissseven.top/18-12-17/95979155.jpg" alt></p><h2 id="3-space-in-Template-Expression-nullptr-std–nullptr-t-auto"><a href="#3-space-in-Template-Expression-nullptr-std–nullptr-t-auto" class="headerlink" title="3. space in Template Expression,nullptr,std–nullptr_t,auto"></a>3. space in Template Expression,nullptr,std–nullptr_t,auto</h2><ul><li>vector&lt;list<int> &gt;  —–&gt;   vector&lt;list<int>&gt;</int></int></li><li>typedef decltype(nullptr)  nullptr_t;</li><li><strong>自动类型推断只能用于单值初始化，不能用于初始化列表</strong></li><li>统一初始化,变量名后加大括号<ul><li>int values[]{1,2,3};</li><li>vector<int> v{2,3,4};</int></li></ul></li></ul><p><img src="http://image.blissseven.top/18-12-17/59957138.jpg" alt></p><ul><li>所有容器都有initializer_list 为参数的构造函数</li><li>complex 类没有Initializer_list为参数的构造函数，因此initializer_list逐个分解</li></ul><h2 id="4-initializer-list"><a href="#4-initializer-list" class="headerlink" title="4. initializer_list"></a>4. initializer_list</h2><ul><li>int i;</li><li>int j{};   //j=0</li><li>int *p;</li><li>int* q{};  q=nullptr;</li><li>不允许缩窄变换<ul><li>int x3{5.0}; // error</li></ul></li><li>initializer_list元素类型一致</li></ul><p><img src="http://image.blissseven.top/18-12-17/81350278.jpg" alt></p><ul><li>编译器看到{}，准备array,调用initializer_list的 private的构造函数</li><li>initializer_list 没有内涵array,,copy initializer_list时，另一个Initializer_List中array只是array浅拷贝</li></ul><p><img src="http://image.blissseven.top/18-12-17/18608235.jpg" alt></p><p><img src="http://image.blissseven.top/18-12-17/44712992.jpg" alt></p><h2 id="5-explicit-for-ctors-taking-more-than-one-argument"><a href="#5-explicit-for-ctors-taking-more-than-one-argument" class="headerlink" title="5.explicit for ctors taking more than one argument"></a>5.explicit for ctors taking more than one argument</h2><ul><li>explicit for ctors taking one argument<ul><li><img src="http://image.blissseven.top/18-12-17/93471630.jpg" alt></li><li>禁止隐式自动类型转换</li></ul></li><li>多个参数也可以禁止自动类型转换</li></ul><p>​     <img src="http://image.blissseven.top/18-12-18/42559007.jpg" alt></p><h2 id="6-range-based-for-statement"><a href="#6-range-based-for-statement" class="headerlink" title="6 range-based for statement"></a>6 range-based for statement</h2><ul><li><p><img src="http://image.blissseven.top/18-12-18/26520176.jpg" alt></p></li><li><p>编译器对其解释</p><p><img src="http://image.blissseven.top/18-12-18/9063914.jpg" alt></p></li><li><p>对于有for loop 中类型不一样就要做转换，有explict则转换失败。</p><p><img src="http://image.blissseven.top/18-12-18/92432434.jpg" alt></p></li></ul><h2 id="7-default-delete"><a href="#7-default-delete" class="headerlink" title="7 =default =delete"></a>7 =default =delete</h2><ul><li>默认构造函数 在其继承自父类时，调用父类的构造函数</li><li>多用在big five上</li></ul><p>​       <img src="http://image.blissseven.top/18-12-18/64877977.jpg" alt></p><p>​    <img src="http://image.blissseven.top/18-12-18/96378552.jpg" alt>                         </p><p>​       <img src="http://image.blissseven.top/18-12-18/86000089.jpg" alt>         </p><ul><li><p>一个类只要有指针成员，需要写拷贝构造，拷贝复制 BIG_THREE</p><p> <img src="http://image.blissseven.top/18-12-18/23496788.jpg" alt></p></li></ul><p><img src="http://image.blissseven.top/18-12-18/83177817.jpg" alt></p><h2 id="8-Alias-Template-（template-typedef）"><a href="#8-Alias-Template-（template-typedef）" class="headerlink" title="8 Alias Template （template typedef）"></a>8 Alias Template （template typedef）</h2><ul><li>alias template 无法特化，全特化，偏特化</li></ul><p><img src="http://image.blissseven.top/18-12-18/27737713.jpg" alt></p><p><img src="http://image.blissseven.top/18-12-18/67430854.jpg" alt></p><p><img src="http://image.blissseven.top/18-12-18/4696917.jpg" alt></p><ul><li>容器-&gt;迭代器-&gt;经过萃取机-&gt;value_type</li></ul><p><img src="http://image.blissseven.top/18-12-18/33145663.jpg" alt></p><h2 id="9-template-template-parameter"><a href="#9-template-template-parameter" class="headerlink" title="9 template template parameter"></a>9 template template parameter</h2><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>&gt; <span class="title">class</span> <span class="title">Container</span>&gt;</span></span><br><span class="line"><span class="class">  //<span class="title">Container</span> 是一个模板，且这个模板以<span class="title">T</span>为参数。</span></span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li><li><p>vector 模板有两个参数。</p></li></ul><p><img src="http://image.blissseven.top/18-12-18/70884867.jpg" alt></p><p><img src="http://image.blissseven.top/18-12-18/82586264.jpg" alt></p><h2 id="10-Type-Alias-noexcept-override-final"><a href="#10-Type-Alias-noexcept-override-final" class="headerlink" title="10 Type Alias,noexcept,override,final"></a>10 Type Alias,noexcept,override,final</h2><ul><li><p>func 一个函数指针 typedef void(*func)(int,int);</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">CharT</span>&gt; <span class="title">using</span> <span class="title">mystring</span>=<span class="title">std</span>:</span>:basic_string&lt;CharT,<span class="built_in">std</span>::char_traits&lt;CharT&gt;&gt;;</span><br><span class="line"><span class="comment">//两个一致</span></span><br><span class="line"><span class="keyword">using</span> mystring= <span class="keyword">template</span> &lt;class CharT&gt; <span class="built_in">std</span>::basic_string&lt;CharT,<span class="built_in">std</span>::char_traits&lt;CharT&gt;&gt;;</span><br></pre></td></tr></table></figure></li><li><p><img src="http://image.blissseven.top/18-12-18/84101100.jpg" alt></p></li><li><p>using 使用总结：<img src="http://image.blissseven.top/18-12-18/38841947.jpg" alt></p></li><li><p>nonexcept</p><ul><li>保证该函数不会丢出异常， 在（）内的条件为真的情况下。</li><li>异常最终默认处理程序std::terminate</li><li><img src="http://image.blissseven.top/18-12-18/15130395.jpg" alt></li><li><img src="http://image.blissseven.top/18-12-18/85035912.jpg" alt></li></ul></li><li><p>override</p><ul><li>子类重载父类函数，帮助编译器，这个函数是override版本</li><li><img src="http://image.blissseven.top/18-12-18/21514718.jpg" alt></li></ul></li><li><p>final</p><ul><li>修饰class，final 禁止子类继承</li><li>修饰virtual function，虚函数不可以被override。</li></ul></li></ul><h2 id="11-decltype"><a href="#11-decltype" class="headerlink" title="11 decltype"></a>11 decltype</h2><p><img src="http://image.blissseven.top/18-12-18/58558981.jpg" alt></p><p><img src="http://image.blissseven.top/18-12-18/80036854.jpg" alt></p><ul><li><p>声明返回类型</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span><br><span class="line">  <span class="keyword">decltype</span>(x+y) add(T1 x,T2 y);</span><br><span class="line">  <span class="comment">//auto add(T1 x,T2 y) -&gt;decltype(x+y)</span></span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li><li><p><img src="http://image.blissseven.top/18-12-18/874430.jpg" alt></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li></ul></li><li><p>metaprogramming 元编程</p><ul><li>typename 帮助编译器确定是一个数据类型</li><li><img src="http://image.blissseven.top/18-12-18/93156572.jpg" alt></li></ul></li><li><p>传递到一个lamdba 表达式</p><ul><li><img src="http://image.blissseven.top/18-12-18/95476411.jpg" alt></li></ul></li></ul><h2 id="12-lambda"><a href="#12-lambda" class="headerlink" title="12 lambda"></a>12 lambda</h2><ul><li><p><img src="http://image.blissseven.top/18-12-18/61788914.jpg" alt></p></li><li></li><li><p>lambda 属于 inline 函数</p></li><li><p>在lambda后加小括号，直接调用</p></li><li><p><img src="http://image.blissseven.top/18-12-18/28514407.jpg" alt></p></li><li><p>[=,&amp;y] 允许通过值传递使用所有的object</p></li><li><p>mutable throwSpec -&gt;retTyppe 可选，但是只要有一个，就要写小括号</p></li><li><p>[]内 lambda中要用到的外部的数据</p></li><li><p><img src="http://image.blissseven.top/18-12-18/10089767.jpg" alt></p></li><li><p>没有mutable  id不能++</p></li><li><p>说明lambda []内参数类型为const </p></li><li><p><img src="http://image.blissseven.top/18-12-18/72755879.jpg" alt></p></li><li><p>lambda 没有默认构造函数，没有赋值运算符</p></li><li><p>对排序准则来讲，一个仿函数，要比lambda更直观一点</p></li><li><p><img src="http://image.blissseven.top/18-12-18/35227147.jpg" alt></p></li><li><p>functor 不是inline函数</p></li><li><p><img src="http://image.blissseven.top/18-12-18/47759986.jpg" alt></p></li></ul><h2 id="13-variadic-template"><a href="#13-variadic-template" class="headerlink" title="13 variadic template"></a>13 variadic template</h2><p><img src="http://image.blissseven.top/18-12-18/28788629.jpg" alt></p><ul><li><p>sizeof…(args) 获得参数个数</p></li><li><p>example1</p><ul><li><img src="http://image.blissseven.top/18-12-18/75845034.jpg" alt></li></ul></li><li><p>example2</p><ul><li><img src="http://image.blissseven.top/18-12-18/25708406.jpg" alt></li></ul></li><li><p>example3</p><ul><li>同一个类型 比大小 用initializer_list</li><li>_iter_less_iter为一个函数</li><li><img src="http://image.blissseven.top/18-12-18/84919365.jpg" alt></li><li></li></ul></li><li><p>example4</p><ul><li><img src="http://image.blissseven.top/18-12-19/88675160.jpg" alt></li><li></li></ul></li><li><p>example5</p><ul><li>采用类模板，对头和尾的操作方式不同</li><li>第2步，递归停止时！！！</li><li><img src="http://image.blissseven.top/18-12-19/15323510.jpg" alt></li><li></li></ul></li><li><p>example6</p><ul><li><p>奇葩的继承</p></li><li><p>private继承</p></li><li><p>protect成员</p></li><li><p>initializer_list中inherited(vtail…)调用基类的构造函数</p></li><li><p>Head::type 不能获得数据类型</p></li><li><p>auto decltype</p></li><li><p><img src="http://image.blissseven.top/18-12-19/42719432.jpg" alt></p></li><li><p><img src="http://image.blissseven.top/18-12-19/52539449.jpg" alt></p></li><li><p><img src="http://image.blissseven.top/18-12-19/43478859.jpg" alt></p></li></ul></li><li><p>example7</p><ul><li>composited&amp; tail() 返回 引用</li><li>否则，可以读，不可以写</li><li><img src="http://image.blissseven.top/18-12-19/66701973.jpg" alt></li><li></li></ul></li></ul><h2 id="1-标准库源代码分布"><a href="#1-标准库源代码分布" class="headerlink" title="1.标准库源代码分布"></a>1.标准库源代码分布</h2><ul><li>VC++<ul><li>\include</li><li>\cliext</li></ul></li><li>GNUC C++<ul><li>\include</li><li>\include\c++</li><li>\include\c++\bits</li><li>\include\c++\ext</li></ul></li></ul><h2 id="2-Rvalue-reference"><a href="#2-Rvalue-reference" class="headerlink" title="2.Rvalue reference"></a>2.Rvalue reference</h2><ul><li>当复制的右手边是一个右值，左边可以偷右手边的东西</li><li>左值 变量，可以出现在op=左边</li><li>右值 变量，只能出现在op=右边，临时对象</li><li><img src="http://image.blissseven.top/18-12-19/18141607.jpg" alt></li><li>函数返回的是右值，不能取地址</li><li><img src="http://image.blissseven.top/18-12-19/9432650.jpg" alt></li><li>insert 调用move ctor，拷贝构造函数，</li><li>noexcept确保不会发生异常</li><li>被move之后，原来的指针就不能用了。</li><li>临时对象，编译器自动调用move版本</li><li>用std::move(c1)，强制调用move版本，相当于拿到了c1的Rvalue reference</li><li>调用Move条件<ul><li>inset 有move版本</li><li>Mystring move constructor，且noexcept</li><li>临时对象/或者move(c1) </li><li><img src="http://image.blissseven.top/18-12-19/1725090.jpg" alt></li><li></li></ul></li></ul><h2 id="3-Perfect-Forwarding"><a href="#3-Perfect-Forwarding" class="headerlink" title="3.Perfect Forwarding"></a>3.Perfect Forwarding</h2><ul><li>MyString move ctor 需要自己写</li><li><img src="http://image.blissseven.top/18-12-19/13532597.jpg" alt></li><li></li><li><img src="http://image.blissseven.top/18-12-19/39768130.jpg" alt></li><li>forward 中间站怎么设计？？？</li><li><img src="http://image.blissseven.top/18-12-19/48820499.jpg" alt></li><li>借forward达到完美的转接</li><li><img src="http://image.blissseven.top/18-12-19/21598130.jpg" alt></li></ul><h2 id="4-move-aware-class"><a href="#4-move-aware-class" class="headerlink" title="4.move-aware class"></a>4.move-aware class</h2><ul><li><p>str.data=NULL 不应delete str.data,应该交给str的析构函数</p></li><li><p>str.data=NLL没有这句话时，析构函数调用，将delete指针所指的内容</p></li><li><p>析构函数判断是否是NULL</p></li><li><p><img src="http://image.blissseven.top/18-12-19/57034216.jpg" alt></p></li><li><p>关联式容器，检测元素大小，需要写operator&lt; operator==</p></li><li><p><img src="http://image.blissseven.top/18-12-19/71051750.jpg" alt></p></li></ul><h2 id="4-对容器的效能测试"><a href="#4-对容器的效能测试" class="headerlink" title="4.对容器的效能测试"></a>4.对容器的效能测试</h2><ul><li><p><img src="http://image.blissseven.top/18-12-19/65888629.jpg" alt></p></li><li><p>由于vector会成长，所以调用Mctor次数7194303</p></li><li></li><li><p><img src="http://image.blissseven.top/18-12-19/31107713.jpg" alt></p></li><li><p>vector copy consructor 需要一个一个copy数据</p></li><li><p><img src="http://image.blissseven.top/18-12-19/41901434.jpg" alt></p></li><li><p><img src="http://image.blissseven.top/18-12-19/76335039.jpg" alt></p></li><li></li><li></li><li><p><img src="http://image.blissseven.top/18-12-19/17909963.jpg" alt></p></li><li><p>300000 放在尾巴，所有不会有扩充操作</p></li><li><p><img src="http://image.blissseven.top/18-12-19/54372120.jpg" alt></p></li><li></li><li><p><img src="http://image.blissseven.top/18-12-19/55930927.jpg" alt></p></li></ul><ul><li>move版本对于vector 影响最大，其次deque</li><li>只要容器以节点形式存在，Move版本影响不大</li></ul><h2 id="5-容器结构与分类"><a href="#5-容器结构与分类" class="headerlink" title="5.容器结构与分类"></a>5.容器结构与分类</h2><ul><li><img src="http://image.blissseven.top/18-12-19/22929065.jpg" alt></li><li><img src="http://image.blissseven.top/18-12-19/91125939.jpg" alt></li><li></li></ul><h2 id="6-array"><a href="#6-array" class="headerlink" title="6.array"></a>6.array</h2><ul><li><img src="http://image.blissseven.top/18-12-19/82153303.jpg" alt></li><li>数组声明时 in a[100]；</li><li>以下typedef int T[100];</li><li>T c;</li><li><img src="http://image.blissseven.top/18-12-20/15402265.jpg" alt></li><li></li></ul><h2 id="7-hashtable"><a href="#7-hashtable" class="headerlink" title="7.hashtable"></a>7.hashtable</h2><ul><li>bucket实现vector，可以增长，每个bucket是一个list</li><li>元素个数&gt;bucket个数，则rehashing，之后，元素位置重新计算</li><li>108 为元素的hashcode</li><li><img src="http://image.blissseven.top/18-12-20/25414608.jpg" alt></li></ul><h2 id="8-hashfunction"><a href="#8-hashfunction" class="headerlink" title="8.hashfunction"></a>8.hashfunction</h2><ul><li>hash<int>() 函数对象functor</int></li><li><img src="http://image.blissseven.top/18-12-20/87212468.jpg" alt></li></ul><ul><li><p><img src="http://image.blissseven.top/18-12-20/40999277.jpg" alt></p></li><li></li><li><p><img src="http://image.blissseven.top/18-12-20/67668885.jpg" alt></p></li><li></li><li><p><img src="http://image.blissseven.top/18-12-20/82424866.jpg" alt></p></li><li></li><li><p><img src="http://image.blissseven.top/18-12-20/51472569.jpg" alt></p></li><li><p><img src="http://image.blissseven.top/18-12-20/93896354.jpg" alt></p></li><li></li><li><p><img src="http://image.blissseven.top/18-12-20/47067778.jpg" alt></p></li><li></li><li><p><img src="http://image.blissseven.top/18-12-20/57867032.jpg" alt></p></li><li><p><img src="http://image.blissseven.top/18-12-20/44361296.jpg" alt></p></li><li></li></ul><h2 id="9-tuple"><a href="#9-tuple" class="headerlink" title="9.tuple"></a>9.tuple</h2><ul><li><p>meta programming</p></li><li><p>对类型做操作</p></li><li><p><img src="http://image.blissseven.top/18-12-20/17798566.jpg" alt></p></li><li></li><li></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Design Pattern</title>
      <link href="/2018/11/10/design-pattern-note/"/>
      <url>/2018/11/10/design-pattern-note/</url>
      
        <content type="html"><![CDATA[<ul><li>36个设计模式</li></ul><a id="more"></a><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h2><ul><li>松耦合设计</li><li>面向对象设计原则</li><li>重构技法</li><li>GOF核心设计</li></ul><p>《设计模式-<strong>可复用</strong>   <strong>面向对象</strong>  软件的基础》</p><p><img src="http://image.blissseven.top/blog/181110/dH7ld6GFAL.png?imageslim" alt="mark"></p><p><img src="http://image.blissseven.top/blog/181110/L24L57ilm1.png?imageslim" alt="mark"></p><p>软件设计复杂的根本原因：</p><ul><li>客户需求变化</li><li>技术平台变化</li><li>开发团队变化</li><li>市场环境变化</li></ul><p>解决复杂性：</p><ul><li>分而治之<ul><li>shape: 2 个shape</li><li>MainForm: shape1 shape2</li></ul></li><li>抽象<ul><li>shape: 2个shape 继承父类shape ,实现各自paint</li><li></li></ul></li></ul><p>尽可能一个class一个文件。</p><p><strong>软件设计的目标：</strong></p><p>​            <strong>复用</strong></p><h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><p>原则大于模式</p><p><img src="http://image.blissseven.top/blog/181112/1kF9424k75.png?" alt="mark"></p><ul><li><p>依赖倒置原则DIP</p><ul><li>从而隔离变化</li><li>高层模块(稳定)不应该依赖于底层模块(变化)，二者都应该依赖与抽象（稳定）。</li><li>抽象(稳定) 不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）</li></ul></li><li><p>开放封闭原则OCP</p><ul><li>对扩展开放，对更改封闭</li><li>类模块应该是可以扩展的，但是不可以修改</li></ul></li><li><p>单一职责原则SRP</p><ul><li>一个类应该仅有一个引起它变化的原因</li><li>变化的方向隐含着类的责任</li></ul></li><li><p>Liskov 替换原则LSP</p><ul><li>子类必须能够替换他们的基类IS-A</li><li>继承表达类型抽象</li></ul></li><li><p>接口隔离原则ISP</p><ul><li>不应该强波客户程序依赖它们不用的方法</li><li>接口应该小而完备</li></ul></li><li><p>优先使用对象组合，而不是类继承</p><ul><li>类继承通常为白箱复用，对象组合通常为黑箱复用</li><li>继承在某种程度上破坏了封装性，子类父类耦合度高</li><li>而对象组合只要求被组合的对象具有良好定义的接口，耦合度低</li></ul></li><li><p>封装变化点</p><ul><li>使用封装来创建对象之间的分界层，让设计者可以在分界一层进行修改，而不会对另一侧产生不良影响，实现层次间的松耦合</li></ul></li><li><p>针对接口编程，而不是针对实现编程</p><ul><li>不将变量类型声明为某个特定的具体类，而是声明为某个接口</li><li>客户程序无需知道对象的具体类型，只需要知道对象所具有的接口</li><li>减少系统中各部分的依赖关系，从而实现高内聚，松耦合的设计方案</li><li><strong>接口标准化</strong></li></ul></li><li><p>将设计原则提升为设计经验</p><ul><li>设计习语<ul><li>effective c++ // more effective c++ // exceptional c++</li></ul></li><li>设计模式</li><li>架构模式</li></ul></li></ul><h2 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><p>GOF-23 模式分类</p><ul><li>从目的来看：<ul><li>创建型（Creational）模式：将对象的部分创建工作延迟到子<br>类或者其他对象，从而应对需求变化为对象创建时具体类型实<br>现引来的冲击。</li><li>结构型（Structural）模式：通过类继承或者对象组合获得更灵<br> 活的结构，从而应对需求变化为对象的结构带来的冲击。</li><li>行为型（Behavioral）模式：通过类继承或者对象组合来划分<br>类与对象间的职责，从而应对需求变化为多个交互的对象带来<br>的冲击。</li></ul></li><li>从范围来看：<ul><li>类模式处理类与子类的静态关系。</li><li>对象模式处理对象间的动态关系 </li></ul></li></ul><p><img src="http://image.blissseven.top/18-11-12/52595199.jpg" alt></p><ul><li>在变化点应用模式</li><li>重构到模式，一步一步修改，最后到模式</li></ul><p><img src="http://image.blissseven.top/18-11-12/64418675.jpg" alt></p><p>重构关键技法：</p><ul><li>静态-&gt;动态</li><li>早绑定-&gt;晚绑定</li><li>继承-&gt;组合</li><li>编译时依赖-&gt;运行时依赖</li><li>紧耦合-&gt;松耦合</li></ul><p>组建协作模式：</p><ul><li>现代软件专业分工之后的第一个结果是“<strong><em>框架</em>与<em>应用程序</em>的划</strong><br><strong>分</strong>”，“组件协作”模式通过<strong>晚期绑定</strong>，来实现框架与应用程序之<br>间的松耦合，是二者之间协作时常用的模式 </li><li>典型模式<ul><li>template method</li><li>strategy</li><li>Ovserver/event</li></ul></li></ul><p>template method 模式</p><ul><li><p>动机</p><ul><li>任务，有<strong>稳定</strong>的整体操作结构，各个子步骤有很多<strong>改变</strong>的需求，由于固有的原因<br>（比如框架与应用之间的关系）而无法和任务的整体结构同时实现 </li><li>在<strong>稳定</strong>操作结构的前提下，灵活应对各个子步骤的<strong>变化</strong>，或者晚期实现需求</li></ul></li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序库开发人员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Library</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Step1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Step3</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Step5</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//应用程序开发人员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Step2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Step4</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Library <span class="title">lib</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Application <span class="title">app</span><span class="params">()</span></span>;</span><br><span class="line">lib.Step1();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (app.Step2())&#123;</span><br><span class="line">lib.Step3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">app.Step4();</span><br><span class="line">&#125;</span><br><span class="line">lib.Step5();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <img src="http://image.blissseven.top/18-11-12/44906616.jpg" alt></p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个基类的析构函数是虚的</span></span><br><span class="line"><span class="comment">//程序库开发人员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Library</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//稳定 template method</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span>&#123;        </span><br><span class="line">        Step1();</span><br><span class="line">        <span class="keyword">if</span> (Step2()) &#123; <span class="comment">//支持变化 ==&gt; 虚函数的多态调用</span></span><br><span class="line">            Step3(); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            Step4(); <span class="comment">//支持变化 ==&gt; 虚函数的多态调用</span></span><br><span class="line">        &#125;</span><br><span class="line">        Step5();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">virtual</span> ~Library()&#123; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Step1</span><span class="params">()</span> </span>&#123; <span class="comment">//稳定</span></span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Step3</span><span class="params">()</span> </span>&#123;<span class="comment">//稳定</span></span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Step5</span><span class="params">()</span> </span>&#123; <span class="comment">//稳定</span></span><br><span class="line"><span class="comment">//.....</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Step2</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//变化</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Step4</span><span class="params">()</span> </span>=<span class="number">0</span>; <span class="comment">//变化</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*******Application***************////</span></span><br><span class="line"><span class="comment">//应用程序开发人员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> :</span> <span class="keyword">public</span> Library &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Step2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//... 子类重写实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Step4</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//... 子类重写实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Library* pLib=<span class="keyword">new</span> Application();</span><br><span class="line">    lib-&gt;Run();</span><br><span class="line"><span class="keyword">delete</span> pLib;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <img src="http://image.blissseven.top/18-11-12/95621225.jpg" alt></p><ul><li><p>早绑定，晚开发的Application 绑定早开发的Libary</p></li><li><p>晚绑定，早开发的Libary绑定晚开发的Application</p><p><img src="http://image.blissseven.top/18-11-12/73202089.jpg" alt></p></li></ul><p>模式定义：</p><ul><li>一个<strong>操作中的算法的骨架</strong>（稳定），将一些步骤延迟（变化）到子类中，template method 使得子类可以不改变（复用）一个算法的结构即可重定义（overried）该算法的某些特定步骤</li><li>定义一个虚函数，子类重写，支持子类变化</li><li>稳定run中有变化 step2,step3。</li><li>当run不稳定时，不能用template method</li><li>设计模式前提，有一个稳定点、</li><li>libary 角度来看</li></ul><p><strong>区分类图中的稳定和变化</strong></p><p><img src="http://image.blissseven.top/18-11-12/48065018.jpg" alt></p><p>总结：</p><ul><li>template method 基础，用最简洁的机制（虚函数的多态性）为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构。 </li><li>除了可以灵活应对子步骤的变化外，“不要调用我，让我来调用你 （libary 角度来看）”的反向控制结构时template method的典型应用</li><li>在具体实现方面，被template method 调用的虚方法可以具有实现，也可以没有任何实现（抽象方法、纯虚方法），但一般推荐将它们设置为protected方法 </li></ul><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p><img src="http://image.blissseven.top/blog/181112/lgl07jiJAi.png?imageslim" alt="mark"></p><ul><li>加一个时间轴看问题，考虑未来变化</li><li>违反开放封闭原则，对扩展开发，对更改封闭，类模块应该是可以扩展的，但是不可以修改</li><li>粘贴源代码，不叫复用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> TaxBase &#123;</span><br><span class="line">CN_Tax,</span><br><span class="line">US_Tax,</span><br><span class="line">DE_Tax,</span><br><span class="line">FR_Tax       <span class="comment">//更改</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalesOrder</span>&#123;</span></span><br><span class="line">    TaxBase tax;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">CalculateTax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...        </span></span><br><span class="line">        <span class="keyword">if</span> (tax == CN_Tax)&#123;</span><br><span class="line">            <span class="comment">//CN***********</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tax == US_Tax)&#123;</span><br><span class="line">            <span class="comment">//US***********</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tax == DE_Tax)&#123;</span><br><span class="line">            <span class="comment">//DE***********</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tax == FR_Tax)&#123;  <span class="comment">//更改</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">     &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个class 一个文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaxStrategy</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">const</span> Context&amp; context)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~TaxStrategy()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNTax</span> :</span> <span class="keyword">public</span> TaxStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">const</span> Context&amp; context)</span></span>&#123;</span><br><span class="line">        <span class="comment">//***********</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">USTax</span> :</span> <span class="keyword">public</span> TaxStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">const</span> Context&amp; context)</span></span>&#123;</span><br><span class="line">        <span class="comment">//***********</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DETax</span> :</span> <span class="keyword">public</span> TaxStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">const</span> Context&amp; context)</span></span>&#123;</span><br><span class="line">        <span class="comment">//***********</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//扩展</span></span><br><span class="line"><span class="comment">//********************************************************///////</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FRTax</span> :</span> <span class="keyword">public</span> TaxStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">const</span> Context&amp; context)</span></span>&#123;</span><br><span class="line"><span class="comment">//.........</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalesOrder</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TaxStrategy* strategy;<span class="comment">///一个指针，不能对象，多态性，指针可以指向不同的子类//引用也支持多态，不常用</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SalesOrder(StrategyFactory* strategyFactory)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;strategy = strategyFactory-&gt;NewStrategy();</span><br><span class="line">    &#125;</span><br><span class="line">    ~SalesOrder()&#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">CalculateTax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="function">Context <span class="title">context</span><span class="params">()</span></span>;    </span><br><span class="line">        <span class="keyword">double</span> val = </span><br><span class="line">            strategy-&gt;Calculate(context); <span class="comment">//多态调用</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模式定义：</p><p>定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化），该模式使得算法（DETax，CNTax）可独立于使用它的客户程序（SalesOrder）（稳定）而变化（扩展，子类化）。</p><p><img src="http://image.blissseven.top/blog/181112/m38IhmE567.png?imageslim" alt="mark"></p><p>总结：</p><ul><li>Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便的根据需要在各个算法之间切换</li><li>strtegy提供了用条件判断语句以外的另一种选择，消除条件判断语句就是在解耦合。含有许多条件判断语句的代码通常都需要strategy模式，除if_else绝对不变。</li><li>如果strategy对象没有实例变量，那么各个上下文可以共享一个strategy对象，节省对象开销</li></ul><h2 id="Observer观察者模式"><a href="#Observer观察者模式" class="headerlink" title="Observer观察者模式"></a>Observer观察者模式</h2><p>动机：</p><ul><li>为某些对象建立一种“通知依赖关系” ——一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密，将使软件不能很好地抵御变化 </li><li>使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合 </li></ul><p>依赖倒置原则：</p><ul><li>高层模块(稳定)不应该依赖于底层模块(变化)，二者都应该依赖与抽象（稳定）。</li><li>抽象(稳定) 不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSplitter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="built_in">string</span> m_filePath;</span><br><span class="line"><span class="keyword">int</span> m_fileNumber;</span><br><span class="line">ProgressBar* m_progressBar;<span class="comment">/// add 抽象依赖于实现细节</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">FileSplitter(<span class="keyword">const</span> <span class="built_in">string</span>&amp; filePath, <span class="keyword">int</span> fileNumber, ProgressBar* progressBar) :</span><br><span class="line">m_filePath(filePath), </span><br><span class="line">m_fileNumber(fileNumber),</span><br><span class="line">m_progressBar(progressBar)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//1.读取大文件</span></span><br><span class="line"><span class="comment">//2.分批次向小文件中写入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_fileNumber; i++)&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">float</span> progressValue = m_fileNumber;</span><br><span class="line">progressValue = (i + <span class="number">1</span>) / progressValue;<span class="comment">//add update bar</span></span><br><span class="line">m_progressBar-&gt;setValue(progressValue);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainForm</span> :</span> <span class="keyword">public</span> Form</span><br><span class="line">&#123;</span><br><span class="line">TextBox* txtFilePath;</span><br><span class="line">TextBox* txtFileNumber;</span><br><span class="line">ProgressBar* progressBar;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Button1_Click</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> filePath = txtFilePath-&gt;getText();</span><br><span class="line"><span class="keyword">int</span> number = atoi(txtFileNumber-&gt;getText().c_str());</span><br><span class="line"><span class="function">FileSplitter <span class="title">splitter</span><span class="params">(filePath, number, progressBar)</span></span>;</span><br><span class="line">splitter.split();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>多继承：一个是主继承类，一个是接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iprogess</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoProgess</span><span class="params">(<span class="keyword">float</span> value)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Iprogess()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSplitter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="built_in">string</span> m_filePath;</span><br><span class="line"><span class="keyword">int</span> m_fileNumber;</span><br><span class="line">Iprogess* iprogress;<span class="comment">///////////////</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">FileSplitter(<span class="keyword">const</span> <span class="built_in">string</span>&amp; filePath, <span class="keyword">int</span> fileNumber, ProgressBar* progressBar) :</span><br><span class="line">m_filePath(filePath), </span><br><span class="line">m_fileNumber(fileNumber),</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//1.读取大文件</span></span><br><span class="line"><span class="comment">//2.分批次向小文件中写入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_fileNumber; i++)&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">float</span> progressValue = m_fileNumber;</span><br><span class="line">progressValue = (i + <span class="number">1</span>) / progressValue;<span class="comment">//add update bar</span></span><br><span class="line">     onProgess(progressValue);</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onProgess</span><span class="params">(<span class="keyword">float</span> progressValue)</span><span class="comment">/////</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      iprogress-&gt;Doprogess(progressValue);<span class="comment">//////</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainForm</span> :</span> <span class="keyword">public</span> Form,<span class="keyword">public</span> Iprogess</span><br><span class="line">&#123;</span><br><span class="line">TextBox* txtFilePath;</span><br><span class="line">TextBox* txtFileNumber;</span><br><span class="line">ProgressBar* progressBar;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Button1_Click</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> filePath = txtFilePath-&gt;getText();</span><br><span class="line"><span class="keyword">int</span> number = atoi(txtFileNumber-&gt;getText().c_str());</span><br><span class="line"><span class="function">FileSplitter <span class="title">splitter</span><span class="params">(filePath, number)</span></span>;<span class="comment">//////</span></span><br><span class="line">splitter.split();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Doprogess</span><span class="params">(<span class="keyword">float</span> value)</span><span class="comment">//////</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    progressBar-&gt;setvalue(value);<span class="comment">////////</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IProgress</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoProgress</span><span class="params">(<span class="keyword">float</span> value)</span></span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~IProgress()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSplitter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="built_in">string</span> m_filePath;</span><br><span class="line"><span class="keyword">int</span> m_fileNumber;</span><br><span class="line">List&lt;IProgress*&gt;  m_iprogressList; <span class="comment">// 抽象通知机制，支持多个观察者</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">FileSplitter(<span class="keyword">const</span> <span class="built_in">string</span>&amp; filePath, <span class="keyword">int</span> fileNumber) :</span><br><span class="line">m_filePath(filePath), </span><br><span class="line">m_fileNumber(fileNumber)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//1.读取大文件</span></span><br><span class="line"><span class="comment">//2.分批次向小文件中写入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_fileNumber; i++)&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">float</span> progressValue = m_fileNumber;</span><br><span class="line">progressValue = (i + <span class="number">1</span>) / progressValue;</span><br><span class="line">onProgress(progressValue);<span class="comment">//发送通知</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addIProgress</span><span class="params">(IProgress* iprogress)</span></span>&#123;</span><br><span class="line">m_iprogressList.push_back(iprogress);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeIProgress</span><span class="params">(IProgress* iprogress)</span></span>&#123;</span><br><span class="line">m_iprogressList.remove(iprogress);</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onProgress</span><span class="params">(<span class="keyword">float</span> value)</span></span>&#123;</span><br><span class="line">List&lt;IProgress*&gt;::iterator itor=m_iprogressList.begin();</span><br><span class="line"><span class="keyword">while</span> (itor != m_iprogressList.end() )</span><br><span class="line">(*itor)-&gt;DoProgress(value); <span class="comment">//更新进度条</span></span><br><span class="line">itor++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainForm</span> :</span> <span class="keyword">public</span> Form, <span class="keyword">public</span> IProgress</span><br><span class="line">&#123;</span><br><span class="line">TextBox* txtFilePath;</span><br><span class="line">TextBox* txtFileNumber;</span><br><span class="line">ProgressBar* progressBar;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Button1_Click</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> filePath = txtFilePath-&gt;getText();</span><br><span class="line"><span class="keyword">int</span> number = atoi(txtFileNumber-&gt;getText().c_str());</span><br><span class="line"></span><br><span class="line">ConsoleNotifier cn;</span><br><span class="line"></span><br><span class="line"><span class="function">FileSplitter <span class="title">splitter</span><span class="params">(filePath, number)</span></span>;</span><br><span class="line"></span><br><span class="line">splitter.addIProgress(<span class="keyword">this</span>); <span class="comment">//订阅通知</span></span><br><span class="line">splitter.addIProgress(&amp;cn)； <span class="comment">//订阅通知</span></span><br><span class="line">splitter.split();</span><br><span class="line">splitter.removeIProgress(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoProgress</span><span class="params">(<span class="keyword">float</span> value)</span></span>&#123;</span><br><span class="line">progressBar-&gt;setValue(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsoleNotifier</span> :</span> <span class="keyword">public</span> IProgress &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoProgress</span><span class="params">(<span class="keyword">float</span> value)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"."</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>模式定义：</p><ul><li>定义对象间的一种一对多（<strong>变化</strong>）的依赖关系，以便当一个对象的状态发生变化时，所有依赖它的对象都可以得到通知并自动更新。</li></ul><p>observer ：IProgress</p><p>update：doProgess </p><p>attach : addiprogess</p><p>detach: removeiprogess</p><p>notify : noprogess</p><p>ConvreteObserver: mainform /console notify</p><p><img src="http://image.blissseven.top/blog/181112/6lma36f72D.png?imageslim" alt="mark"></p><p>总结：</p><ul><li>使用面向对象的抽象，Observer模式使得我们可以独立的改变目标与观察者，从而使二者之间的依赖关系松耦合</li><li>目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）自动传播</li><li>观察者自己决定是否需要订阅通知，目标对象对此一无所知</li><li>Observer模式基于事件的ui 框架中常用的设计模式，也是MVC模式的一个重要组成部分</li></ul><h2 id="Decorator装饰模式"><a href="#Decorator装饰模式" class="headerlink" title="Decorator装饰模式"></a>Decorator装饰模式</h2><p>单一职责模式：</p><ul><li><p>在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，这时候的关键是划清责任 </p></li><li><p>Decorator</p></li><li><p>Bridge</p><p>动机:</p></li><li><p>某些情况下可能过度使用继承来扩展对象的功能，由于继承为类型引入的静态特质（FileStream:read(),NetworkStream::read()），使得这种扩展方式缺乏灵活性，并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀。</p></li><li><p>如何时对象功能的扩展能够根据需要来动态的实现？同时避免“扩展功能的增多”带来的子类膨胀问题？从而使得任何“功能扩展变化”所导致的影响降为最低？</p></li></ul><p><img src="http://image.blissseven.top/blog/181113/IKHDDGKh6h.png?imageslim" alt="mark"></p><ul><li>编译时一样，运行时不一样，多态</li><li>装饰</li><li>CryoFileSyream/BufferedFileStream 不一定要继承 FileStream，不是一个增长方向</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//业务操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stream</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">virtual</span> ~Stream()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//主体类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileStream</span>:</span> <span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkStream</span> :</span><span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemoryStream</span> :</span><span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写内存流</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//扩展操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CryptoFileStream</span> :</span><span class="keyword">public</span> FileStream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        FileStream::Read(number);<span class="comment">//读文件流</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        FileStream::Seek(position);<span class="comment">//定位文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(byte data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        FileStream::Write(data);<span class="comment">//写文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CryptoNetworkStream</span> :</span> :<span class="keyword">public</span> NetworkStream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;       </span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        NetworkStream::Read(number);<span class="comment">//读网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        NetworkStream::Seek(position);<span class="comment">//定位网络流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(byte data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        NetworkStream::Write(data);<span class="comment">//写网络流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CryptoMemoryStream</span> :</span> <span class="keyword">public</span> MemoryStream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        MemoryStream::Read(number);<span class="comment">//读内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        MemoryStream::Seek(position);<span class="comment">//定位内存流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(byte data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        MemoryStream::Write(data);<span class="comment">//写内存流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferedFileStream</span> :</span> <span class="keyword">public</span> FileStream&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferedNetworkStream</span> :</span> <span class="keyword">public</span> NetworkStream&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferedMemoryStream</span> :</span> <span class="keyword">public</span> MemoryStream&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CryptoBufferedFileStream</span> :</span><span class="keyword">public</span> FileStream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        <span class="comment">//额外的缓冲操作...</span></span><br><span class="line">        FileStream::Read(number);<span class="comment">//读文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        <span class="comment">//额外的缓冲操作...</span></span><br><span class="line">        FileStream::Seek(position);<span class="comment">//定位文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        <span class="comment">//额外的缓冲操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(byte data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        <span class="comment">//额外的缓冲操作...</span></span><br><span class="line">        FileStream::Write(data);<span class="comment">//写文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        <span class="comment">//额外的缓冲操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Process</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//编译时装配</span></span><br><span class="line">    CryptoFileStream *fs1 = <span class="keyword">new</span> CryptoFileStream();</span><br><span class="line"></span><br><span class="line">    BufferedFileStream *fs2 = <span class="keyword">new</span> BufferedFileStream();</span><br><span class="line"></span><br><span class="line">    CryptoBufferedFileStream *fs3 =<span class="keyword">new</span> CryptoBufferedFileStream();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://image.blissseven.top/blog/181113/6BA9JcHI3K.png?imageslim" alt="mark"></p><ul><li>组合替代了继承</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//业务操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stream</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~Stream()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//主体类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileStream</span>:</span> <span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkStream</span> :</span><span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写网络流</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemoryStream</span> :</span><span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写内存流    </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//扩展操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CryptoStream</span>:</span> <span class="keyword">public</span> Stream <span class="comment">//继承Stream 为了virtual 接口统一</span></span><br><span class="line">&#123;    </span><br><span class="line">    Stream* stream;<span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CryptoStream(Stream* stm):stream(stm)&#123;</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream-&gt;Read(number);<span class="comment">//读文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream::Seek(position);<span class="comment">//定位文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(byte data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream::Write(data);<span class="comment">//写文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferedStream</span> :</span> <span class="keyword">public</span> Stream&#123;    </span><br><span class="line">    Stream* stream;<span class="comment">//...   </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BufferedStream(Stream* stm):stream(stm)&#123;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//运行时装配</span></span><br><span class="line">    FileStream* s1=<span class="keyword">new</span> FileStream();</span><br><span class="line">    CryptoStream* s2=<span class="keyword">new</span> CryptoStream(s1);  </span><br><span class="line">    BufferedStream* s3=<span class="keyword">new</span> BufferedStream(s1);  </span><br><span class="line">    BufferedStream* s4=<span class="keyword">new</span> BufferedStream(s2);     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//业务操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stream</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~Stream()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//主体类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileStream</span>:</span> <span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkStream</span> :</span><span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写网络流</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemoryStream</span> :</span><span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写内存流</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//扩展操作</span></span><br><span class="line">DecoratorStream: <span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">protected</span>: <span class="comment">////protected????</span></span><br><span class="line">    Stream* stream;<span class="comment">//... </span></span><br><span class="line">    DecoratorStream(Stream * stm):stream(stm)&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CryptoStream</span>:</span> <span class="keyword">public</span> DecoratorStream &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CryptoStream(Stream* stm):DecoratorStream(stm)<span class="comment">//调用基类构造器</span></span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123; </span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream-&gt;Read(number);<span class="comment">//读文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream::Seek(position);<span class="comment">//定位文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(byte data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream::Write(data);<span class="comment">//写文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferedStream</span> :</span> <span class="keyword">public</span> DecoratorStream&#123;  </span><br><span class="line">    Stream* stream;<span class="comment">//...  </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BufferedStream(Stream* stm):DecoratorStream(stm)&#123;      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//运行时装配</span></span><br><span class="line">    FileStream* s1=<span class="keyword">new</span> FileStream();   </span><br><span class="line">    CryptoStream* s2=<span class="keyword">new</span> CryptoStream(s1);  </span><br><span class="line">    BufferedStream* s3=<span class="keyword">new</span> BufferedStream(s1);</span><br><span class="line">    BufferedStream* s4=<span class="keyword">new</span> BufferedStream(s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模式定义：</p><ul><li>动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator比生成子类（继承）更为灵活（消除重复代码&amp;减少子类个数）。</li></ul><p><img src="http://image.blissseven.top/blog/181113/5K1DjF72kf.png?imageslim" alt="mark"></p><p>总结：</p><ul><li><p>通过采用组合而非继承的方法，Decorator模式实现了在<strong>运行时</strong>动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的“灵活性差”和“多子类衍生问题”。</p></li><li><p>Decorator类在<strong>接口上表现为is-a component继承关系</strong>，即Decorator类继承了component类所具有的接口。但在<strong>实现上又表现为has-a component</strong> 组合关系，即Decorator类又使用了另外一个Component类</p></li><li><p>Decorator模式的目的并非解决“多子类衍生的多继承问题”，应用的要点在于解决“<strong>主题类在多个方向上的扩展功能</strong>”，是为装饰的含义。</p></li><li><p>看到一个类,父类为一个类，同时子类里还有一个父类的字段，怀疑为装饰模式</p><ul><li>继承父类 为了接口规范</li><li>有父类字段，为了支持实现</li></ul></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DecoratorStream: <span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">protected</span>: <span class="comment">////protected????</span></span><br><span class="line">    Stream* stream;<span class="comment">//... </span></span><br><span class="line">    DecoratorStream(Stream * stm):stream(stm)&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Bridge桥模式"><a href="#Bridge桥模式" class="headerlink" title="Bridge桥模式"></a>Bridge桥模式</h2><p><img src="http://image.blissseven.top/blog/181113/E3g7Eim4eI.png?imageslim" alt="mark"></p><p>动机：</p><ul><li>由于某些类型的固有的实现逻辑，使得它们具有两个变化的维度，乃至多个维度的变化。</li><li>如何应对这种多维度的变化，如何利用面向对象技术来使得类型可以轻松的沿着两个乃至多个方向变化，而不引入额外的复杂度。</li></ul><p>Lite 和Lite，perfect和perfect 重合</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Messager</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(<span class="built_in">string</span> username, <span class="built_in">string</span> password)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="built_in">string</span> message)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>=<span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">virtual</span> ~Messager()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//平台实现n   类的个数1+n+m*n</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PCMessagerBase</span> :</span> <span class="keyword">public</span> Messager&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MobileMessagerBase</span> :</span> <span class="keyword">public</span> Messager&#123;</span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//业务抽象m</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PCMessagerLite</span> :</span> <span class="keyword">public</span> PCMessagerBase &#123;</span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(<span class="built_in">string</span> username, <span class="built_in">string</span> password)</span></span>&#123;     </span><br><span class="line">        PCMessagerBase::Connect();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="built_in">string</span> message)</span></span>&#123;     </span><br><span class="line">        PCMessagerBase::WriteText();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;       </span><br><span class="line">        PCMessagerBase::DrawShape();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PCMessagerPerfect</span> :</span> <span class="keyword">public</span> PCMessagerBase &#123;</span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(<span class="built_in">string</span> username, <span class="built_in">string</span> password)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        PCMessagerBase::PlaySound();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        PCMessagerBase::Connect();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="built_in">string</span> message)</span></span>&#123;  </span><br><span class="line">        PCMessagerBase::PlaySound();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        PCMessagerBase::WriteText();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        PCMessagerBase::PlaySound();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        PCMessagerBase::DrawShape();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MobileMessagerLite</span> :</span> <span class="keyword">public</span> MobileMessagerBase &#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(<span class="built_in">string</span> username, <span class="built_in">string</span> password)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        MobileMessagerBase::Connect();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="built_in">string</span> message)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        MobileMessagerBase::WriteText();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        MobileMessagerBase::DrawShape();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MobileMessagerPerfect</span> :</span> <span class="keyword">public</span> MobileMessagerBase &#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(<span class="built_in">string</span> username, <span class="built_in">string</span> password)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        MobileMessagerBase::PlaySound();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        MobileMessagerBase::Connect();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="built_in">string</span> message)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        MobileMessagerBase::PlaySound();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        MobileMessagerBase::WriteText();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        MobileMessagerBase::PlaySound();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        MobileMessagerBase::DrawShape();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//编译时装配</span></span><br><span class="line">        Messager *m =</span><br><span class="line">            <span class="keyword">new</span> MobileMessagerPerfect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Messager 构造函数 增加对Messager的初始化</li><li>子类构造函数调用Messager的构造函数</li><li>如果子类里有同样的字段，把这个字段往父类扔，protected:</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Messager</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">     MessagerImp* messagerImp;<span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(<span class="built_in">string</span> username, <span class="built_in">string</span> password)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="built_in">string</span> message)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Messager()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessagerImp</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~MessagerImp()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//平台实现 n</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PCMessagerImp</span> :</span> <span class="keyword">public</span> MessagerImp&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MobileMessagerImp</span> :</span> <span class="keyword">public</span> MessagerImp&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//业务抽象 m</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类的数目：1+n+m</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessagerLite</span> :</span><span class="keyword">public</span> Messager &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(<span class="built_in">string</span> username, <span class="built_in">string</span> password)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        messagerImp-&gt;Connect();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="built_in">string</span> message)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        messagerImp-&gt;WriteText();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        messagerImp-&gt;DrawShape();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessagerPerfect</span>  :</span><span class="keyword">public</span> Messager &#123;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(<span class="built_in">string</span> username, <span class="built_in">string</span> password)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        messagerImp-&gt;PlaySound();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        messagerImp-&gt;Connect();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="built_in">string</span> message)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        messagerImp-&gt;PlaySound();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        messagerImp-&gt;WriteText();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        messagerImp-&gt;PlaySound();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        messagerImp-&gt;DrawShape();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//运行时装配</span></span><br><span class="line">    MessagerImp* mImp=<span class="keyword">new</span> PCMessagerImp();</span><br><span class="line">    Messager *m =<span class="keyword">new</span> Messager(mImp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模式定义：</p><ul><li>将抽象部分（业务功能）与实现部分（平台分离）分离，使它们都可以独立变化</li></ul><p><img src="http://image.blissseven.top/blog/181113/Eb789KJ2jm.png?imageslim" alt="mark"></p><p>总结：</p><ul><li>Bridge 使用<strong>对象间的组合关系</strong>解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自维度的变化，即<strong>子类化它们</strong>。</li><li>Bridge 有时候类似于多继承方案，但是多继承方案往往违背单一职责原则（一个类只有一个变化的原因），复用性差。Bridge是比多继承方案更好的解决方案</li><li>Bridge模式的应用一般在<strong>两个非常强的变化维度</strong>，有时一个类有多余两个的变化维度，这时剋使用Bridge的扩展模式。</li></ul><h2 id="Factory-Method-工厂模式"><a href="#Factory-Method-工厂模式" class="headerlink" title="Factory Method 工厂模式"></a>Factory Method 工厂模式</h2><p>对象创建模式：</p><ul><li>通过对象创建模式绕开new,来避免对象创建(new)过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作</li><li>Fcatory method</li><li>Abstract Factory</li><li>Prototype</li><li>Builder</li></ul><p>动机：</p><ul><li>在软件系统中，经常面临创建对象的工作；由于需求的变化，需要创建的对象的具体类型经常变化</li><li>如何应对这种变化，如何绕过常规的对象创建方法（new），提供一种封装机制来避免客户程序和这种具体对象创建工作的紧耦合</li></ul><p>违背依赖倒置原则，</p><p>编译时依赖，编译时通过，MainFrom 编译时，需要依赖于BinarySplitter的存在。`</p><p>创建对象：</p><ul><li>new</li><li>BinarySplitter bs();</li><li>通过一个函数返回一个对象</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISplitter</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~ISplitter()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySplitter</span> :</span> <span class="keyword">public</span> ISplitter&#123;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TxtSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PictureSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//////////////////////////////////////</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainForm</span> :</span> <span class="keyword">public</span> Form</span><br><span class="line">&#123;</span><br><span class="line">TextBox* txtFilePath;</span><br><span class="line">TextBox* txtFileNumber;</span><br><span class="line">ProgressBar* progressBar;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Button1_Click</span><span class="params">()</span></span>&#123;        </span><br><span class="line">ISplitter * splitter=</span><br><span class="line">            <span class="keyword">new</span> BinarySplitter();<span class="comment">//依赖具体类        </span></span><br><span class="line">        splitter-&gt;split();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySplitter</span> :</span> <span class="keyword">public</span> ISplitter&#123;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TxtSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PictureSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//具体工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySplitterFactory</span>:</span> <span class="keyword">public</span> SplitterFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BinarySplitter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TxtSplitterFactory</span>:</span> <span class="keyword">public</span> SplitterFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TxtSplitter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PictureSplitterFactory</span>:</span> <span class="keyword">public</span> SplitterFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PictureSplitter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoSplitterFactory</span>:</span> <span class="keyword">public</span> SplitterFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> VideoSplitter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISplitter</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~ISplitter()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//工厂基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplitterFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~SplitterFactory()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainForm</span> :</span> <span class="keyword">public</span> Form</span><br><span class="line">&#123;</span><br><span class="line">    SplitterFactory*  factory;<span class="comment">//工厂</span></span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">    MainForm(SplitterFactory*  factory)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;factory=factory;</span><br><span class="line">    &#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Button1_Click</span><span class="params">()</span></span>&#123;     </span><br><span class="line">ISplitter * splitter=</span><br><span class="line">            factory-&gt;CreateSplitter(); <span class="comment">//多态new       </span></span><br><span class="line">        splitter-&gt;split();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>模式定义：</p><ul><li>定义一个用于创建对象的接口，让子类决定实例化哪个类，Factory Method使得一个类的实例化延迟（目的：解耦，手段：虚函数）到子类。</li></ul><p>Product: ISplitter</p><p>ConcreteProduct: BinarySplitter/TxtSplitter/PictureSplitter</p><p>Creator: SplitterFactory</p><p>ConcreteCreator:BinarySplitterFactory/TxtSplitterFactory/PictureSplitterFactory</p><p><img src="http://image.blissseven.top/blog/181113/b9l3cIaIe5.png?imageslim" alt="mark"></p><p>总结：</p><ul><li>Factory Method 模式用于隔离对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系（new）会导致软件的脆弱</li><li>Factory Method 模式通过面向对象的手法，将所要创建的具体对象工作<strong>延迟</strong>到子类，从而实现一种<strong>扩展</strong>（<strong>而非更改</strong>）的策略，较好的解决了这种紧耦合关系。</li><li>Factory Method 模式解决单个对象的需求变化。<strong>缺点在于要求创建方法/参数相同</strong>.</li></ul><h2 id="Abstract-Factory抽象工厂模式"><a href="#Abstract-Factory抽象工厂模式" class="headerlink" title="Abstract Factory抽象工厂模式"></a>Abstract Factory抽象工厂模式</h2><p><strong>动机</strong>：</p><ul><li>面临<strong>一系列相互依赖的对象</strong>的创建工作，同时由于需求的变化，往往存在更多系列对象的创建工作。</li><li>如何应对这种变化，如何绕过常规的对象创建方法（new）,提供一种封装机制来避免客户程序和这种多系列具体对象创建工作的紧耦合。</li></ul><p>面临多种数据库的变化，new（） 不适合</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmployeeDAO</span>&#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;EmployeeDO&gt; GetEmployees()&#123;</span><br><span class="line">        SqlConnection* connection =</span><br><span class="line">            <span class="keyword">new</span> SqlConnection();</span><br><span class="line">        connection-&gt;ConnectionString = <span class="string">"..."</span>;</span><br><span class="line"></span><br><span class="line">        SqlCommand* command =</span><br><span class="line">            <span class="keyword">new</span> SqlCommand();</span><br><span class="line">        command-&gt;CommandText=<span class="string">"..."</span>;</span><br><span class="line">        command-&gt;SetConnection(connection);</span><br><span class="line"></span><br><span class="line">        SqlDataReader* reader = command-&gt;ExecuteReader();</span><br><span class="line">        <span class="keyword">while</span> (reader-&gt;Read())&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//数据库访问有关的基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDBConnection</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDBConnectionFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBConnection* <span class="title">CreateDBConnection</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDBCommand</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDBCommandFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBCommand* <span class="title">CreateDBCommand</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDataReader</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDataReaderFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDataReader* <span class="title">CreateDataReader</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//支持SQL Server</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlConnection</span>:</span> <span class="keyword">public</span> IDBConnection&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlConnectionFactory</span>:</span><span class="keyword">public</span> IDBConnectionFactory&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlCommand</span>:</span> <span class="keyword">public</span> IDBCommand&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlCommandFactory</span>:</span><span class="keyword">public</span> IDBCommandFactory&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlDataReader</span>:</span> <span class="keyword">public</span> IDataReader&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlDataReaderFactory</span>:</span><span class="keyword">public</span> IDataReaderFactory&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//支持Oracle</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OracleConnection</span>:</span> <span class="keyword">public</span> IDBConnection&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OracleCommand</span>:</span> <span class="keyword">public</span> IDBCommand&#123;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OracleDataReader</span>:</span> <span class="keyword">public</span> IDataReader&#123; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmployeeDAO</span>//<span class="title">connection</span> 和 <span class="title">command</span>和 <span class="title">reader</span> 三者是要同一个数据库类型</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    IDBConnectionFactory* dbConnectionFactory;</span><br><span class="line">    IDBCommandFactory* dbCommandFactory;</span><br><span class="line">    IDataReaderFactory* dataReaderFactory;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;EmployeeDO&gt; GetEmployees()&#123;</span><br><span class="line">        </span><br><span class="line">        IDBConnection* connection =</span><br><span class="line">            dbConnectionFactory-&gt;CreateDBConnection();</span><br><span class="line">        connection-&gt;ConnectionString(<span class="string">"..."</span>);</span><br><span class="line">        </span><br><span class="line">        IDBCommand* command =</span><br><span class="line">            dbCommandFactory-&gt;CreateDBCommand();</span><br><span class="line">        command-&gt;CommandText(<span class="string">"..."</span>);</span><br><span class="line">        command-&gt;SetConnection(connection); <span class="comment">//关联性</span></span><br><span class="line">        </span><br><span class="line">        IDBDataReader* reader = command-&gt;ExecuteReader(); <span class="comment">//关联性</span></span><br><span class="line">        <span class="keyword">while</span> (reader-&gt;Read())&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//数据库访问有关的基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDBConnection</span>&#123;</span>    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDBCommand</span>&#123;</span>    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDataReader</span>&#123;</span>   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDBFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBConnection* <span class="title">CreateDBConnection</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBCommand* <span class="title">CreateDBCommand</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDataReader* <span class="title">CreateDataReader</span><span class="params">()</span></span>=<span class="number">0</span>;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//支持SQL Server</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlConnection</span>:</span> <span class="keyword">public</span> IDBConnection&#123;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlCommand</span>:</span> <span class="keyword">public</span> IDBCommand&#123;   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlDataReader</span>:</span> <span class="keyword">public</span> IDataReader&#123;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlDBFactory</span>:</span><span class="keyword">public</span> IDBFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBConnection* <span class="title">CreateDBConnection</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBCommand* <span class="title">CreateDBCommand</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDataReader* <span class="title">CreateDataReader</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//支持Oracle</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OracleConnection</span>:</span> <span class="keyword">public</span> IDBConnection&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OracleCommand</span>:</span> <span class="keyword">public</span> IDBCommand&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OracleDataReader</span>:</span> <span class="keyword">public</span> IDataReader&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmployeeDAO</span>&#123;</span></span><br><span class="line">    IDBFactory* dbFactory;    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;EmployeeDO&gt; GetEmployees()&#123;</span><br><span class="line">        IDBConnection* connection =</span><br><span class="line">            dbFactory-&gt;CreateDBConnection();</span><br><span class="line">        connection-&gt;ConnectionString(<span class="string">"..."</span>);</span><br><span class="line"></span><br><span class="line">        IDBCommand* command =</span><br><span class="line">            dbFactory-&gt;CreateDBCommand();</span><br><span class="line">        command-&gt;CommandText(<span class="string">"..."</span>);</span><br><span class="line">        command-&gt;SetConnection(connection); <span class="comment">//关联性</span></span><br><span class="line"></span><br><span class="line">        IDBDataReader* reader = command-&gt;ExecuteReader(); <span class="comment">//关联性</span></span><br><span class="line">        <span class="keyword">while</span> (reader-&gt;Read())&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>模式定义：</p><ul><li>提供一个接口，让该接口负责创建一系列<strong>相关或者相互依赖的对象</strong>，无需指定它们具体的类。</li></ul><p>AbstractFactory: IDBFactory</p><p>ConcreteFactory1: SqlDBFactory</p><p>ConcreteFactory2: OracleDBFactory</p><p>AbstractProductA: IDBConnection</p><p>AbstractProductB: IDBCommand</p><p><img src="http://image.blissseven.top/blog/181113/eEb4g1e26k.png?imageslim" alt="mark"></p><p>总结：</p><ul><li>如果没有必要应对多系列对象构建的需求变化，则没有必要使用Abstract Factory模式，这时候使用简单的工厂</li><li>系列对象指的是在某一特定系列下的对象之间有相互依赖、相互作用的关系。不同系列的对象之间不能相互依赖。</li><li>Abstract Factory 主要在于应对新系列的需求变化。其缺点在于难以应对新对象的需求变动。</li></ul><h2 id="Prototype原型模式"><a href="#Prototype原型模式" class="headerlink" title="Prototype原型模式"></a>Prototype原型模式</h2><ul><li>和BUILD模式用的少</li><li>对象创建模式</li></ul><p>通过拷贝构造函数绕过new</p><p>动机：</p><ul><li>在软件系统中，经常面临<strong>“某些结构复杂的对象”</strong>的创建工作，由于需求的变化，这些对象经常面临者剧烈的变化，但是它们却拥有比较稳定一致的接口</li><li>如何应对这种变化？如何向“客户程序”（使用这些对象的程序）隔离出这些易变对象，从而使得”依赖这些易变对象的客户程序“不随着需求改变而改变。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISplitter</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">clone</span><span class="params">()</span></span>=<span class="number">0</span>; <span class="comment">//通过克隆自己来创建对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~ISplitter()&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//具体类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySplitter</span> :</span> <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BinarySplitter(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TxtSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TxtSplitter(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PictureSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PictureSplitter(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> VideoSplitter(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">////////////////////////////////////</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainForm</span> :</span> <span class="keyword">public</span> Form</span><br><span class="line">&#123;</span><br><span class="line">    ISplitter*  prototype;<span class="comment">//原型对象</span></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    MainForm(ISplitter*  prototype)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;prototype=prototype;</span><br><span class="line">    &#125;    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Button1_Click</span><span class="params">()</span></span>&#123;</span><br><span class="line">ISplitter * prototype=</span><br><span class="line">            prototype-&gt;clone(); <span class="comment">//克隆原型  </span></span><br><span class="line">        prototype-&gt;split();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">delete</span> prototype；</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>模式定义：</p><ul><li>使用<strong>原型实例</strong>指定创建对象的种类，然后通过<strong>深拷贝</strong>这些原型来<strong>创建新的对象</strong>。</li><li>工厂方法 new一个对象，对象的method 实现</li><li>深拷贝构造函数，</li></ul><p><img src="http://image.blissseven.top/blog/181116/ji79KIbj2b.png?imageslim" alt="mark"></p><p> 总结：</p><ul><li>同样适用于隔离<strong>类对象的使用者</strong>和<strong>具体类型（易变类）</strong>之间的耦合关系，同样要求这些易变类有<strong>稳定</strong>的接口。</li><li>对于如何创建易变类的实体对象采用原型克隆的方法来做，使得我们可以非常灵活的动态创建拥有某些稳定接口的新对象，所需工具仅仅是注册一个新类的对象即原型，然后在任何需要的地法国Clone</li><li>Clone方法可以利用某些框架中的<strong>序列化</strong>来实现深拷贝</li></ul><h2 id="Builder构建器模式"><a href="#Builder构建器模式" class="headerlink" title="Builder构建器模式"></a>Builder构建器模式</h2><p>动机：</p><ul><li>在软件系统中，有时候面临着一个复杂对象的创建工作，其通常由各个福分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的<strong>各个部分经常面临着剧烈的变化</strong>，但是将它们<strong>组合在一起的算法相对稳定</strong></li><li>如何应对这种变化，如何提供一种封装机制来隔离出复杂对象的各个部分的变化，从而保持系统中的稳定构建算法不随着需求的改变而改变。</li></ul><p>c++构造函数调用纯虚函数为静态绑定，不会调用子类的函数。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span>&#123;</span></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HouseBuilder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">House* <span class="title">GetResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pHouse;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~HouseBuilder()&#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    </span><br><span class="line">    House* pHouse;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart1</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart2</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart3</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart4</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart5</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoneHouse</span>:</span> <span class="keyword">public</span> House&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoneHouseBuilder</span>:</span> <span class="keyword">public</span> HouseBuilder&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//pHouse-&gt;Part1 = ...;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HouseDirector</span>&#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HouseBuilder* pHouseBuilder;</span><br><span class="line">    </span><br><span class="line">    HouseDirector(HouseBuilder* pHouseBuilder)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pHouseBuilder=pHouseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">House* <span class="title">Construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        pHouseBuilder-&gt;BuildPart1();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            pHouseBuilder-&gt;BuildPart2();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> flag=pHouseBuilder-&gt;BuildPart3();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            pHouseBuilder-&gt;BuildPart4();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pHouseBuilder-&gt;BuildPart5();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pHouseBuilder-&gt;GetResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="C:%5CUsers%5Cbliss%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1542364198157.png" alt="1542364198157"></p><p>总结：</p><ul><li>Build模式主要用于分步骤构建一个复杂的对象。这其中分步骤是一个稳定的算法，而复杂对象的各个部分经常变化</li><li>变化在哪里，封装在哪里—–Builder模式主要在于应对复杂对象的各个部分的频繁需求变动。其缺点在于难以应对分步骤构建算法的需求变动</li><li>注意不同语言中构造器内调用虚函数的差别（c++ VS C#）</li><li><strong>派生类中可以通过派生类对象访问基类的protected成员</strong></li></ul><h2 id="Singleton-单件模式"><a href="#Singleton-单件模式" class="headerlink" title="Singleton 单件模式"></a>Singleton 单件模式</h2><p>对象性能模式：</p><ul><li>面向对象带来的成本,虚函数</li><li>Singleton</li><li>Flyweight</li></ul><p>动机：</p><ul><li>特殊的类，只存在一个实例</li><li>绕过常规的构造器，提供一种机制来保证一个类只有一个实例</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton();</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp; other);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> Singleton* m_instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::m_instance=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程非安全版本</span></span><br><span class="line">Singleton* Singleton::getInstance() &#123;</span><br><span class="line">    <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        m_instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//同时读操作不需要加锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程安全版本，但锁的代价过高</span></span><br><span class="line">Singleton* Singleton::getInstance() &#123;</span><br><span class="line">    Lock lock;</span><br><span class="line">    <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        m_instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//双检查锁，但由于内存读写reorder不安全</span></span><br><span class="line"><span class="comment">//reorder </span></span><br><span class="line"><span class="comment">//分配内存，构造器，内存地址赋值m_instance 三个顺序有可能reorder</span></span><br><span class="line"><span class="comment">//分配内存  内存地址赋值m_instance(thiead b 返回m_instance) 构造器</span></span><br><span class="line">Singleton* Singleton::getInstance() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(m_instance==<span class="literal">nullptr</span>)<span class="comment">// 都是读操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        Lock lock;</span><br><span class="line">        <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="number">50</span>            m_instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++ 11版本之后的跨平台实现 (volatile)</span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;Singleton*&gt; Singleton::m_instance;</span><br><span class="line"><span class="built_in">std</span>::mutex Singleton::m_mutex;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::getInstance() &#123;</span><br><span class="line">    Singleton* tmp = m_instance.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_acquire);<span class="comment">//获取内存fence</span></span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(m_mutex);</span><br><span class="line">        tmp = m_instance.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            tmp = <span class="keyword">new</span> Singleton;</span><br><span class="line">            <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_release);<span class="comment">//释放内存fence</span></span><br><span class="line">            m_instance.store(tmp, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模式定义：</p><ul><li>保证一个类只有一个实例，并提供一个该例的全局访问点</li><li></li></ul><p><img src="C:%5CUsers%5Cbliss%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1542368309714.png" alt="1542368309714"></p><p>总结：</p><ul><li>Singleton模式中的实例构造器可以设置为protected以允许子类派生。</li><li>一般不要支持拷贝构造和Clone接口</li><li>多线程下的安全的Singletong,注意双检查锁的正确实现。</li></ul><h2 id="Flyweight-享元模式"><a href="#Flyweight-享元模式" class="headerlink" title="Flyweight 享元模式"></a>Flyweight 享元模式</h2><ul><li>在软件系统采用纯粹对象方案的问题在于大量<strong>细粒度的对象</strong>会很快充斥在系统中，从而带来很高的运行时代价-主要指内存需求方面的代价。</li><li>如何在避免大量细粒度对象问题的同时，让外部客户程序仍然能够透明地使用面向对象的方式来操作。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Font</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> key;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Font(<span class="keyword">const</span> <span class="built_in">string</span>&amp; key)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FontFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">map</span> &lt;<span class="built_in">string</span>,Font*&gt; fontpool;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Font* <span class="title">GetFont</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>,Font*&gt;::iterator item=fontpool.find(key);</span><br><span class="line">        <span class="keyword">if</span>(item!=fontpool.end())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> fontpool[key];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Font* font=<span class="keyword">new</span> Font(key);</span><br><span class="line">            fontpool[key]=font;</span><br><span class="line">            <span class="keyword">return</span> font;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>模式定义：</p><ul><li>运用共享技术有效支持大量细粒度对象</li></ul><p>总结：</p><ul><li>解决面向对象的代价问题</li><li>采用共享对象的做法来降低系统中对象的个数，降低细粒度给系统带来的内存压力，在具体事项方面，注意对象状态的处理，尽可能只读</li></ul><h2 id="Facade-门面模式"><a href="#Facade-门面模式" class="headerlink" title="Facade 门面模式"></a>Facade 门面模式</h2><p>接口隔离模式：</p><ul><li><p>在组建构建过程中，某些接口之间直接的依赖会带来很多问题，采用添加一层间接（稳定）的接口，来隔离本来互相基民关联的接口是一种常见的解决方案。</p></li><li><p>Facade</p></li><li><p>Proxy</p></li><li><p>Adapter</p></li><li><p>Mediator</p></li></ul><p>动机：</p><ul><li>A方案的问题在于客户和组件中各种复杂的子系统有了过多的耦合，随着外部客户程序和各子系统的演化，这种过多的耦合面临很多变化的挑战。</li><li>如何简化外部客户程序和系统间的交互接口？如何将外部客户程序的演化和内部子系统的变化之间的依赖相互解耦。</li></ul><p>模式定义：</p><ul><li>为子系统中的一组接口提供一个一致（稳定）的界面，Facade定义了一个高层接口，使得这一子系统更加容易使用（复用）。</li></ul><p>总结：</p><ul><li>从客户程序角度来看，Facade模式简化了整个组建系统的接口，对于组建内部与外部客户程序来说，达到了一种<strong>解耦</strong>的效果-内部子系统的任何变化不会影响到Facade接口的变化。</li><li>Facade模式更注重从<strong>架构的层次</strong>去看整个系统，而不是单个类的层次，更多时候是一种架构设计模式。</li><li>并非一个集装箱，可以任意放进任何多个对象。Facade中组建的内部应该是“<strong>相互耦合关系比较大的一系列组建件</strong>”，而不是一个简单的功能集合。</li></ul><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>动机：</p><ul><li>有些对象某些原因（对象创建的开销很大，某些操作需要安全控制，需要进程外的访问），直接访问会给使用者、系统结构带来很多麻烦</li><li>如何在不失去透明操作对象的同时来管理/控制这些对象特有的复杂性？增加一层间接层是软件开发中常见的解决方式。</li></ul><p>模式定义：</p><ul><li>为其它对象提供一种代理以控制（隔离，使用接口）对这个对象的访问。</li></ul><p><img src="http://image.blissseven.top/18-11-17/95972507.jpg" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISubject</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span>:</span> <span class="keyword">public</span> ISubject&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientApp</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">    ISubject* subject;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    ClientApp()&#123;</span><br><span class="line">        subject=<span class="keyword">new</span> RealSubject();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        subject-&gt;process();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISubject</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Proxy的设计 很复杂 多工具自动生成</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubjectProxy</span>:</span> <span class="keyword">public</span> ISubject&#123;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//对RealSubject的一种间接访问</span></span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientApp</span>&#123;</span>   </span><br><span class="line">    ISubject* subject;    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    ClientApp()&#123;</span><br><span class="line">        subject=<span class="keyword">new</span> SubjectProxy();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        subject-&gt;process();        </span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>总结：</p><p><img src="http://image.blissseven.top/18-11-17/89050695.jpg" alt></p><h2 id="Adapter适配器"><a href="#Adapter适配器" class="headerlink" title="Adapter适配器"></a>Adapter适配器</h2><p>动机：</p><ul><li>由于应用环境的变化，常常需要将“一些现存的对象”放到新的环境中去使用，但是新环境要求的接口是这些现存对象所不满足的</li><li>如何应对这种“迁移的变化”？如何技能利用现有对象的良好实现，同时又能满足新的应用环境所要求的接口?</li></ul><p>模式定义：</p><ul><li>将一个类的就转成客户想要的接口</li><li>组合/</li></ul><p><img src="http://image.blissseven.top/18-11-17/23334727.jpg" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标接口（新接口）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ITarget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遗留接口（老接口）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IAdaptee</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> data)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遗留类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OldClass</span>:</span> <span class="keyword">public</span> IAdaptee&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象适配器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span>:</span> <span class="keyword">public</span> ITarget&#123; <span class="comment">//继承</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    IAdaptee* pAdaptee;<span class="comment">//组合</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    Adapter(IAdaptee* pAdaptee)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pAdaptee=pAdaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> data=pAdaptee-&gt;bar();</span><br><span class="line">        pAdaptee-&gt;foo(data);    </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类适配器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span>:</span> <span class="keyword">public</span> ITarget,</span><br><span class="line">               <span class="keyword">protected</span> OldClass&#123; <span class="comment">//多继承                             </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IAdaptee* pAdaptee=<span class="keyword">new</span> OldClass();</span><br><span class="line">    </span><br><span class="line">    ITarget* pTarget=<span class="keyword">new</span> Adapter(pAdaptee);</span><br><span class="line">    pTarget-&gt;process();</span><br><span class="line">       </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stack</span>&#123;</span></span><br><span class="line">    deqeue container;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span>&#123;</span></span><br><span class="line">    deqeue container;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>主要应用于“希望复用一些现存的类，但是接口又与复用环境不一致的情况”，在遗留代码复用、类库迁移等方面非常有用。</li><li>两种实现结构：<ul><li>对象适配器，对象组合</li><li>类适配器，多继承，不推荐</li></ul></li></ul><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>动机：</p><ul><li>多个对象互相并联交互，<strong>多个对象之间维持一种复杂的引用关系</strong>，如果遇到一些需求的更改，这种直接的引用关系将面临不断的变化。</li><li>使用一种中介对象来管理对象间的关联关系，避免相互交互的对象之间的紧耦合引用关系，从而更好抵御变化。</li></ul><p>定义：</p><ul><li><p>用一个中介对象来封装（封装变化）一系列的对象交互。中介者使各对象不需要显式的相互引用（编译时依赖-&gt;运行时依赖），从而使其耦合松散（管理变化），而且可以独立地改变它们之间的交互。</p></li><li><p>concretecolleague1和concretecolleague2本来存在依赖关系</p></li><li><p>concretecolleague1和concretecolleague2 依赖Mediator，而Mediator依赖Colleague，使得concretecolleague1和concretecolleague2不相互依赖</p></li></ul><p><img src="http://image.blissseven.top/18-11-17/54361873.jpg" alt></p><p> <img src="http://image.blissseven.top/18-11-17/46008598.jpg" alt></p><p>总结：</p><ul><li>将多个对象间复杂的关联关系解耦，Mediator模式将多个对象间的控制逻辑进行集中管理，变“多个对象互相关联”为多个对象和一个中介者关联，简化了系统的维护，抵御了可能的变化。</li><li>随着控制逻辑的变化，Mediator具体对象的实现可能相当复杂。可以对Mediator对象进行分界处理</li><li>Facade模式是解耦<strong>系统间</strong>（单向）的对象关联关系；Mediator模式解耦<strong>系统内</strong>各个对象之间（双向）的并联关系。</li></ul><h2 id="State-状态模式"><a href="#State-状态模式" class="headerlink" title="State 状态模式"></a>State 状态模式</h2><p>状态变化模式：</p><ul><li>在组件构建过程中，某些<strong>对象的状态经常面临变化</strong>，如何对状态变化进行有效的管理？同时又维持高层模块的稳定？</li><li>State</li><li>Memento</li></ul><p>动机：</p><ul><li>某些对象的状态如果改变，其行为也会随之而发生变化，eg(文档处于只读状态其支持的行为和读写的状态支持的行为就可能完全不同)</li><li>如何在运行时根据对象的状态来透明的更改对象的行为？而不会为对象操作和状态转化之间引入紧耦合。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多个 if/else </span></span><br><span class="line"><span class="comment">//增加一个时，违背开放封闭原则</span></span><br><span class="line"><span class="keyword">enum</span> NetworkState</span><br><span class="line">&#123;</span><br><span class="line">    Network_Open,</span><br><span class="line">    Network_Close,</span><br><span class="line">    Network_Connect,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkProcessor</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">    NetworkState state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state == Network_Open)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//**********</span></span><br><span class="line">            state = Network_Close;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == Network_Close)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//..........</span></span><br><span class="line">            state = Network_Connect;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == Network_Connect)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//$$$$$$$$$$</span></span><br><span class="line">            state = Network_Open;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Operation2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (state == Network_Open)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//**********</span></span><br><span class="line">            state = Network_Connect;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == Network_Close)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//.....</span></span><br><span class="line">            state = Network_Open;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == Network_Connect)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//$$$$$$$$$$</span></span><br><span class="line">            state = Network_Close;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Operation3</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkState</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NetworkState* pNext;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operation1</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operation2</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operation3</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~NetworkState()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenState</span> :</span><span class="keyword">public</span> NetworkState&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> NetworkState* m_instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> NetworkState* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> OpenState();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">        pNext = CloseState::getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//..........</span></span><br><span class="line">        pNext = ConnectState::getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//$$$$$$$$$$</span></span><br><span class="line">        pNext = OpenState::getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloseState</span>:</span><span class="keyword">public</span> NetworkState&#123; &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkProcessor</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">    NetworkState* pState;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    NetworkProcessor(NetworkState* pState)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">this</span>-&gt;pState = pState;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        pState-&gt;Operation1();</span><br><span class="line">        pState = pState-&gt;pNext;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        pState-&gt;Operation2();</span><br><span class="line">        pState = pState-&gt;pNext;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        pState-&gt;Operation3();</span><br><span class="line">        pState = pState-&gt;pNext;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>context：networkprocessor</p><p><img src="http://image.blissseven.top/18-11-17/46277154.jpg" alt></p><p>模式定义：</p><ul><li>允许对象在其内部状态改变时改变它的行为。从而使对象看起来似乎修改了其行为。</li></ul><p>总结：</p><ul><li>state模式将所有与一个特定状态相关的行为都放入一个state的对象中，在<strong>对象状态切换</strong>时，<strong>切换相应的对象</strong>，但同时维持state的接口，实现了具体操作和状态切换之间的解耦</li><li>为不同的状态引入不同的对象使得状态转换变得更加明确，而且可以保证不会出现状态不一致的情况，因为转换是原子性的——即要么彻底转换过来，要么不转换。</li><li>如果state对象没有实例变量，那么各个上下文可以共享同一个state对象（singleton），节省开销。</li></ul><h2 id="Memento-备忘录模式"><a href="#Memento-备忘录模式" class="headerlink" title="Memento 备忘录模式"></a>Memento 备忘录模式</h2><p>动机：</p><ul><li>某些对象的状态在转换过程中，可能由于某种需要，要求程序能够回溯到对象之前处于某个点时的状态。如果使用一些共有接口来让其他对象得到对象的状态，便会暴漏对象的细节实现。</li><li>如何实现对象状态的良好保存和恢复？同时又不会破坏对象本身的封装性。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memento</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> state;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Memento(<span class="keyword">const</span> <span class="built_in">string</span> &amp; s) : state(s) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getState</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> state; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp; s)</span> </span>&#123; state = s; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Originator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> state;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Originator() &#123;&#125;</span><br><span class="line">    <span class="function">Memento <span class="title">createMomento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">Memento <span class="title">m</span><span class="params">(state)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMomento</span><span class="params">(<span class="keyword">const</span> Memento &amp; m)</span> </span>&#123;</span><br><span class="line">        state = m.getState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Originator orginator;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//捕获对象状态，存储到备忘录</span></span><br><span class="line">    Memento mem = orginator.createMomento();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//... 改变orginator状态</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从备忘录中恢复</span></span><br><span class="line">    orginator.setMomento(memento);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>备忘录存储原发器对象的内部状态，在需要时回复原发器的状态</li><li>Memento核心为信息隐藏，即Originator需要向外隐藏信息，保持其封装性，但同时有需要将状态保持到外界Memento</li><li>多采用对象序列化支持实现Memento</li></ul><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>数据结构模式：</p><ul><li>组件在内部有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大的破坏组件的复用。这时候<strong>将这些特定数据结构封装在内部，在外部提供统一的接口</strong>，来实现与特定数据结构无关的访问，行之有效。</li><li>Composite</li><li>Iterator</li><li>Chain of Responsibility</li></ul><p>动机：</p><ul><li>某些情况下，客户代码过多依赖于对象容器复杂的内部实现结构，对象容器内部实现结构（而非抽象接口）的变化将引起客户代码的频繁变化，带来了代码的维护性、扩展性弊端。</li><li>如何将客户代码与复杂的对象容器结构解耦，让对象容器自己来实现自身的复杂结构，从而使客户代码就像简单对象一样来处理复杂的对象容器。</li></ul><p>模式定义：</p><ul><li>将对象组合成<strong>树形结构</strong>以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性（稳定）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Component()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span> :</span> <span class="keyword">public</span> Component&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">list</span>&lt;Component*&gt; elements;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Composite(<span class="keyword">const</span> <span class="built_in">string</span> &amp; s) : name(s) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Component* element)</span> </span>&#123;</span><br><span class="line">        elements.push_back(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component* element)</span></span>&#123;</span><br><span class="line">        elements.remove(element);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1. process current node      </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2. process leaf nodes</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : elements)</span><br><span class="line">            e-&gt;process(); <span class="comment">//多态调用,处理所有子节点process</span></span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//叶子节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> :</span> <span class="keyword">public</span> Component&#123;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Leaf(<span class="built_in">string</span> s) : name(s) &#123;&#125;</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//process current node</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Invoke</span><span class="params">(Component &amp; c)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    c.process();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Composite <span class="title">root</span><span class="params">(<span class="string">"root"</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode1</span><span class="params">(<span class="string">"treeNode1"</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode2</span><span class="params">(<span class="string">"treeNode2"</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode3</span><span class="params">(<span class="string">"treeNode3"</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode4</span><span class="params">(<span class="string">"treeNode4"</span>)</span></span>;</span><br><span class="line">    <span class="function">Leaf <span class="title">leat1</span><span class="params">(<span class="string">"left1"</span>)</span></span>;</span><br><span class="line">    <span class="function">Leaf <span class="title">leat2</span><span class="params">(<span class="string">"left2"</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    root.add(&amp;treeNode1);</span><br><span class="line">    treeNode1.add(&amp;treeNode2);</span><br><span class="line">    treeNode2.add(&amp;leaf1);</span><br><span class="line">    </span><br><span class="line">    root.add(&amp;treeNode3);</span><br><span class="line">    treeNode3.add(&amp;treeNode4);</span><br><span class="line">    treeNode4.add(&amp;leaf2);</span><br><span class="line">    </span><br><span class="line">    process(root);</span><br><span class="line">    process(leaf2);</span><br><span class="line">    process(treeNode3);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://image.blissseven.top/18-11-18/93110774.jpg" alt></p><p>总结：</p><ul><li>Composite采用树形结构来实现普遍存在的对象容器，从而将<strong>一对多</strong>的关系转化为<strong>一对一</strong>的关系，使得客户代码可以<strong>一致</strong>的（复用）处理对象和对象容器，无需关心处理的时单个的对象，还是组合的对象容器。</li><li>将<strong>客户代码与复杂的对象容器结构</strong>解耦是composite的核心思想，解耦之后，客户代码将<strong>与纯粹的抽象接口</strong>-而非对象容器的内部实现结构-发生依赖，从而更能应对变化</li><li>Composite模式在具体实现中，可以让父对象中的子对象方向追溯，如果父对象有频繁的遍历要求可使用缓存技巧来改善效率。</li></ul><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ul><li>数据结构模式</li></ul><p>动机：</p><ul><li>软件构件过程中，集合对象内部结构常常变化各异。但对于这些集合对象，希望在不暴漏其内部结构的同时，可以让外部客户代码透明的访问其中的元素；同时这种透明遍历也为同一种算法在多种集合对象上进行操作提供了可能。</li><li>使用面向对象技术将这种遍历机制抽象为“迭代器对象”为“应对变化中的集合对象”提供了一种优雅的方式。</li></ul><p>模式定义：</p><ul><li>提供一种方法顺序访问一个聚合对象中的元素，而又不暴漏（稳定）该对象的内部表示</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目前已经过时,虚函数，运行时依赖调用成本大，STL中iterator 泛型编程运行时依赖</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">isDone</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">current</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCollection</span>&#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    Iterator&lt;T&gt; GetIterator()&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionIterator</span> :</span> <span class="keyword">public</span> Iterator&lt;T&gt;&#123;</span><br><span class="line">    MyCollection&lt;T&gt; mc;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    CollectionIterator(<span class="keyword">const</span> MyCollection&lt;T&gt; &amp; c): mc(c)&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">first</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isDone</span><span class="params">()</span> <span class="keyword">const</span> override</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T&amp; <span class="title">current</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyAlgorithm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyCollection&lt;<span class="keyword">int</span>&gt; mc;</span><br><span class="line">    </span><br><span class="line">    Iterator&lt;<span class="keyword">int</span>&gt; iter= mc.GetIterator();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (iter.first(); !iter.isDone(); iter.next())&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter.current() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://image.blissseven.top/18-11-18/492691.jpg" alt></p><p>总结：</p><ul><li>迭代对象：访问一个聚合对象的内容，而无需暴漏它的内部表示</li><li>迭代多态：为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作</li><li>迭代器的健壮性考虑：遍历的同时更改迭代器所在的集合结构，会导致问题</li></ul><h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2><p>动机：</p><ul><li>在软件构建过程中，一个请求可能被多个对象处理，但是每个请求在运行时只能由一个接受者，如果显示指定，将不可避免的带来请求发送者与接受者的紧耦合</li><li>如何使请求的发送者不需要指定具体的接受者？让请求的接受者自己在运行时决定来处理请求，从而使二者解耦。</li></ul><p>模式定义：</p><ul><li>使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系，将这些对象连成<strong>一条链</strong>，并<strong>沿着这条链传递请求</strong>，直到有一个对象处理完为止。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    REQ_HANDLER1,</span><br><span class="line">    REQ_HANDLER2,</span><br><span class="line">    REQ_HANDLER3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reqest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> description;</span><br><span class="line">    RequestType reqType;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Reqest(<span class="keyword">const</span> <span class="built_in">string</span> &amp; desc, RequestType type) : description(desc), reqType(type) &#123;&#125;</span><br><span class="line">    <span class="function">RequestType <span class="title">getReqType</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> reqType; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">getDescription</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> description; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChainHandler</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">    ChainHandler *nextChain;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendReqestToNextHandler</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nextChain != <span class="literal">nullptr</span>)</span><br><span class="line">            nextChain-&gt;handle(req);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">canHandleRequest</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ChainHandler() &#123; nextChain = <span class="literal">nullptr</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setNextChain</span><span class="params">(ChainHandler *next)</span> </span>&#123; nextChain = next; &#125;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (canHandleRequest(req))</span><br><span class="line">            processRequest(req);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sendReqestToNextHandler(req);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler1</span> :</span> <span class="keyword">public</span> ChainHandler&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canHandleRequest</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> req.getReqType() == RequestType::REQ_HANDLER1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Handler1 is handle reqest: "</span> &lt;&lt; req.getDescription() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler2</span> :</span> <span class="keyword">public</span> ChainHandler&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canHandleRequest</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> req.getReqType() == RequestType::REQ_HANDLER2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Handler2 is handle reqest: "</span> &lt;&lt; req.getDescription() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler3</span> :</span> <span class="keyword">public</span> ChainHandler&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canHandleRequest</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> req.getReqType() == RequestType::REQ_HANDLER3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Handler3 is handle reqest: "</span> &lt;&lt; req.getDescription() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Handler1 h1;</span><br><span class="line">    Handler2 h2;</span><br><span class="line">    Handler3 h3;</span><br><span class="line">    h1.setNextChain(&amp;h2);</span><br><span class="line">    h2.setNextChain(&amp;h3);</span><br><span class="line">    </span><br><span class="line">    <span class="function">Reqest <span class="title">req</span><span class="params">(<span class="string">"process task ... "</span>, RequestType::REQ_HANDLER3)</span></span>;</span><br><span class="line">    h1.handle(req);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://image.blissseven.top/18-11-18/68784029.jpg" alt></p><p>总结：</p><ul><li>应用场合在于“<strong>一个请求可能有多个接受者，但是最后真正的接受者只有一个</strong>”，这时候请求发送者与接受者的耦合有可能出现“变化脆弱”的症状，职责链的目的就是将二者解耦</li><li>应用职责链之后，对象的<strong>职责分派</strong>将更具灵活性，可以在<strong>运行时动态添加/修改请求</strong>的处理指责</li><li>如果请求传递到职责链的末尾得不到处理，应该有一个合理的<strong>缺省机制</strong>，这也是每一个接受对象的责任，而不是发出请求的对象的责任。</li></ul><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>行为变化模式：</p><ul><li>组件行为的变化经常导致组建本身剧烈变化。将组件的行为和组建本身进行解耦，从而支持组建行为的变化，实现两者之间的松耦合</li><li>Command</li><li>Visitor</li></ul><p>动机：</p><ul><li>软件构建过程中，“行为请求者”和行为实现者通常呈现一种紧耦合，但在某些场合，比如需要对行为进行“记录、撤销/重(undo/redo) 事务”等处理，这种无法抵御变化的紧耦合不合适</li><li>如何将行为请求者与行为实现者解耦？将一组行为抽象为对象，实现两者之间的松耦合。</li></ul><p>模式定义：</p><ul><li>将请求封装为对象，从而使的用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Command</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand1</span> :</span> <span class="keyword">public</span> Command</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> arg;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ConcreteCommand1(<span class="keyword">const</span> <span class="built_in">string</span> &amp; a) : arg(a) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"#1 process..."</span>&lt;&lt;arg&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand2</span> :</span> <span class="keyword">public</span> Command</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> arg;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ConcreteCommand2(<span class="keyword">const</span> <span class="built_in">string</span> &amp; a) : arg(a) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"#2 process..."</span>&lt;&lt;arg&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MacroCommand</span> :</span> <span class="keyword">public</span> Command</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Command*&gt; commands;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addCommand</span><span class="params">(Command *c)</span> </span>&#123; commands.push_back(c); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : commands)</span><br><span class="line">        &#123;</span><br><span class="line">            c-&gt;execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">ConcreteCommand1 <span class="title">command1</span><span class="params">(receiver, <span class="string">"Arg ###"</span>)</span></span>;</span><br><span class="line">    <span class="function">ConcreteCommand2 <span class="title">command2</span><span class="params">(receiver, <span class="string">"Arg $$$"</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    MacroCommand macro;</span><br><span class="line">    macro.addCommand(&amp;command1);</span><br><span class="line">    macro.addCommand(&amp;command2);</span><br><span class="line">    </span><br><span class="line">    macro.execute();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://image.blissseven.top/18-11-18/82576378.jpg" alt></p><p>总结：</p><ul><li><img src="http://image.blissseven.top/18-11-18/47847845.jpg" alt></li><li>在其他语言应用广泛 JAVA，泛型编程已经更好的解决了。</li></ul><h2 id="Visitor-访问模式"><a href="#Visitor-访问模式" class="headerlink" title="Visitor 访问模式"></a>Visitor 访问模式</h2><p>动机：</p><ul><li>由于需求的变化，某些类层次的结构中常常需要添加新的行为（方法），如果直接在基类中修改，常常给子类带来繁重的变更负担，违背扩展封闭原则</li><li>如何在不更改类层次结构的前提下，在运行时根据需要透明的为类层次结构上的各个类动态添加新的操作，从而避免上述问题</li></ul><p>已经开发完成的情况下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Visitor</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor&amp; visitor)</span> </span>= <span class="number">0</span>; <span class="comment">//第一次多态辨析</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~Element()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElementA</span> :</span> <span class="keyword">public</span> Element</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor &amp;visitor)</span> override </span>&#123;</span><br><span class="line">        visitor.visitElementA(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElementB</span> :</span> <span class="keyword">public</span> Element</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor &amp;visitor)</span> override </span>&#123;</span><br><span class="line">        visitor.visitElementB(*<span class="keyword">this</span>); <span class="comment">//第二次多态辨析</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Visitor</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">visitElementA</span><span class="params">(ElementA&amp; element)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">visitElementB</span><span class="params">(ElementB&amp; element)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~Visitor()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//==================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Visitor1</span> :</span> <span class="keyword">public</span> Visitor&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visitElementA</span><span class="params">(ElementA&amp; element)</span> override</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Visitor1 is processing ElementA"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visitElementB</span><span class="params">(ElementB&amp; element)</span> override</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Visitor1 is processing ElementB"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">     </span><br><span class="line"><span class="comment">//扩展2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Visitor2</span> :</span> <span class="keyword">public</span> Visitor&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visitElementA</span><span class="params">(ElementA&amp; element)</span> override</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Visitor2 is processing ElementA"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visitElementB</span><span class="params">(ElementB&amp; element)</span> override</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Visitor2 is processing ElementB"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Visitor2 visitor;</span><br><span class="line">    ElementB elementB;</span><br><span class="line">    elementB.accept(visitor);<span class="comment">// double dispatch</span></span><br><span class="line">    </span><br><span class="line">    ElementA elementA;</span><br><span class="line">    elementA.accept(visitor);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模式定义：</p><ul><li>表示一个作用于某对象结构（Element/ElementA/ElementB）中的各元素的操作。使得可以在不改变（稳定）各元素的类的前提下定义（扩展）作用于这些元素的新操作（变化）。isitor</li></ul><p>Visitor===Visitor</p><p>ConcreteVisitor1===Visitor1</p><p>Visitor 需要知道Element子类的个数，具体类型，常常满足不了，就不能用</p><p><img src="http://image.blissseven.top/18-11-18/91630033.jpg" alt></p><p>总结：</p><ul><li><p>Visitor通过双重分发（double dispatch）实现在不更改（不添加新的操作-编译时）Element类层次结构的前提下，在运行时透明的为类层次结构上的各个类动态添加新的操作（支持变化）</p></li><li><p>双重分发即Visitor模式中间包括两个多态分发（多态机制）：第一个为acccept方法的多态解析，第二个为visitElementX方法的多态辨析</p></li><li><p>最大缺点在于扩展类层次结构（增加新的Element子类），会导致Visitor类的改变，因此，Visitor模式适用于<strong>Element类层次结构稳定</strong>，而其中的<strong>操作却经常改动</strong>的情形。</p></li></ul><h2 id="Interpreter解析器"><a href="#Interpreter解析器" class="headerlink" title="Interpreter解析器"></a>Interpreter解析器</h2><p>领域规则模式：</p><ul><li>某些变化虽然频繁，可以抽象为规则。结合特定领域，将问题抽象为语法规则，从而给出在该领域下的一般性解决方案</li></ul><p><img src="http://image.blissseven.top/18-11-18/8874139.jpg" alt></p><p><img src="http://image.blissseven.top/18-11-18/38064604.jpg" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Expression</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; var)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Expression()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//变量表达式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VarExpression</span>:</span> <span class="keyword">public</span> Expression &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> key;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    VarExpression(<span class="keyword">const</span> <span class="keyword">char</span>&amp; key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;key = key;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; var)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var[key];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//符号表达式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SymbolExpression</span> :</span> <span class="keyword">public</span> Expression &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 运算符左右两个参数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Expression* left;</span><br><span class="line">    Expression* right;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SymbolExpression( Expression* left,  Expression* right):</span><br><span class="line">        left(left),right(right)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法运算</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddExpression</span> :</span> <span class="keyword">public</span> SymbolExpression &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AddExpression(Expression* left, Expression* right):</span><br><span class="line">        SymbolExpression(left,right)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; var)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left-&gt;interpreter(var) + right-&gt;interpreter(var);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法运算</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubExpression</span> :</span> <span class="keyword">public</span> SymbolExpression &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SubExpression(Expression* left, Expression* right):</span><br><span class="line">        SymbolExpression(left,right)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; var)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left-&gt;interpreter(var) - right-&gt;interpreter(var);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Expression*  <span class="title">analyse</span><span class="params">(<span class="built_in">string</span> expStr)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">stack</span>&lt;Expression*&gt; expStack;</span><br><span class="line">    Expression* left = <span class="literal">nullptr</span>;</span><br><span class="line">    Expression* right = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;expStr.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(expStr[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                <span class="comment">// 加法运算</span></span><br><span class="line">                left = expStack.top();</span><br><span class="line">                right = <span class="keyword">new</span> VarExpression(expStr[++i]);</span><br><span class="line">                expStack.push(<span class="keyword">new</span> AddExpression(left, right));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                <span class="comment">// 减法运算</span></span><br><span class="line">                left = expStack.top();</span><br><span class="line">                right = <span class="keyword">new</span> VarExpression(expStr[++i]);</span><br><span class="line">                expStack.push(<span class="keyword">new</span> SubExpression(left, right));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 变量表达式</span></span><br><span class="line">                expStack.push(<span class="keyword">new</span> VarExpression(expStr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    Expression* expression = expStack.top();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> expression;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(Expression* expression)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放表达式树的节点内存...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> expStr = <span class="string">"a+b-c+d-e"</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; var;</span><br><span class="line">    var.insert(make_pair(<span class="string">'a'</span>,<span class="number">5</span>));</span><br><span class="line">    var.insert(make_pair(<span class="string">'b'</span>,<span class="number">2</span>));</span><br><span class="line">    var.insert(make_pair(<span class="string">'c'</span>,<span class="number">1</span>));</span><br><span class="line">    var.insert(make_pair(<span class="string">'d'</span>,<span class="number">6</span>));</span><br><span class="line">    var.insert(make_pair(<span class="string">'e'</span>,<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    Expression* expression= analyse(expStr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> result=expression-&gt;interpreter(var);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;result&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    release(expression);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模式定义：</p><ul><li>给定一个语言，定义它的文法表示，并定义一种解释器，解释语言中的句子</li></ul><p><img src="http://image.blissseven.top/18-11-18/50101092.jpg" alt></p><p><img src="http://image.blissseven.top/18-11-18/13480502.jpg" alt></p><h2 id="设计模式总结"><a href="#设计模式总结" class="headerlink" title="设计模式总结"></a>设计模式总结</h2><p>管理变化，提高复用</p><ul><li>依赖倒置原则 DIP</li><li>开放封闭原则 OCP</li><li>单一职责原则SRP</li><li>ListKov替换原则LSP</li><li>接口隔离模式ISP</li><li>对象组合优于类继承</li><li>封装变化点</li><li>面向接口编程</li></ul><p><img src="http://image.blissseven.top/18-11-18/72718461.jpg" alt></p><p><img src="http://image.blissseven.top/18-11-18/8024704.jpg" alt></p><p><img src="http://image.blissseven.top/18-11-18/73601087.jpg" alt></p><p><img src="http://image.blissseven.top/18-11-18/40617606.jpg" alt></p><p><img src="http://image.blissseven.top/18-11-18/197055.jpg" alt></p><p><img src="http://image.blissseven.top/18-11-18/93328063.jpg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> design pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL_note</title>
      <link href="/2018/11/08/STL-note/"/>
      <url>/2018/11/08/STL-note/</url>
      
        <content type="html"><![CDATA[<ul><li>STL中容器、分配器、算法、仿函数、适配器、迭代器底层实现</li><li>STL源码剖析</li></ul><a id="more"></a><p>[TOC]</p><h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="headers-版本，资源"><a href="#headers-版本，资源" class="headerlink" title="headers,版本，资源"></a>headers,版本，资源</h2><ul><li><p>c++ standard library</p><ul><li>以header 文件实现</li><li>包括standard template library</li></ul></li><li><p>standard template library</p><ul><li>六大部件</li></ul></li><li><p>cplusplus.com</p></li><li><p>cppreference.com</p></li><li><p>gcc.gnu.org</p></li><li><p>《The C++ STANDARD LIBRARY》 &amp; 《STL 源码剖析》</p></li></ul><h2 id="STL-体系结构"><a href="#STL-体系结构" class="headerlink" title="STL 体系结构"></a>STL 体系结构</h2><ul><li><p>容器</p></li><li><p>分配器</p></li><li><p>算法</p></li><li><p>迭代器</p></li><li><p>适配器</p></li><li><p>仿函数</p><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwnu4q6r85j20ez0axq6x.jpg" alt></p><p>vector 放东西，分配器提供内存支持，算法提供函数支持，迭代器提供算法的输入，仿函数一种函数，适配器对容器，仿函数，迭代器做转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="comment">//allocator</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ia[<span class="number">6</span>]=&#123;<span class="number">27</span>,<span class="number">210</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>,allocator&lt;<span class="keyword">int</span>&gt;&gt; vi(ia,ia+<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;count_if(vi.begin(),vi.end(),not1(bind2nd(less&lt;<span class="keyword">int</span>&gt;(),<span class="number">40</span>)));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度：n 要很大,查网站</p><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwnuqk9wmxj20ax07zq5g.jpg" alt></p></li></ul><h3 id="前闭后开区间"><a href="#前闭后开区间" class="headerlink" title="前闭后开区间"></a>前闭后开区间</h3><p>c.end最后一个元素的下一个位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//container 遍历</span></span><br><span class="line">Container &lt;T&gt; c;</span><br><span class="line">....</span><br><span class="line">Container&lt;T&gt;::iterator ite=c.begin();</span><br><span class="line"><span class="keyword">for</span>(;ite!=c.end();++ite)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><strong>c++11 range based for statement</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i:&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> elem: vec)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;elem;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; elem: vec)</span><br><span class="line">&#123;</span><br><span class="line">  elem*=<span class="number">3</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; c;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator ite;</span><br><span class="line">ite=::find(c.begin(),c.end(),target);</span><br><span class="line"><span class="comment">////</span></span><br><span class="line"><span class="keyword">auto</span> ite=::find(c.begin(),c.end(),target);</span><br></pre></td></tr></table></figure><h2 id="容器分类和测试"><a href="#容器分类和测试" class="headerlink" title="容器分类和测试"></a>容器分类和测试</h2><h3 id="容器结构与分类"><a href="#容器结构与分类" class="headerlink" title="容器结构与分类"></a>容器结构与分类</h3><table><thead><tr><th>vector</th><th>push_back</th><th>尾部 插入元素</th></tr></thead><tbody><tr><td></td><td>pop_back</td><td>弹出最后一个元素</td></tr><tr><td></td><td>begin</td><td>指向第一个元素的迭代器</td></tr><tr><td></td><td>end</td><td>指向最后一个元素下一个的迭代器</td></tr><tr><td></td><td>size</td><td>元素个数</td></tr><tr><td></td><td>max_size</td><td>最大容量</td></tr><tr><td></td><td>capacity</td><td>当前开辟空间大小</td></tr><tr><td></td><td>empty</td><td>是否为空</td></tr><tr><td></td><td>front</td><td>第一个元素的引用</td></tr><tr><td></td><td>back</td><td>最后一个元素的引用</td></tr><tr><td></td><td>data</td><td>容器元素首地址，为指针</td></tr><tr><td></td><td>clear</td><td>清空容器</td></tr><tr><td></td><td>at</td><td></td></tr></tbody></table><table><thead><tr><th>list</th><th>push_back</th><th></th></tr></thead><tbody><tr><td></td><td>pop_back</td><td></td></tr><tr><td></td><td>push_front</td><td></td></tr><tr><td></td><td>pop_front</td><td></td></tr><tr><td></td><td>begin</td><td></td></tr><tr><td></td><td>end</td><td></td></tr><tr><td></td><td>size</td><td></td></tr><tr><td></td><td>max_size</td><td></td></tr><tr><td></td><td>front</td><td></td></tr><tr><td></td><td>back</td><td></td></tr><tr><td></td><td><strong>c.sort</strong></td><td></td></tr></tbody></table><table><thead><tr><th>deque</th><th>push_back</th><th></th></tr></thead><tbody><tr><td></td><td>push_front</td><td></td></tr><tr><td></td><td>pop_back</td><td></td></tr><tr><td></td><td>pop_front</td><td></td></tr><tr><td></td><td>begin</td><td></td></tr><tr><td></td><td>end</td><td></td></tr><tr><td></td><td>size</td><td></td></tr><tr><td></td><td>max_size</td><td></td></tr><tr><td></td><td>front</td><td></td></tr><tr><td></td><td>back</td><td></td></tr><tr><td></td><td>at</td><td></td></tr><tr><td></td><td>operator[]</td><td></td></tr></tbody></table><table><thead><tr><th>set</th><th>insert</th><th></th></tr></thead><tbody><tr><td></td><td>clear</td><td>清空set</td></tr><tr><td></td><td>erase</td><td>删除某一迭代器指定元素，两个迭代器之间的元素，和key值相等的元素</td></tr><tr><td></td><td>c.find</td><td></td></tr><tr><td></td><td>count</td><td></td></tr><tr><td></td><td>lower_bound</td><td>Returns an iterator pointing to the first element that is not less than key</td></tr><tr><td></td><td>upper_bound</td><td></td></tr><tr><td></td><td>contains</td><td></td></tr></tbody></table><table><thead><tr><th>map</th><th>insert</th><th></th></tr></thead><tbody><tr><td></td><td>at</td><td>access specified element with bounds checking</td></tr><tr><td></td><td>operator[]</td><td>access or insert specified element</td></tr><tr><td></td><td>empty</td><td></td></tr><tr><td></td><td>size</td><td></td></tr><tr><td></td><td>max_size</td><td></td></tr><tr><td></td><td>clear</td><td></td></tr><tr><td></td><td>erase</td><td></td></tr><tr><td></td><td>c.find</td><td></td></tr></tbody></table><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwnvkxs7yvj20ny0cjaco.jpg" alt></p><ul><li>Sequence container<ul><li>Array,固定size</li><li>Vector可以自动增长，分配器设置</li><li>Deque两端可进可出</li><li>List</li><li>Forward-List</li></ul></li><li>Associative container(大量查找)<ul><li>Set,底层红黑树，Multiset,值可重复</li><li>Map，底层红黑树，Multimap，值可重复</li></ul></li><li>Unordered containers (<strong>c++11</strong>)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> bliss_test_array&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test_array</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;"test array start ...."&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">array</span> &lt;<span class="keyword">long</span>,ASIZE&gt; c;</span><br><span class="line">        <span class="keyword">clock_t</span> timestart=clock();</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>;i&lt;ASIZE;i++)</span><br><span class="line">            c[i]=rand()%ASIZE;<span class="comment">//0-(ASIZE-1)</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"clock-timestart "</span>&lt;&lt;(clock()-timestart)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"size: "</span>&lt;&lt;c.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"front "</span>&lt;&lt;c.front()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"back "</span>&lt;&lt;c.back()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"data "</span>&lt;&lt;c.data()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">long</span> target=get_a_target_long();</span><br><span class="line">        timestart=clock();</span><br><span class="line">        qsort(c.data(),ASIZE,<span class="keyword">sizeof</span>(<span class="keyword">long</span>),compareLongs);</span><br><span class="line">        <span class="keyword">long</span>* pitem=(<span class="keyword">long</span>*)bsearch(&amp;target,(c.data()),ASIZE,<span class="keyword">sizeof</span>(<span class="keyword">long</span>),compareLongs);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"cost time: "</span>&lt;&lt;clock()-timestart&lt;&lt;<span class="string">" ms"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(pitem!=<span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"found, "</span>&lt;&lt;*pitem&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"not found \n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vector-test"><a href="#vector-test" class="headerlink" title="vector test"></a>vector test</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vector</span></span><br><span class="line"><span class="keyword">namespace</span> bliss_test_vector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test_vector</span><span class="params">(<span class="keyword">long</span>&amp; value)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"\n test vector start ,,,\n"</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; c;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">clock_t</span> timestart=clock();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>;i&lt;value;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="built_in">snprintf</span>(buf,<span class="number">10</span>,<span class="string">"%d"</span>,rand()%ASIZE);</span><br><span class="line">                c.push_back(buf);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(exception&amp; p)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"i: "</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>&lt;&lt;p.what()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">abort</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"cost time: "</span>&lt;&lt;clock()-timestart&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"size: "</span>&lt;&lt;c.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"front: "</span>&lt;&lt;c.front()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"back: "</span>&lt;&lt;c.back()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"data: "</span>&lt;&lt;c.data()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"capacity: "</span>&lt;&lt;c.capacity()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">string</span> target=get_a_target_string();</span><br><span class="line">        &#123;</span><br><span class="line">            timestart=clock();</span><br><span class="line">            <span class="keyword">auto</span> pitem=::find(c.begin(),c.end(),target);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"find cost time ms "</span>&lt;&lt;clock()-timestart&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(pitem!=c.end())</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"found, is "</span>&lt;&lt;*pitem&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"not found "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            timestart=clock();</span><br><span class="line">            sort(c.begin(),c.end());</span><br><span class="line">            <span class="built_in">string</span>* pitem=(<span class="built_in">string</span>*)bsearch(&amp;target,c.data(),c.size(),<span class="keyword">sizeof</span>(<span class="built_in">string</span>),compareStrings);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"sort+bsearch cost time ms "</span>&lt;&lt;clock()-timestart&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(pitem!=<span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"found, is "</span>&lt;&lt;*pitem&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"not found "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vector 内存增长方式为两倍增长,</p><p>假如c1已有2个元素，插入第三个时，vector扩展为4个，找到4个连续的空间，把前两个复制过去，把第三个填进去。</p><p>list 一个萝卜一个坑</p><h3 id="list-test"><a href="#list-test" class="headerlink" title="list  test"></a>list  test</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//list test</span></span><br><span class="line"><span class="keyword">namespace</span> bliss_test_list</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test_list</span><span class="params">(<span class="keyword">long</span>&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"\n test list start"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">list</span> &lt;<span class="built_in">string</span>&gt; c;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">clock_t</span> timestart=clock();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>;i&lt;value;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf,<span class="number">10</span>,<span class="string">"%d"</span>,rand()%value);</span><br><span class="line">            c.push_back(<span class="built_in">string</span>(buf));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(exception&amp; p)&#123;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">"i "</span>&lt;&lt;i&lt;&lt;<span class="string">"  "</span>&lt;&lt;p.what()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="built_in">abort</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"list cost time: "</span>&lt;&lt;clock()-timestart&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"list size "</span>&lt;&lt;c.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"list max_size "</span>&lt;&lt;c.max_size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"list front "</span>&lt;&lt;c.front()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"list back "</span>&lt;&lt;c.back()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">string</span> target=get_a_target_string();</span><br><span class="line">        &#123;</span><br><span class="line">            timestart=clock();</span><br><span class="line">            <span class="keyword">auto</span> pitem=::find(c.begin(),c.end(),target);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"list find cost time ms "</span>&lt;&lt;clock()-timestart&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(pitem!=c.end())</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"list found, is "</span>&lt;&lt;*pitem&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"list not found "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            timestart=clock();</span><br><span class="line">            c.sort();</span><br><span class="line">            <span class="comment">//qsort(c.data(),value,sizeof(string),compareStrings);</span></span><br><span class="line">            <span class="keyword">clock_t</span> timestart2=clock();</span><br><span class="line">            <span class="comment">//string* pitem=(string*)bsearch(&amp;target,c.data(),c.size(),sizeof(string),compareStrings);</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"list c.sort+bsearch cost time ms "</span>&lt;&lt;clock()-timestart&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;"c.sot cost time : "&lt;&lt;timestart2-timestart&lt;&lt;"\n ratio: "&lt;&lt;(timestart2-timestart)*1.0/(clock()-timestart)&lt;&lt;endl;</span></span><br><span class="line">           <span class="comment">// if(pitem!=NULL)</span></span><br><span class="line">            <span class="comment">//    cout&lt;&lt;"found, is "&lt;&lt;*pitem&lt;&lt;endl;</span></span><br><span class="line">           <span class="comment">// else</span></span><br><span class="line">            <span class="comment">//    cout&lt;&lt;"not found "&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="deque-test"><a href="#deque-test" class="headerlink" title="deque test"></a>deque test</h3><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwo719ghfyj20g70a7782.jpg" alt></p><p>一行一个buffer，分段连续，每一个buffer连续，不同buff虚连续，每次扩充一个buffer，如果往右插，插满，右扩一个buffer，左边类似。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//deque</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> bliss_test_deque</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test_deque</span><span class="params">(<span class="keyword">long</span>&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"\n test deque start"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">deque</span> &lt;<span class="built_in">string</span>&gt; c;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">clock_t</span> timestart=clock();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>;i&lt;value;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf,<span class="number">10</span>,<span class="string">"%d"</span>,rand()%value);</span><br><span class="line">            c.push_back(<span class="built_in">string</span>(buf));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(exception&amp; p)&#123;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">"i "</span>&lt;&lt;i&lt;&lt;<span class="string">"  "</span>&lt;&lt;p.what()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="built_in">abort</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"deque cost time: "</span>&lt;&lt;clock()-timestart&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"deque size "</span>&lt;&lt;c.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"deque max_size "</span>&lt;&lt;c.max_size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"deque front "</span>&lt;&lt;c.front()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"deque back "</span>&lt;&lt;c.back()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">string</span> target=get_a_target_string();</span><br><span class="line">        &#123;</span><br><span class="line">            timestart=clock();</span><br><span class="line">            <span class="keyword">auto</span> pitem=::find(c.begin(),c.end(),target);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"deque find cost time ms "</span>&lt;&lt;clock()-timestart&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(pitem!=c.end())</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"deque found, is "</span>&lt;&lt;*pitem&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"deque not found "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            timestart=clock();</span><br><span class="line">            ::sort(c.begin(),c.end());</span><br><span class="line">            <span class="comment">//qsort(c.data(),value,sizeof(string),compareStrings);</span></span><br><span class="line">            <span class="keyword">clock_t</span> timestart2=clock();</span><br><span class="line">            <span class="comment">//string* pitem=(string*)bsearch(&amp;target,c.data(),c.size(),sizeof(string),compareStrings);</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"deque c.sort+bsearch cost time ms "</span>&lt;&lt;clock()-timestart&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;"c.sot cost time : "&lt;&lt;timestart2-timestart&lt;&lt;"\n ratio: "&lt;&lt;(timestart2-timestart)*1.0/(clock()-timestart)&lt;&lt;endl;</span></span><br><span class="line">           <span class="comment">// if(pitem!=NULL)</span></span><br><span class="line">            <span class="comment">//    cout&lt;&lt;"found, is "&lt;&lt;*pitem&lt;&lt;endl;</span></span><br><span class="line">           <span class="comment">// else</span></span><br><span class="line">            <span class="comment">//    cout&lt;&lt;"not found "&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="stack-test"><a href="#stack-test" class="headerlink" title="stack test"></a>stack test</h3><p>stack 先进后出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> bliss_test_stack</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test_stack</span><span class="params">(<span class="keyword">long</span>&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"\n test stack start"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">stack</span> &lt;<span class="built_in">string</span>&gt; c;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">clock_t</span> timestart=clock();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>;i&lt;value;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf,<span class="number">10</span>,<span class="string">"%d"</span>,rand()%value);</span><br><span class="line">            c.push(<span class="built_in">string</span>(buf));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(exception&amp; p)&#123;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">"i "</span>&lt;&lt;i&lt;&lt;<span class="string">"  "</span>&lt;&lt;p.what()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="built_in">abort</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"stack cost time: "</span>&lt;&lt;clock()-timestart&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"stack size "</span>&lt;&lt;c.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"stack top "</span>&lt;&lt;c.top()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"stack pop "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        c.pop();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"stack size "</span>&lt;&lt;c.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"stack top "</span>&lt;&lt;c.top()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;"deque max_size "&lt;&lt;c.max_size()&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">//cout&lt;&lt;"deque front "&lt;&lt;c.front()&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">//cout&lt;&lt;"deque back "&lt;&lt;c.back()&lt;&lt;endl;</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>stack 和queue 不提供 iterator 函数。</p><p>没有讲find函数？？,找到后返回一个iterator</p><h3 id="queue-test"><a href="#queue-test" class="headerlink" title="queue test"></a>queue test</h3><ul><li>先进先出</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> bliss_test_queue</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test_queue</span><span class="params">(<span class="keyword">long</span>&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"\n test queue start"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">queue</span> &lt;<span class="built_in">string</span>&gt; c;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">clock_t</span> timestart=clock();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>;i&lt;value;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf,<span class="number">10</span>,<span class="string">"%d"</span>,rand()%value);</span><br><span class="line">            c.push(<span class="built_in">string</span>(buf));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(exception&amp; p)&#123;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">"i "</span>&lt;&lt;i&lt;&lt;<span class="string">"  "</span>&lt;&lt;p.what()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="built_in">abort</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"queue cost time: "</span>&lt;&lt;clock()-timestart&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"queue size "</span>&lt;&lt;c.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"queue front "</span>&lt;&lt;c.front()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"queue back "</span>&lt;&lt;c.back()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"queue pop "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        c.pop();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"queue size "</span>&lt;&lt;c.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"queue front "</span>&lt;&lt;c.front()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"queue back "</span>&lt;&lt;c.back()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;"deque max_size "&lt;&lt;c.max_size()&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">//cout&lt;&lt;"deque front "&lt;&lt;c.front()&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">//cout&lt;&lt;"deque back "&lt;&lt;c.back()&lt;&lt;endl;</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="multiset-test"><a href="#multiset-test" class="headerlink" title="multiset test"></a>multiset test</h3><ul><li>insert时，已排好序</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> bliss_test_multiset</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test_multiset</span><span class="params">(<span class="keyword">long</span>&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"\n test multiset start"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">multiset</span> &lt;<span class="built_in">string</span>&gt; c;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">clock_t</span> timestart=clock();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>;i&lt;value;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf,<span class="number">10</span>,<span class="string">"%d"</span>,rand()%value);</span><br><span class="line">            c.insert(<span class="built_in">string</span>(buf));   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(exception&amp; p)&#123;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">"i "</span>&lt;&lt;i&lt;&lt;<span class="string">"  "</span>&lt;&lt;p.what()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="built_in">abort</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"multiset cost time: "</span>&lt;&lt;clock()-timestart&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"multiset size "</span>&lt;&lt;c.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"multiset max_size "</span>&lt;&lt;c.max_size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">         <span class="built_in">string</span> target=get_a_target_string();</span><br><span class="line">        &#123;</span><br><span class="line">            timestart=clock();</span><br><span class="line">            <span class="keyword">auto</span> pitem=::find(c.begin(),c.end(),target);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"multiset find cost time ms "</span>&lt;&lt;clock()-timestart&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(pitem!=c.end())</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"multiset found, is "</span>&lt;&lt;*pitem&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"multiset not found "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"find cost time :"</span>&lt;&lt;clock()-timestart&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            timestart=clock();</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">auto</span> pitem=c.find(target);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"c.find cost time :"</span>&lt;&lt;clock()-timestart&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(pitem != c.end())</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"found "</span>&lt;&lt;*pitem&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"not found!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="multimap-test"><a href="#multimap-test" class="headerlink" title="multimap test"></a>multimap test</h3><p>multiset，multimap底层红黑树，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; //abort()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  //snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> bliss_test_multimap</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test_multimap</span><span class="params">(<span class="keyword">long</span> &amp;value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"test multimap start..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">multimap</span>&lt;<span class="keyword">long</span>,<span class="built_in">string</span>&gt; c;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">clock_t</span> timestart=clock();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>;i&lt;value;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="built_in">snprintf</span>(buf,<span class="number">10</span>,<span class="string">"%d"</span>,rand()%value);</span><br><span class="line">                c.insert(pair&lt;<span class="keyword">long</span>,<span class="built_in">string</span>&gt; (i,buf));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(exception&amp; p)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"i: "</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>&lt;&lt;p.what()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">abort</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"inset cost time "</span>&lt;&lt;clock()-timestart&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"multimap size "</span>&lt;&lt;c.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"multimap maxsize "</span>&lt;&lt;c.max_size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">long</span> target=get_a_target_long();</span><br><span class="line">        timestart=clock();</span><br><span class="line">        <span class="keyword">auto</span> pitem=c.find(target);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"c.find cost time "</span>&lt;&lt;clock()-timestart&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(pitem!=c.end())</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"find "</span>&lt;&lt;(*pitem).first&lt;&lt;<span class="string">" : "</span> &lt;&lt;(*pitem).second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"not found !"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unordered-multiset-test"><a href="#unordered-multiset-test" class="headerlink" title="unordered_multiset test"></a>unordered_multiset test</h3><p>seperated chaining  底层hashtable</p><p>bucket 一定比数据多</p><p>每一个bucket一定不太长，如果元素个数&gt;=bucket个数，这个bucket拆开。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> bliss_test_umultiset</span><br><span class="line">&#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">test_umultiset</span><span class="params">(<span class="keyword">long</span>&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"\n test unordered multiset start"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">unordered_multiset</span> &lt;<span class="built_in">string</span>&gt; c;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">clock_t</span> timestart=clock();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>;i&lt;value;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf,<span class="number">10</span>,<span class="string">"%d"</span>,rand()%value);</span><br><span class="line">            c.insert(<span class="built_in">string</span>(buf));   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(exception&amp; p)&#123;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">"i "</span>&lt;&lt;i&lt;&lt;<span class="string">"  "</span>&lt;&lt;p.what()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="built_in">abort</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"unordered multiset cost time: "</span>&lt;&lt;clock()-timestart&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"unorderedmultiset size "</span>&lt;&lt;c.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"unordered multiset max_size "</span>&lt;&lt;c.max_size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"unordered multiset c.bucket_count "</span>&lt;&lt;c.bucket_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"unordered multiset c.max_bucket_count "</span>&lt;&lt;c.max_bucket_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"unordered multiset c.load_factor "</span>&lt;&lt;c.load_factor()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"unordered multiset c.max_load_factor "</span>&lt;&lt;c.max_load_factor()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"bucket "</span>&lt;&lt;i&lt;&lt;<span class="string">" has "</span>&lt;&lt;c.bucket_size(i)&lt;&lt;<span class="string">" elements!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="built_in">string</span> target=get_a_target_string();</span><br><span class="line">        &#123;</span><br><span class="line">            timestart=clock();</span><br><span class="line">            <span class="keyword">auto</span> pitem=::find(c.begin(),c.end(),target);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"unordered multiset find cost time ms "</span>&lt;&lt;clock()-timestart&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(pitem!=c.end())</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"unordered multiset found, is "</span>&lt;&lt;*pitem&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"unordered multiset not found "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="comment">// cout&lt;&lt;"find cost time :"&lt;&lt;clock()-timestart&lt;&lt;endl;</span></span><br><span class="line">            timestart=clock();</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">auto</span> pitem=c.find(target);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"unordered multiset c.find cost time :"</span>&lt;&lt;clock()-timestart&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(pitem != c.end())</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"found "</span>&lt;&lt;*pitem&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"not found!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unordered-multimap-test"><a href="#unordered-multimap-test" class="headerlink" title="unordered_multimap test"></a>unordered_multimap test</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; //abort()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  //snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> bliss_test_umultimap</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test_umultimap</span><span class="params">(<span class="keyword">long</span> &amp;value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"test unordered multimap start..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">unordered_multimap</span>&lt;<span class="keyword">long</span>,<span class="built_in">string</span>&gt; c;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">clock_t</span> timestart=clock();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>;i&lt;value;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="built_in">snprintf</span>(buf,<span class="number">10</span>,<span class="string">"%d"</span>,rand()%value);</span><br><span class="line">                c.insert(pair&lt;<span class="keyword">long</span>,<span class="built_in">string</span>&gt; (i,buf));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(exception&amp; p)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"i: "</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>&lt;&lt;p.what()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">abort</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"unordered multimap inset cost time "</span>&lt;&lt;clock()-timestart&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"unordered multimap size "</span>&lt;&lt;c.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"unordered multimap maxsize "</span>&lt;&lt;c.max_size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">long</span> target=get_a_target_long();</span><br><span class="line">        timestart=clock();</span><br><span class="line">        <span class="keyword">auto</span> pitem=c.find(target);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"unordered multimap c.find cost time "</span>&lt;&lt;clock()-timestart&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(pitem!=c.end())</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"unordered multimap find "</span>&lt;&lt;(*pitem).first&lt;&lt;<span class="string">" : "</span> &lt;&lt;(*pitem).second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"unordered multimap not found !"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="set-test"><a href="#set-test" class="headerlink" title="set test"></a>set test</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> bliss_test_set&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test_set</span><span class="params">(<span class="keyword">long</span>&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"test set start .."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">set</span> &lt;<span class="built_in">string</span>&gt; c;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">clock_t</span> timestart=clock();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>;i&lt;value;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf,<span class="number">10</span>,<span class="string">"%d"</span>,rand()%value);</span><br><span class="line">            c.insert(buf);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(exception &amp; p)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"i: "</span>&lt;&lt;i&lt;&lt;p.what()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"set insert cost time : "</span>&lt;&lt;clock()-timestart&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"set size "</span>&lt;&lt;c.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">string</span> target=get_a_target_string();</span><br><span class="line">        &#123;</span><br><span class="line">            timestart=clock();</span><br><span class="line">            <span class="keyword">auto</span> pitem=::find(c.begin(),c.end(),target);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">".find cost time "</span>&lt;&lt;clock()-timestart&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(pitem!=c.end())</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"set find "</span>&lt;&lt;*pitem&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"not find !"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            timestart=clock();</span><br><span class="line">            <span class="keyword">auto</span> pitem=c.find(target);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"set c.find cost time "</span>&lt;&lt;clock()-timestart&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(pitem!= c.end())</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">" find "</span>&lt;&lt;*pitem&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"not find !"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="map-test"><a href="#map-test" class="headerlink" title="map test"></a>map test</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> bliss_test_map</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test_map</span><span class="params">(<span class="keyword">long</span>&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"test map start .."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">long</span>,<span class="built_in">string</span>&gt; c;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">clock_t</span> timestart=clock();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>;i&lt; value;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="built_in">snprintf</span>(buf,<span class="number">10</span>,<span class="string">"%d"</span>,rand()%value);</span><br><span class="line">                c[i]=<span class="built_in">string</span>(buf);<span class="comment">// key=,value= string(buf);</span></span><br><span class="line">            &#125;</span><br><span class="line">             <span class="keyword">catch</span>(exception &amp; p)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"i: "</span>&lt;&lt;i&lt;&lt;p.what()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"map insert cost time : "</span>&lt;&lt;clock()-timestart&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"map size "</span>&lt;&lt;c.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">long</span> target = get_a_target_long();</span><br><span class="line">        timestart = clock();</span><br><span class="line">        <span class="keyword">auto</span> pItem = c.find(target);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c.find(), milli-seconds : "</span> &lt;&lt; (clock()-timestart) &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">if</span> (pItem != c.end())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"found, value="</span> &lt;&lt; (*pItem).second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">        c.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hash_set -&gt; unordered set</p><p>hash_map -&gt; unordered map</p><p>hash_multiset -&gt; unordered multiset</p><p>hash_multimap -&gt; unordered multimap</p><h2 id="分配器测试"><a href="#分配器测试" class="headerlink" title="分配器测试"></a>分配器测试</h2><p>gnuc c 编译器</p><p>对vector 支持对内存的使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过容器使用分配器</span></span><br><span class="line"><span class="comment">//不能在 switch case 中宣告，只好下面這樣. //1000000次 </span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">string</span>, allocator&lt;<span class="built_in">string</span>&gt;&gt; c1;<span class="comment">//3140</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>, __gnu_cxx::malloc_allocator&lt;<span class="built_in">string</span>&gt;&gt; c2;  <span class="comment">//3110</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">string</span>, __gnu_cxx::new_allocator&lt;<span class="built_in">string</span>&gt;&gt; c3; <span class="comment">//3156</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>, __gnu_cxx::__pool_alloc&lt;<span class="built_in">string</span>&gt;&gt; c4;  <span class="comment">//4922</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>, __gnu_cxx::__mt_alloc&lt;<span class="built_in">string</span>&gt;&gt; c5; <span class="comment">//3297</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">string</span>, __gnu_cxx::bitmap_allocator&lt;<span class="built_in">string</span>&gt;&gt; c6;  <span class="comment">//4781 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span> : c1.push_back(<span class="built_in">string</span>(buf)); </span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span> : c2.push_back(<span class="built_in">string</span>(buf)); </span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span> : c3.push_back(<span class="built_in">string</span>(buf)); </span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span> : c4.push_back(<span class="built_in">string</span>(buf)); </span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span> : c5.push_back(<span class="built_in">string</span>(buf)); </span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span> : c6.push_back(<span class="built_in">string</span>(buf)); </span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//直接使用 分配器</span></span><br><span class="line"><span class="keyword">int</span>* p; </span><br><span class="line">    allocator&lt;<span class="keyword">int</span>&gt; alloc1;</span><br><span class="line">p = alloc1.allocate(<span class="number">1</span>);  <span class="comment">//要 1个</span></span><br><span class="line">alloc1.deallocate(p,<span class="number">1</span>); <span class="comment">//还1个</span></span><br><span class="line"></span><br><span class="line">__gnu_cxx::malloc_allocator&lt;<span class="keyword">int</span>&gt; alloc2;  </span><br><span class="line">p = alloc2.allocate(<span class="number">1</span>);  </span><br><span class="line">alloc2.deallocate(p,<span class="number">1</span>);  </span><br><span class="line"></span><br><span class="line">    __gnu_cxx::new_allocator&lt;<span class="keyword">int</span>&gt; alloc3; </span><br><span class="line">p = alloc3.allocate(<span class="number">1</span>);  </span><br><span class="line">alloc3.deallocate(p,<span class="number">1</span>); </span><br><span class="line"></span><br><span class="line">__gnu_cxx::__pool_alloc&lt;<span class="keyword">int</span>&gt; alloc4;  </span><br><span class="line">p = alloc4.allocate(<span class="number">2</span>);  </span><br><span class="line">alloc4.deallocate(p,<span class="number">2</span>); <span class="comment">//我刻意令參數為 2, 但這有何意義!! 一次要 2 個 ints? </span></span><br><span class="line"></span><br><span class="line">__gnu_cxx::__mt_alloc&lt;<span class="keyword">int</span>&gt; alloc5; </span><br><span class="line">p = alloc5.allocate(<span class="number">1</span>);  </span><br><span class="line">alloc5.deallocate(p,<span class="number">1</span>);  </span><br><span class="line"></span><br><span class="line">    __gnu_cxx::bitmap_allocator&lt;<span class="keyword">int</span>&gt; alloc6;  </span><br><span class="line">p = alloc6.allocate(<span class="number">3</span>);  </span><br><span class="line">alloc6.deallocate(p,<span class="number">3</span>);  <span class="comment">//我刻意令參數為 3, 但這有何意義!! 一次要 3 個 ints?</span></span><br></pre></td></tr></table></figure><p>malloc  free</p><ul><li><p>不建议直接分配器，</p></li><li><p>直接用容器，小内存用malloc free</p></li></ul><hr><h2 id="源代码分布-vc-gcc"><a href="#源代码分布-vc-gcc" class="headerlink" title="源代码分布(vc gcc)"></a>源代码分布(vc gcc)</h2><p>////gnuc 2.91</p><p>visiual studio 2013/include </p><p>dev-c++ 5.11 with gnu 4.92//4.9.2 include /c++</p><h2 id="OOP-VS-GP"><a href="#OOP-VS-GP" class="headerlink" title="OOP VS GP"></a>OOP VS GP</h2><ul><li>OOP 将datas 和methods 关联在一起</li><li>GP 将datas和methods分开<ul><li>容器和algorithm可以分开来独立开发，以Iterator沟通即可</li><li>Algorithms 通过Iterator确定操作范围，通过iterator获取container、元素</li></ul></li><li>list 不能直接调用全局sort,自己类内定义有sort，全局sort 需要有randomaccess iterator,list iterator 迭代器指向上一个，下一个，不能随便跳。</li><li>所有algorithms, 最终涉及的元素本身的操作，就是比大小</li></ul><h2 id="操作符重载和模板"><a href="#操作符重载和模板" class="headerlink" title="操作符重载和模板"></a>操作符重载和模板</h2><ul><li>：：    ，. ,* ,?:,不能被重载</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">complex</span>(T r=<span class="number">0</span>,T i=<span class="number">0</span>)</span><br><span class="line">            :re(r),im(i)&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    T re,im;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; c1(<span class="number">2.5</span>,<span class="number">1.5</span>);</span><br><span class="line">    <span class="keyword">complex</span>&lt;<span class="keyword">int</span>&gt;c2(<span class="number">2</span>,<span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在声明模板的时候使用typename而不是class</strong> –effectve stl</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> </span></span><br><span class="line"><span class="class"><span class="title">const</span> <span class="title">T</span>&amp; <span class="title">min</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">A</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">B</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">return</span> b&lt;a?b:a;    </span><br><span class="line">&#125;</span><br><span class="line">stone s1,s2;</span><br><span class="line">min(s1,s2)<span class="comment">//实参推导 到 stone类内的 操作符重载 stone::operator&lt;</span></span><br></pre></td></tr></table></figure><p>成员模板。。。。。</p><p>模板特化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">type_traits</span>&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> __true_type this_dummy_member_must_be_first;</span><br><span class="line"><span class="keyword">typedef</span> __false_type has_trivial_default_constructor;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//int 特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;int&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;；</span><br><span class="line"><span class="comment">//double 特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;double&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;；</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">__type_traits&lt;Foo&gt;::this_dumy;</span><br><span class="line">__type_traits&lt;<span class="keyword">int</span>&gt;::</span><br><span class="line">__type_traits&lt;<span class="keyword">double</span>&gt;::</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//偏特化</span></span><br><span class="line"><span class="comment">//个数偏特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">Alloc</span>=<span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span>&lt;bool,Alloc&gt;</span></span><br><span class="line"><span class="class">&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//范围偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;T*&gt;&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const T*&gt;&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="分配器-Allocator"><a href="#分配器-Allocator" class="headerlink" title="分配器 Allocator"></a>分配器 Allocator</h2><p>operator new() 和malloc()</p><h3 id="VC6-allocator使用"><a href="#VC6-allocator使用" class="headerlink" title="VC6 allocator使用"></a>VC6 allocator使用</h3><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwqdu624gmj20oo0eb14g.jpg" alt></p><p>debug 模式下=debug内存+内存+pad+cookie</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p=allocator&lt;<span class="keyword">int</span>&gt;().allocate(<span class="number">512</span>,(<span class="keyword">int</span>* )<span class="number">0</span>);</span><br><span class="line">allocator&lt;<span class="keyword">int</span>&gt;().deallocate(p,<span class="number">512</span>);</span><br></pre></td></tr></table></figure><p>VC6* 的allocator 只是以::operator new 和::operator delete 完成allocat() 和deallocate()，没有任何特殊设计。</p><h3 id="BC5-STL-对allocator-使用"><a href="#BC5-STL-对allocator-使用" class="headerlink" title="BC5 STL 对allocator 使用"></a>BC5 STL 对allocator 使用</h3><p>BC++ 的allocator 只是以::operator new 和::operator delete 完成allocat() 和deallocate()，没有任何特殊设计。</p><h3 id="G2-9-对allocator使用"><a href="#G2-9-对allocator使用" class="headerlink" title="G2.9  对allocator使用"></a>G2.9  对allocator使用</h3><p>GCC2.9 的allocator 只是以::operator new 和::operator delete 完成allocat() 和deallocate()，没有任何特殊设计。</p><p>GCC2.9 实际使用 SGI版本的allocator。</p><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwqf1fgjoej20f608n0x0.jpg" alt></p><ul><li><p>尽量减少调用malloc次数，调用malloc有额外开销。</p></li><li><p>cookie记录整块大小，容器每个元素大小相同，不必对每个元素都记录大小</p></li><li><p>设计16条链表，每一条负责特定大小的区块，用链表串起来。</p></li><li><p>第7个负责7*8=56个字节大小，第一个负责8个byte，第二个16个。</p></li><li><p>容器需要内存时，向这个分配器要内存，容器的元素大小被调整到8的倍数，50-&gt;56，第七个负责，看这个链表有没有挂内存块，如果没有向操作系统要内存(malloc),切出来的内存用单向链表存，整块内存还是带cookie，整块中每个小块不带cookie，1个cookie 8个字节。</p></li><li><p>一个容器有1百万个元素，可以省去开销8百万个字节（最多），alloc分配器。</p></li><li><p>GCC2.91 allocator 采用上述分配器 alloc。</p></li></ul><h3 id="GCC4-9-allocator"><a href="#GCC4-9-allocator" class="headerlink" title="GCC4.9 allocator"></a>GCC4.9 allocator</h3><p>GCC4.9 allocator回到从前allocator，extension allocators中 __poool_allloc 极为G2.9中 alloc。</p><p>GCC4.9使用较好版本alloctor.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span> &lt;<span class="built_in">string</span>,__gnu_cxx::__pool_alloc&lt;<span class="built_in">string</span>&gt;&gt; vec;</span><br></pre></td></tr></table></figure><h2 id="容器之间的实现关系和分类"><a href="#容器之间的实现关系和分类" class="headerlink" title="容器之间的实现关系和分类"></a>容器之间的实现关系和分类</h2><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwqjbm3sc5j20jd0bftga.jpg" alt></p><p>heap 里有一个vector。</p><p>左右蓝色区域，为创建一个object需要内存，指的是需要控制所有元素所需的内存，那个对象本身。</p><h2 id="list-深度探索"><a href="#list-深度探索" class="headerlink" title="list 深度探索"></a>list 深度探索</h2><p>GCC2.9 list 只需一个Link_type node 4 个字节。</p><p><img src="http://ww1.sinaimg.cn/bmiddle/b4e58cf1ly1fwqjc5esztj21hc0uae81.jpg" alt></p><ul><li><p>灰色，环状，双向，实现所有容器在表现起begin end时，前闭后开。</p></li><li><p>end指向灰色。</p></li><li><p><strong>除vector array外所有容器，iterator 都必须class</strong>。</p></li></ul><p><img src="http://ww1.sinaimg.cn/bmiddle/b4e58cf1ly1fwqh4v46fnj21hc0uae81.jpg" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个node</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">list_node</span>&#123;</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">void</span> * void_pointer;</span><br><span class="line">        void_pointer prev;</span><br><span class="line">        void_pointer next;</span><br><span class="line">        T data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">Alloc</span>=<span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">list</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">typedef</span> __list_node&lt;T&gt; list_node;</span><br><span class="line"><span class="keyword">typedef</span> __list_iterator&lt;T,T&amp;,T*&gt; iterator;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">link_type node;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">Ref</span>,<span class="title">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">list_iterator</span>&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line"><span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line"><span class="keyword">typedef</span> Ref reference;</span><br><span class="line"><span class="keyword">typedef</span> __list_node&lt;T&gt; * link_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="built_in">list</span>&lt;Foo&gt;::iterator it;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/bmiddle/b4e58cf1ly1fwqh4v46fnj21hc0uae81.jpg" alt></p><ul><li><p>每一个容器的iterator一定有 5个typedef。</p></li><li><p>一堆操作符重载</p></li><li><p>iterator++,应找到next指针。</p></li><li><p>两个版本,++i前置型,i++ 后置型;</p></li><li><p>为区分，前++没有参数，i已经变为调用这个函数的object本身。</p></li></ul><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwqhghtts3j20n60cwgv1.jpg" alt></p><p><strong>self tmp=*this,编译器首先遇到=,进行拷贝构造，</strong></p><ul><li>operator-&gt;() ？？？？？</li></ul><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwqhwm1pxaj20pe0eiamf.jpg" alt></p><p>新旧版本区别</p><ul><li>__list_node 链表指针指向自己</li><li>_list_iterator 一个参数</li></ul><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwqj25un7lj20jc0b2agr.jpg" alt></p><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwqjgr4g1sj20jc0ap0zg.jpg" alt></p><p>​    G4.9 list大小为8，看base多大，看_list_impt多大，看_list_node_base，两个指针，八个字节。</p><p>list没有数据，继承自父类_list_base，_list_base 有数据 <em>m</em>impl，数据类型为_list_impl。</p><p>list_impl有数据<em>m</em>mode,数据类型为_list_node_base,而list_node_base 包含两个指针。</p><pre><code>## 迭代器的设计原则和iterator traits 的作用和设计</code></pre><ul><li><p>traits 萃取机，提取特征</p></li><li><p>pointer traits，character traits，等</p><p> <img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwr5kp4ebzj20pg0foqhg.jpg" alt></p><p>iterator 算法和容器之间桥梁。</p><p>iterator associated types:</p></li><li><p>iterator_category: iterator 分类，移动性质，++,– ，+=5；</p></li><li><p>value_type: iterator 指向的object的元素的类型</p></li><li><p>difference_type: 两个iterator 之间距离用什么type表示。e.g uint</p></li><li><p>reference type   未使用</p></li><li><p>pointer type    未使用</p><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwr62r0jcjj20ug0iqtol.jpg" alt></p></li><li><p><code>std::ptrdiff_t</code> is the signed integer type of the result of subtracting two pointers.</p></li><li><p>A <strong>BidirectionalIterator</strong> is a <a href="./ForwardIterator.html">ForwardIterator</a> that can be moved in both directions (i.e. incremented and decremented).      </p></li><li><p>只有class 才能做 typedef</p></li><li><p>当算法收到的是指针而不是iterator（class）时。</p><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwr6hboaxtj20mt0giwoz.jpg" alt></p><p>加上一层traits中间层，通过偏特化，分类。</p><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwr6o29yh8j20rr0hgaok.jpg" alt></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line"><span class="comment">// I能也包含模板时，必须这样用</span></span><br><span class="line"><span class="comment">// 显然，iterator 本身是一个class，肯定带模板参数</span></span><br><span class="line"><span class="comment">//typedef  I::value_type value_type; xxxx</span></span><br><span class="line"><span class="keyword">typedef</span> 定义一个新的名字（同一个数据类型）</span><br><span class="line"><span class="keyword">typename</span> 把一个特殊的名字解释成一个类型</span><br></pre></td></tr></table></figure><p>  <img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwr6t1l9ntj20k00i614h.jpg" alt></p><ul><li><p>A <strong>RandomAccessIterator</strong> is a <a href="./BidirectionalIterator.html">BidirectionalIterator</a> that can be moved to point to any element in constant time.</p><p>A pointer to an element of an array satisfies all requirements of RandomAccessIterator</p></li></ul>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  各种traits:</span><br><span class="line">  </span><br><span class="line"><span class="bullet">* </span>type traits &lt;.../c++/type_traits&gt;</span><br><span class="line">  </span><br><span class="line"><span class="bullet">* </span>iterator traits  &lt;.../c++/bits/stl_traits.h&gt;</span><br><span class="line">  </span><br><span class="line"><span class="bullet">* </span>char traits   &lt;.../c++/bits/char_traits.h&gt;</span><br><span class="line">  </span><br><span class="line"><span class="bullet">* </span>allocator traits &lt;.../c++/bits/allocator_traits.h&gt;</span><br><span class="line">  </span><br><span class="line"><span class="bullet">* </span>pointer traits   &lt;.../c++/bits/ptr_traits.h&gt;</span><br><span class="line">  </span><br><span class="line"><span class="bullet">* </span>array traits     &lt;.../c++/array&gt;</span><br></pre></td></tr></table></figure><h2 id="vector-深度探索"><a href="#vector-深度探索" class="headerlink" title="vector 深度探索"></a>vector 深度探索</h2><ul><li><p>一个vector三个变量记录，八个空间，目前已放6个元素，start,finish,end_of_storage</p></li><li><p>sizeof(vector<int>())=12; protected 3个 数据。</int></p></li></ul><ul><li>所有连续空间容器需要提供[]操作符重载,deque号称连续空间</li></ul><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwr7nwegucj20mu0e2dot.jpg" alt></p><p><img src="http://image.blissseven.top/blog/181109/kHF2CI33d6.png?imageslim" alt="mark"></p><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwr80e0xvcj20ro0hik76.jpg" alt></p><p>大量元素拷贝，引发拷贝构造函数，析构函数，成本很大。</p><ul><li><p>链表迭代器节点分离,iterator设计为class</p></li><li><p>vector 连续空间，iterator 指针</p></li></ul><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwr86nndljj20n00ebk2q.jpg" alt></p><p>新版本大小</p><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwr8ai0a1sj20fi0fkjwk.jpg" alt></p><p>​         </p><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwr8g6unnmj20td0iltpr.jpg" alt></p><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwr8knn3nfj20qi0gh7ih.jpg" alt></p><h2 id="array-forward-list-深度探索"><a href="#array-forward-list-深度探索" class="headerlink" title="array forward_list 深度探索"></a>array forward_list 深度探索</h2><ul><li><p>c++1.0 1998</p></li><li><p>c++2.0 2011</p></li><li><p>TR1版本</p></li></ul><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwrcp12sguj20si0hqtl9.jpg" alt></p><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwrcuem4ijj20ty0hwk7j.jpg" alt></p><p>iterator作为算法和容器之间的桥梁，需要给算法提供5个typedef，(value_type,reference_type,pointer,distance,category)iterator本身可以为class或者指针，这时就需要traitor萃取器，以偏特化的方式获取5个typedef。</p><h2 id="forward-list"><a href="#forward-list" class="headerlink" title="forward list"></a>forward list</h2><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwrd7ojykij20r30h8qdk.jpg" alt></p><h2 id="deque-queue-stack-深度探索"><a href="#deque-queue-stack-深度探索" class="headerlink" title="deque queue stack 深度探索"></a>deque queue stack 深度探索</h2><p>deque:</p><ul><li>5个buffer(横条)</li><li>vector 将buffer串起来，vector元素为指针，指向buffer</li><li>pushback 将缓冲区填满时，右建一个buffer，右挂到vector上</li><li>pushfront将缓冲区填满时，左建一个buffer，左挂到vector上</li><li>迭代器 为clas，内部有四个元素,cur,first,last,node<ul><li>node 指向vector 中控制区</li><li>first last 指定buffer大小</li></ul></li><li>几乎所有容器都提供两个函数 begin end,。</li></ul><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwrdwtljt2j20jd0c67af.jpg" alt></p><pre><code>* sizeof(dque&lt;int&gt;) 16*2+4+4= 40* 一个iterator 16 4个指针</code></pre><p>  <img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwre5kzgnoj20pq0eun8c.jpg" alt></p><p>deque iterator 4个元素:</p><ul><li><strong>cur</strong></li><li><strong>first</strong></li><li><strong>last</strong></li><li><strong>node</strong></li></ul><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwredhpzh7j20pd0fotix.jpg" alt></p><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwreq72l3tj20ip0d5agy.jpg" alt></p><p>​     </p><p>​      <img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwreth8fczj20ll0d6jzs.jpg" alt></p><p>size()函数：</p><ul><li>start 指向的buffer有多少个元素+finish指向的buffer有多少个元素</li><li>以及start和finish之间有多少个buffer，每个buffer</li></ul><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwrhvkgo4ij20o00dngug.jpg" alt></p><p>operator -，两个迭代器之间有多少个元素</p><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwrknxzp0tj20k60cajz7.jpg" alt></p><ul><li><p>i++(self operator++(int))，调用++i(self&amp; operator++())；</p></li><li><p>i–,调用–i;</p></li><li><p>set_node()  移动到下一个缓冲区时，first,last需要重新设值。</p><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwrkw2yey0j20q30eywoh.jpg" alt></p></li></ul><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwrl6r1py3j20l90daagj.jpg" alt></p><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwrl6r1py3j20l90daagj.jpg" alt></p><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwrlhsf9rqj20gw0alaco.jpg" alt></p><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwrlgsjx5oj20p70fnn8s.jpg" alt></p><p>一个deque包含4个：</p><ul><li><em>m</em>map指向 控制中心</li><li><em>m</em>map_size 指定控制中心大小，可以容纳多少个指针，控制中心copy时copy到中心。</li><li><em>m</em>start 开始 迭代器</li><li><em>m</em>finish 结束</li></ul><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwrlpu1s62j20ow0edn3w.jpg" alt></p><p>queue 也成为适配器</p><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwrlwjedl8j20ny0e97dq.jpg" alt></p><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwrly43x63j20oq0el7di.jpg" alt></p><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwrm5rnlhaj20p40f3gxf.jpg" alt></p><ul><li>vector 只能在尾部添加元素</li><li>如果没有调用c.pop()，那么queue用vector做底层是没有问题的（至少编译器不报错）。</li></ul><p><img src="http://ww1.sinaimg.cn/large/b4e58cf1ly1fwrm7karlgj20ow0dpk10.jpg" alt></p><p><strong>stack 和queue 都不可用set 和map做底部支撑，编译器不会做全面检查，用到哪个，才会检查哪个。</strong></p><h2 id="rb-tree深度探索"><a href="#rb-tree深度探索" class="headerlink" title="rb tree深度探索"></a>rb tree深度探索</h2><ul><li>小型数据库</li><li>key -&gt;value</li><li>插入快，搜寻快</li><li>红黑树<ul><li>平衡二元搜寻树，排列有利于search和insert</li><li>begin() 最左边的节点，end()最右边的节点</li><li>提供遍历，++ite时，从左边走，5-&gt;6-&gt;7-&gt;6&gt;8-&gt;10-&gt;11-&gt;12-&gt;13-&gt;15</li><li><strong>不应该</strong>使用iterators改变元素值。map中key不可以改，但是value可以改变</li><li>提供两种insertion<ul><li>insert_unique() key 独一无二,放重复值时不会崩溃，不会异常，只是放不进去</li><li>insert_equal() 允许key重复，相同的值 相邻。</li></ul></li><li>header 满足前闭后开</li></ul></li></ul><p><img src="http://image.blissseven.top/blog/181102/mh0gFHd2GG.png?imageslim" alt="mark"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Value</span>,//(<span class="title">key</span>|<span class="title">data</span>)合起来 =<span class="title">value</span></span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">KeyOfValue</span>,//在这个<span class="title">value</span>里，这个<span class="title">key</span>要怎么拿到</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Compare</span>,// 两个元素比大小 函数</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Alloc</span>=<span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">rb_tree</span>&#123;</span></span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _rb_tree_node&lt;value&gt; rb_tree_node;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> rb_tree_node* link_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    size_type node_count;<span class="comment">//rb_tree 大小 节点数量</span></span><br><span class="line">    link_type header;</span><br><span class="line">    Compare key_compare;<span class="comment">//key 大小判定 函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>仿函数没有数据大小为0，对于大小为0的class，编译器实现出来大小为1；</p><p>2+3+1=9 -&gt;12(4的倍数)</p><p><img src="http://image.blissseven.top/blog/181102/KgcAF30ajc.png?imageslim" alt="mark"></p><p>五个模板参数怎么用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg</span>,<span class="title">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">unary_function</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> Arg argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;//仿函数</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">identity</span>:</span><span class="keyword">public</span> unary_function&lt;T,T&gt;&#123;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> T&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp;x)</span></span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// RB_TREE_HPP</span></span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg1</span>,<span class="title">class</span> <span class="title">Arg2</span>,<span class="title">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">binary_function</span>&#123;</span></span><br><span class="line">        <span class="keyword">typedef</span>  Arg1 first_argument_type;</span><br><span class="line">        <span class="keyword">typedef</span> Arg2 second_argument_type;</span><br><span class="line">        <span class="keyword">typedef</span> Result result_type;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">less</span>:</span><span class="keyword">public</span> binary_function&lt;T,T,<span class="keyword">bool</span>&gt;&#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x,<span class="keyword">const</span> T&amp;y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x&lt;y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">rb_tree&lt;<span class="keyword">int</span>,</span><br><span class="line">        <span class="keyword">int</span>,</span><br><span class="line">        identity&lt;<span class="keyword">int</span>&gt;,</span><br><span class="line">        less&lt;<span class="keyword">int</span>&gt;,</span><br><span class="line">        alloc&gt;</span><br><span class="line">mytree;</span><br></pre></td></tr></table></figure><p><img src="http://image.blissseven.top/blog/181102/020Cl56Dff.png?imageslim" alt="mark"></p><p>测试:</p><p><img src="http://image.blissseven.top/blog/181102/1ChEkEF42C.png?imageslim" alt="mark"></p><p><img src="http://image.blissseven.top/blog/181102/AEieGlk7b4.png?imageslim" alt="mark"></p><h2 id="set-multiset深度探索"><a href="#set-multiset深度探索" class="headerlink" title="set multiset深度探索"></a>set multiset深度探索</h2><ul><li>以红黑树为底层，自动排序，排序依据为key</li><li>key 即为value，value即为key</li><li>提供遍历操作，++ite，获得排序状态</li><li>无法使用iterators改变元素的值，底层时RB tree的 const iterator</li><li>set key 独一无二  Insert ： rbtree insert_unique()</li><li>multiset key可以重复 insert : rbtree insert_equal()</li></ul><p><img src="http://image.blissseven.top/blog/181102/K3FKLkbjb0.png?imageslim" alt="mark"></p><p><img src="http://image.blissseven.top/blog/181102/m9lhIKEBhI.png?imageslim" alt="mark"></p><h3 id="map-multimap-深度探索"><a href="#map-multimap-深度探索" class="headerlink" title="map multimap 深度探索"></a>map multimap 深度探索</h3><p><img src="http://image.blissseven.top/blog/181104/jbkcjdlC5a.png?imageslim" alt="mark"></p><ul><li>通过select1st获取key</li><li>pair&lt;const key,T&gt;,不可以通过iterator修改key</li></ul><p><img src="http://image.blissseven.top/blog/181104/aJH9jei7le.png?imageslim" alt="mark"></p><ul><li>select1st 仿函数 重载operator()</li><li>multimap 不可用[] 做insertion</li></ul><p><img src="http://image.blissseven.top/blog/181104/G50JAHJHik.png" alt="mark"></p><p><img src="http://image.blissseven.top/blog/181104/8GF0LJ9Dc0.png?imageslim" alt="mark"></p><ul><li><p>map.operator[]如果找到key，则返回，如果找不到插入这个key</p></li><li><p>假设有7个hello，且这七个放在一起</p></li><li><p>lower_bound找到第一个hello，如果value不存在找到最适合安插这个值的迭代器</p></li><li><p>c.insert(pair&lt;long,string&gt;(i,buf))</p></li><li><p>c[i]=string(buf)</p></li></ul><p><img src="http://image.blissseven.top/blog/181104/5IJfC113ik.png?imageslim" alt="mark"></p><h2 id="hashtable-深度探索"><a href="#hashtable-深度探索" class="headerlink" title="hashtable 深度探索"></a>hashtable 深度探索</h2><ul><li><p>一个object对应一个数，数的范围0-2^32-1;需要N=sizeof(T)*2^32 个空间</p></li><li><p>N: 编号为T，将object放到第T个位置去</p></li><li><p>M&lt;N</p></li><li><p>M:编号为H，放到第H%M个位置去，有可能冲突，冲突就放在一起成为要给链表</p></li></ul><p> <img src="http://image.blissseven.top/blog/181104/EDEGH8aFCE.png?imageslim" alt="mark"></p><ul><li>separate chainging 方法：<ul><li>55%53=2</li><li>2%53=2</li></ul></li><li>链表很长？？链表长时打散。<ul><li>bucket为位置，篮子，多为质数，素数53</li><li>当链表元素个书大于bucket个数，链表打散rehashing，bucket变为大约两倍，变为素数53左右的素数97</li><li>53 97 193 389</li></ul></li></ul><p><img src="http://image.blissseven.top/blog/181104/ghBlKHJ0hg.png?imageslim" alt="mark"></p><ul><li>HashFcn  计算object编号 hashcode</li><li>ExtractKey  获得key的function</li><li>EqualKey   key相等的定义</li><li>3（hasher+key_equal+extractKey 三个0 大小的class）+3*4（vector）+4=19-&gt;20</li><li>vC链表双向，GCC单向链表</li><li>cur某一个结点，图错误！！</li></ul><p><img src="http://image.blissseven.top/blog/181104/7eE4Am1lIj.png?imageslim" alt="mark"></p><ul><li>测试<ul><li>元素为char* string</li><li>hash 提供 hashcode</li><li>identity 提供 key的方法</li><li>eqstr  key相等的方法<ul><li>判断两个字符串内容</li></ul></li></ul></li></ul><p><img src="http://image.blissseven.top/blog/181104/mH77k8cGfg.png" alt="mark"></p><ul><li>模板偏特化</li><li>仿函数</li><li>如果是数值的话，就把该数值作为hashcode</li></ul><p><img src="http://image.blissseven.top/blog/181104/0hDlIILkF7.png?imageslim" alt="mark"></p><ul><li>hash_code需要尽可能的不重复</li><li>标准库没有提供针对c++字符串的hash<a href="std::string" target="_blank" rel="noopener">std::string</a></li><li>Zeal——–There is no specialization for C strings. std::hash&lt;const char*&gt; produces a hash of the value of the pointer (the memory address), it does not examine the contents of any character array.</li></ul><p><img src="http://image.blissseven.top/blog/181104/iFAEBlD0aG.png?imageslim" alt="mark"></p><ul><li>modulus 余数</li><li>左边hash_table成员函数</li></ul><p><img src="http://image.blissseven.top/blog/181104/C628J2ll2c.png?imageslim" alt="mark"></p><h2 id="hash-set-hash-multiset-hash-map-hash-multimap-概念"><a href="#hash-set-hash-multiset-hash-map-hash-multimap-概念" class="headerlink" title="hash_set hash_multiset hash_map hash_multimap 概念"></a>hash_set hash_multiset hash_map hash_multimap 概念</h2><h2 id="unordered-容器概念"><a href="#unordered-容器概念" class="headerlink" title="unordered 容器概念"></a>unordered 容器概念</h2><p><img src="http://image.blissseven.top/blog/181104/107HKmj92a.png?imageslim" alt="mark"></p><ul><li>bucket 个数大于元素个数</li></ul><p><img src="http://image.blissseven.top/blog/181104/g8hc58cFeI.png?imageslim" alt="mark"></p><h2 id="算法的形式"><a href="#算法的形式" class="headerlink" title="算法的形式"></a>算法的形式</h2><ul><li>算法是个函数模板，两个版本<ul><li>带compare</li><li>不带compare</li><li>算法如果知道容器，也许能够找到一些最优的方法，</li><li>算法提问，迭代器回答，如果迭代器回答不了，则编译失败</li></ul></li></ul><p><img src="http://image.blissseven.top/blog/181104/kDKHf0LB3h.png?imageslim" alt="mark"></p><p>迭代器的分类</p><ul><li>5个typedef</li><li>迭代器是由容器提供的</li><li>array /vector/ deque <ul><li>random_access</li></ul></li><li>list/ rb_tree（set/ map/ multiset /multimap）<ul><li>bidirectional</li></ul></li><li>forward-list<ul><li>farward</li></ul></li><li>hashtable <ul><li>根据底层的链表 实现</li></ul></li><li>以5个strut表示iterator的类别，而不是enum，或者5个数</li></ul><p><img src="http://image.blissseven.top/blog/181104/eEIbaIdGj2.png?imageslim" alt="mark"></p><ul><li>typename（） 创建一个临时对象</li><li>istream_iterator<int>() input_iterator</int></li><li>ostream_iterator<int>(cout,””) output_iterator</int></li></ul><p><img src="http://image.blissseven.top/blog/181104/0ka0932H1C.png?imageslim" alt="mark"></p><ul><li>类型名称 typeid（iterator）.name</li><li>一个class 命名abc ，编译器编译后增加东西</li></ul><p><img src="http://image.blissseven.top/blog/181104/FhD2d2l0hA.png?imageslim" alt="mark"></p><ul><li>父类只有typedef ，子类相当于继承了这几个typedef</li><li>不同版本接口一定一样，可以通过默认参数设置</li></ul><p><img src="http://image.blissseven.top/blog/181104/92738DBaa1.png?imageslim" alt="mark"></p><p><img src="http://image.blissseven.top/blog/181104/djj7K6k1gd.png?imageslim" alt="mark"></p><h2 id="迭代器分类对算法的影响"><a href="#迭代器分类对算法的影响" class="headerlink" title="迭代器分类对算法的影响"></a>迭代器分类对算法的影响</h2><ul><li><p>distance 得到两根指针的距离</p></li><li><p>输入参数</p><ul><li>iterator_traits<inputiterator>::iterator_category category;</inputiterator></li><li>把itertor 丢给iterator_traits 然后问<ul><li>random_access<ul><li>last-begin</li></ul></li><li>input_iterator //// 慢<ul><li>++first, count(++)</li></ul></li></ul></li></ul></li><li><p>返回类型</p><ul><li><p>inline iterator_traits<inputerator>::difference_type;</inputerator></p></li><li><p>把itertor 丢给iterator_traits 然后问</p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//qt msvc</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">typename</span> <span class="title">iterator_traits</span>&lt;InputIterator&gt;:</span>:difference_type</span><br><span class="line">_distance(InputIterator first,InputIterator last,input_iterator_tag)&#123;</span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type n=<span class="number">0</span>;<span class="comment">//不一样！！！！</span></span><br><span class="line">    <span class="keyword">while</span>(first!=last)</span><br><span class="line">    &#123;</span><br><span class="line">        ++first;</span><br><span class="line">        ++n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">typename</span> <span class="title">iterator_traits</span>&lt;InputIterator&gt;:</span>:difference_type</span><br><span class="line">_distance(InputIterator first,InputIterator last,random_access_iterator_tag)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> last-first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">typename</span> <span class="title">iterator_traits</span> &lt;InputIterator&gt;:</span>:difference_type</span><br><span class="line">distance(InputIterator first,InputIterator last)&#123;</span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::iterator_category category;<span class="comment">/////!!!!!!!!不一样</span></span><br><span class="line">    <span class="keyword">return</span> _distance(first,last,category);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://image.blissseven.top/blog/181104/b3k2gKKeF3.png?imageslim" alt="mark"></p><ul><li>将迭代器i，丢给iterator_category（）函数，</li><li>在iterator_category()函数里，通过traits函数获得category,返回一个category（）对象</li></ul><p><img src="http://image.blissseven.top/blog/181104/32EB0L97ie.png?imageslim" alt="mark"></p><ul><li>左侧为想法，不是最终实现</li><li>引发拷贝复制函数<ul><li>has trival op=() 如果 op= 不重要</li><li>has non-trivial op=[] 如果op=重要</li></ul></li><li>type traits 问iterator 你的op=是否重要<ul><li>eg. complex 拷贝构造函数不重要</li></ul></li></ul><p><img src="http://image.blissseven.top/blog/181104/f7LAlD16AL.png?imageslim" alt="mark"></p><p><img src="http://image.blissseven.top/blog/181104/cjFljHjD72.png?imageslim" alt="mark"></p><ul><li>算法的效率和它能不能判断迭代器的分类有很大关系</li></ul><p><img src="http://image.blissseven.top/blog/181104/kJLeK745dI.png?imageslim" alt="mark"></p><ul><li>unique_copy 如果重复的就不copy</li><li></li></ul><p><img src="http://image.blissseven.top/blog/181104/99edH784Kg.png?imageslim" alt="mark"></p><ul><li>算法可以接受任意type的iterator</li><li>但是算法的参数class name可以暗示，需要的参数</li></ul><p><img src="http://image.blissseven.top/blog/181104/C84mkDBbad.png?imageslim" alt="mark"></p><h2 id="算法源代码剖析"><a href="#算法源代码剖析" class="headerlink" title="算法源代码剖析"></a>算法源代码剖析</h2><ul><li>c++ 算法，符合右侧定义</li></ul><p><img src="http://image.blissseven.top/blog/181104/26d0Hc18d1.png?imageslim" alt="mark"></p><ul><li>accumulate 累计，不一定是+</li><li>iterator符合前闭后开区间</li><li>一个函数对象，像函数的object，或者仿函数 重载opertor()</li></ul><p><img src="http://image.blissseven.top/blog/181104/B7G1f0f1eD.png?imageslim" alt="mark"></p><ul><li>在一段区间，在一段范围，对每一个元素做一件事情</li><li></li></ul><p><img src="http://image.blissseven.top/blog/181104/j76eAAAfL0.png?imageslim" alt="mark"></p><ul><li>replace  将旧值替换为新值</li><li>replace_if 根据条件， 条件为真，将该元素替换为value</li><li>replace_copy</li></ul><p><img src="http://image.blissseven.top/blog/181104/8GClkf7GL0.png?imageslim" alt="mark"></p><ul><li><p>左边全局函数，右边容器成员函数</p></li><li><p>count 相等 则加1</p></li><li><p>count_if  条件满足，则加1</p></li></ul><p><img src="http://image.blissseven.top/blog/181104/hL6Ljfiiai.png?imageslim" alt="mark"></p><p><img src="http://image.blissseven.top/blog/181104/9fHb929bJ7.png?imageslim" alt="mark"></p><ul><li>myvec.rbegin() reverse iterator</li><li>myvec.rend()</li></ul><p><img src="http://image.blissseven.top/blog/181104/3a6bE5B1lb.png?imageslim" alt="mark"></p><ul><li>不能违反前闭后开规则</li><li>rbegin 通过end() 套结一个适配器</li></ul><p><img src="http://image.blissseven.top/blog/181104/28EIHcJDBG.png?imageslim" alt="mark"></p><ul><li><p>binary_search 必须之前先排序</p></li><li><p>lower_bound: 在不违反排序的情况下，20 能够安插进去的最低位置</p></li><li><p>upper_bound:在不违反排序的情况下，20 能够安插进去的最高位置</p></li></ul><p><img src="http://image.blissseven.top/blog/181104/8Aki6g45cc.png?imageslim" alt="mark"></p><h2 id="仿函数和函数对象"><a href="#仿函数和函数对象" class="headerlink" title="仿函数和函数对象"></a>仿函数和函数对象</h2><p><img src="http://image.blissseven.top/blog/181104/9aKi4eEbj9.png?imageslim" alt="mark"></p><ul><li>重载operator()的class</li><li>算术类</li><li>逻辑运算类</li><li>相对关系类</li></ul><p><img src="C:%5CUsers%5Cbliss%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1541332986486.png" alt="1541332986486"></p><p><img src="http://image.blissseven.top/blog/181104/36D20Gi739.png?imageslim" alt="mark"></p><ul><li><p>less<int>() 用默认的比较方式。()创建一个对象</int></p></li><li><p>黄色binary_function</p></li><li><p>myclass 没有继承binary_function就没有融入STL<br><img src="http://image.blissseven.top/blog/181104/fhlc2Gijmd.png?imageslim" alt="mark"></p></li><li><p>unary 一个操作数</p></li><li><p>binary 两个操作数</p></li><li><p>如果有子类继承者两个0 class，这两个class的大小就真的为0</p></li><li><p>adapter 问functor问题，functor继承unary,binary 才能回答问题</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public std::binary_function  c++11中被废弃 c++17被删除</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="http://image.blissseven.top/blog/181104/blemm62CCE.png?imageslim" alt="mark"></p><h2 id="多种adapter"><a href="#多种adapter" class="headerlink" title="多种adapter"></a>多种adapter</h2><ul><li>根据所要改造的object，命名相应的名字</li><li>functor adapter / iterator adapter/container adapter</li><li>A 改造B，A做主要的事由B做，B为幕后<ul><li>A继承B</li><li>A内涵B composition  <strong>主要！！</strong>！</li><li>A 作为一个函数模板 里有B一个functor，</li></ul></li></ul><p><img src="http://image.blissseven.top/blog/181105/Ggm1BBlHbk.png?imageslim" alt="mark"></p><p><img src="http://image.blissseven.top/blog/181105/04AFmB7Ja4.png?imageslim" alt="mark"></p><h2 id="函数适配器"><a href="#函数适配器" class="headerlink" title="函数适配器"></a>函数适配器</h2><h3 id="binder2nd"><a href="#binder2nd" class="headerlink" title="binder2nd"></a>binder2nd</h3><ul><li><p>绑定第二个参数</p></li><li><p>less<int>()一个object</int></p></li><li><p>修饰functor后，也要变成functor的样子，重载operator()</p><ul><li>修饰容器后，也要变成容器的样子</li></ul></li><li><p>模板类不能实参推导</p></li><li><p>函数模板可以做实参推导，东西放到函数模板后，是什么类型type</p><ul><li>函数模板bind2nd里有个functor binder2nd</li></ul></li><li><p>bind2nd 返回一个binder2nd<operation> object;</operation></p></li><li><p>binder2nd<opertion>(op,arg2_type(x)) 构造函数一个Object,记录到op,value</opertion></p></li><li><p>binder2nd重载 operator() 因为最终还是要通过operation()调用less<int> 函数</int></p></li><li><p>执行(pred(*first) 调用op(x,value))</p></li><li><p>typename Operation::second_argument_type  一个类型</p><ul><li>帮助编译器通过这个代码，编译时，不知道opertion::second_argument_type，</li></ul></li><li><p>typedef   typename Operation::second_argument_type arg2_type 将这个类型 重新起个名字</p></li><li><p><strong>binder2nd 如果也要继续被adapter时，也要继承unary_function</strong></p></li></ul><p><img src="http://image.blissseven.top/blog/181105/aiaB5I36bd.png?imageslim" alt="mark"></p><p><img src="http://image.blissseven.top/blog/181105/akKHLkg0IF.png?imageslim" alt="mark"></p><ul><li>左边现在，右边过时</li></ul><p><img src="http://image.blissseven.top/blog/181105/dJCe8L0BI1.png?imageslim" alt="mark"></p><h3 id="not1"><a href="#not1" class="headerlink" title="not1"></a>not1</h3><p><img src="C:%5CUsers%5Cbliss%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1541415116929.png" alt="1541415116929"></p><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><ul><li><p>_1 _2 _3占位符号 using namespace std::placeholders</p><ul><li>保留参数</li></ul></li><li><p>my_divide ===function</p></li><li><p>std::divide<double>mydivide ====function objects</double></p></li><li><p>bind<int> 绑定返回类型</int></p><ul><li>如果没有返回类型就是它所绑定的 object的返回类型</li></ul></li></ul><p>member :</p><ul><li>membe function—- &amp;MyPair::multiply  隐藏argument this</li><li>cbegin const begin，不能改内容</li></ul><p>bind(less<int>,_1,50) //第一个参数不能给，是v.cbegin 到v.cend()之间的元素</int></p><p><img src="http://image.blissseven.top/blog/181105/aGGAGlaHb7.png?imageslim" alt="mark"></p><h3 id="reverse-iterator"><a href="#reverse-iterator" class="headerlink" title="reverse_iterator"></a>reverse_iterator</h3><ul><li>iterator adapter</li><li>逆向取值= 正向-1 再取值</li></ul><p><img src="http://image.blissseven.top/blog/181105/hKB7flm60F.png?imageslim" alt="mark"></p><h3 id="ostream-iterator"><a href="#ostream-iterator" class="headerlink" title="ostream_iterator"></a>ostream_iterator</h3><ul><li><p>x 未知 适配器</p></li><li><p>不属于 container/functor/iterator/ adapter</p></li><li><p>“,” 作为分隔符</p></li></ul><p><img src="http://image.blissseven.top/blog/181105/fe7fmb539I.png?imageslim" alt="mark"></p><h3 id="istream-iterator"><a href="#istream-iterator" class="headerlink" title="istream_iterator"></a>istream_iterator</h3><ul><li>创建一个对象时，就已经在读了。</li><li>operator++ 时在等待输入</li></ul><p><img src="http://image.blissseven.top/blog/181105/d34201dcCg.png?imageslim" alt="mark"></p><p><img src="http://image.blissseven.top/blog/181105/f3FCg969EJ.png?imageslim" alt="mark"></p><h2 id="万用的hash-function"><a href="#万用的hash-function" class="headerlink" title="万用的hash-function"></a>万用的hash-function</h2><ul><li><p>将customer 作为元素放入容器，设计hash_cunction</p></li><li><p>一个class 重载operator()</p><ul><li>Unordered_set&lt;Customer,CustomerHash&gt;</li></ul></li><li><p>一个函数 size_t(*)(const Customer&amp;) 函数类型</p><ul><li>unordered_set&lt;Customer, size_t(*)(const Customer&amp;)&gt;</li><li>cutset(20,customer_hash_func)使用时，传递函数地址</li></ul></li></ul><p><img src="http://image.blissseven.top/blog/181106/2dJH7LHa4l.png?imageslim" alt="mark"></p><ul><li>hash<string>()(c.fname) 一个class对象调用operator()</string></li><li>TR1版本 1 2 3 4 .</li><li>template&lt;typename… Types&gt; 1 接收任意个数的模板参数</li><li>seed pass by reference</li></ul><p><img src="http://image.blissseven.top/blog/181106/06aLE3k6mF.png?imageslim" alt="mark"></p><p><img src="http://image.blissseven.top/blog/181106/bJe9d130aB.png?imageslim" alt="mark"></p><p> <img src="http://image.blissseven.top/blog/181106/CJbEl1Dmdc.png?imageslim" alt="mark"></p><ul><li>hh()%11 得到元素应该放到第几个bucket</li></ul><p><img src="http://image.blissseven.top/blog/181106/dEKIaKH52k.png?imageslim" alt="mark"></p><ul><li>写一个hash<customer>版本</customer></li></ul><p><img src="http://image.blissseven.top/blog/181106/cK7FBc7HgH.png?imageslim" alt="mark"></p><p><img src="http://image.blissseven.top/blog/181106/h9CGH7a7fb.png?imageslim" alt="mark"></p><h2 id="tuple-用例"><a href="#tuple-用例" class="headerlink" title="tuple 用例"></a>tuple 用例</h2><ul><li><p>允许在声明一个组合体时，可以任意个数，任意类型</p></li><li><p>tuple&lt;string,int,int,complex<double>&gt; t;</double></p></li><li><p>get&lt;0&gt;(t1)  </p></li><li><p>auto t2=make_tuple(22,44,”stacy”);</p></li><li><p>get&lt;1&gt;(t1)=get&lt;1&gt;(t2);</p></li><li><p>如果t1 t2 有相同成分，t1&lt;t2</p></li><li><p>t1=t2</p></li><li><p>tie(i1,f1,s1)=t3;// assigns values of t3 to i1,f1,s1</p></li><li><p>typedef tuple&lt;int,float,string&gt;TupleType…… tuple_size(TupleType)::value</p></li><li><p>tuple_element&lt;1,Tuple_Type&gt;</p></li></ul><p><img src="http://image.blissseven.top/blog/181107/DJCA82j1j9.png?imageslim" alt="mark"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承方式实现递归</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="function">class <span class="title">tuple</span><span class="params">()</span></span>&#123;&#125;; <span class="comment">// 终止条件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tuple</span> &lt;Head,Tail...&gt;：<span class="title">private</span> <span class="title">tuple</span>&lt;Tail...&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>typename Head::type head(){return m_head;} //</li><li>inherited &amp; tail (){return *this;} //this 原来指三个元素，经inherited&amp; tail 转型后，指两个元素</li></ul><p><img src="http://image.blissseven.top/blog/181107/dig8IJfB70.png?imageslim" alt="mark"></p><h2 id="type-traits"><a href="#type-traits" class="headerlink" title="type traits"></a>type traits</h2><ul><li>G2.9版假设默认构造，复制构造，析构，拷贝赋值都重要</li><li>特别class 带有指针。或者析构函数要关掉一个窗口，一个文件，一个锁</li><li>算法 去问： _type_traits<foo>::has_trivial_destructor</foo></li><li></li></ul><p><img src="http://image.blissseven.top/blog/181107/K8kHkagHHb.png?imageslim" alt="mark"></p><ul><li>POD plain old data 没有function，只有数据，c版本的struct</li><li>新版本 不需要对自己的class，不需要自己写偏特化</li></ul><p><img src="http://image.blissseven.top/blog/181107/hfEF7fC9F4.png?imageslim" alt="mark"></p><p><img src="http://image.blissseven.top/blog/181107/99840eamHd.png?imageslim" alt="mark"></p><p><img src="http://image.blissseven.top/blog/181107/JLmlJHeHG1.png?imageslim" alt="mark"></p><p><img src="http://image.blissseven.top/blog/181107/fh24cJkC2e.png?imageslim" alt="mark"></p><ul><li>丢进去一个string</li><li>字符串不会当做父类，没有vitual destructor</li></ul><p><img src="http://image.blissseven.top/blog/181107/e6I70bc4Kj.png?imageslim" alt="mark"></p><p><img src="http://image.blissseven.top/blog/181107/AK43lBhhjH.png?imageslim" alt="mark"></p><p><img src="http://image.blissseven.top/blog/181107/7FgFJGBG2h.png?imageslim" alt="mark"></p><ul><li><p>&amp;&amp; move contstructor</p></li><li><p>Zoo(const Zoo&amp;) =delete; 复制构造函数 没有</p></li><li><p>Zoo(Zoo&amp;&amp;) move constructor</p></li><li></li><li><p><img src="http://image.blissseven.top/blog/181107/E97C4keFIg.png?imageslim" alt="mark"></p></li></ul><h2 id="type-traits-实现"><a href="#type-traits-实现" class="headerlink" title="type_traits 实现"></a>type_traits 实现</h2><ul><li><p>模板+typedef</p></li><li><p>移除const volatile _is_void_helper&lt;typename remove_cv&lt;__TP&gt;::type&gt;::type;</p></li><li><p>template<typename></typename></p><ul><li>struct _is_void_helper: public false_type{};</li></ul></li><li><p>template&lt;&gt;</p><ul><li>struct _is_void_helper<void>: public true_type{};</void></li></ul></li></ul><p><img src="http://image.blissseven.top/blog/181107/CeL8hledac.png?imageslim" alt="mark"></p><p><img src="http://image.blissseven.top/blog/181107/Ke9dLlkb5I.png?imageslim" alt="mark"></p><ul><li>可能 编译器 实现</li><li>grep 命令找</li></ul><p><img src="http://image.blissseven.top/blog/181107/cekhBL283F.png?imageslim" alt="mark"></p><h2 id="cout"><a href="#cout" class="headerlink" title="cout"></a>cout</h2><ul><li>一个对象object不是class</li><li>extern 这个东西可以被外界使用</li></ul><p><img src="http://image.blissseven.top/blog/181107/JFl1DCA0gI.png?imageslim" alt="mark"></p><h2 id="moveable-元素对容器速度效能影响"><a href="#moveable-元素对容器速度效能影响" class="headerlink" title="moveable 元素对容器速度效能影响"></a>moveable 元素对容器速度效能影响</h2><ul><li>元素类型加不加move这个功能，影响很大</li><li>元素有move功能，调用Mctor 否则调用CCtor</li><li>MCtor move ctor  vector两倍增长</li><li>CCtor</li></ul><p><img src="http://image.blissseven.top/blog/181107/g09c294CGg.png?imageslim" alt="mark"></p><ul><li>list 一个萝卜一个坑</li><li>CCtor Mctor =300000</li><li>之后的容器会扩充的是一个一个结点</li></ul><p><img src="http://image.blissseven.top/blog/181107/jFc4IAB8B2.png?imageslim" alt="mark">  </p><p><img src="http://image.blissseven.top/blog/181107/ekEahLf8Ke.png?imageslim" alt="mark"></p><ul><li>浅拷贝 就是Move的动作</li><li>把原来的指针销掉，建立一个新的指针指向对象</li></ul><p><img src="http://image.blissseven.top/blog/181107/9cim0ID8dg.png?imageslim" alt="mark"></p><p><img src="C:%5CUsers%5Cbliss%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1541593229584.png" alt="1541593229584"></p><h2 id="测试函数"><a href="#测试函数" class="headerlink" title="测试函数"></a>测试函数</h2><ul><li><p>std::move(c1) 调用move版本</p></li><li><p>3百万个元素，3百万个指针，move版本</p></li><li><p>Move copy后，之前的那个指针就不能用了</p><ul><li>比如 临时对象temp</li><li><strong>见到临时对象，自动调用move版本 如果有的话</strong></li><li><strong>c1.insert(ite,V1type(buf))</strong></li></ul></li><li><p>M c11(c1) c1 不是临时对象，编译器不调用move版本</p></li><li><p>M c12(std::move(c1)) 强制调用move版本 </p></li></ul><p><img src="http://image.blissseven.top/blog/181107/k3cbb3JkiE.png?imageslim" alt="mark"></p><ul><li><p>vector 深拷贝</p><p><img src="C:%5CUsers%5Cbliss%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1541594490059.png" alt></p></li><li><p>vector 本身浅拷贝</p></li><li><p>M c12(std::move(c1) )</p><ul><li>把三根指针交换</li><li>unspecified   未指明的，未加规定的;未特别指定（规定）的;未详细说明的</li></ul></li></ul><p><img src="C:%5CUsers%5Cbliss%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1541636127973.png" alt="1541636127973"></p><p><img src="C:%5CUsers%5Cbliss%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1541636621199.png" alt="1541636621199"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
