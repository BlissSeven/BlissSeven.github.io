<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="bliss7">



<meta name="description" content="好吧，这是为了面试而准备的，顺便查漏补缺">
<meta name="keywords" content="cpp,review">
<meta property="og:type" content="article">
<meta property="og:title" content="cpp-review">
<meta property="og:url" content="blissseven.top/2019/08/30/cpp-review/index.html">
<meta property="og:site_name" content="bliss7&#39;s blog">
<meta property="og:description" content="好吧，这是为了面试而准备的，顺便查漏补缺">
<meta property="og:locale" content="default">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/1568370381628.png">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/20180805132942260.jpg">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/20190128164450968.png">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/20190128165747507.png">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/20160425230849959-1572162931459.gif">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/1334370490_3589.jpg">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/20190128174333124.png">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/20190128174734675.png">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/20190128174904564.png">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/20190128180745482.png">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/20190128185944131.png">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/20180531111209270-1570539021425.jpg">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/2018053111122476.jpg">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/20180531111239523.jpg">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/20171208095645231.png">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/20160624093011_365.png">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/1568374913878.png">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/image002.jpg">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/c9Rd4j0YFFdr.png">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/lp02PfVJt4c9.png">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/IAyD5lcoVH3k.png">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/1567476237158.png">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/1567391865764.png">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/1567391955508.png">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/8AMLnhHgXyzf.png">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/201012122157476286.png">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/201012122157494693.png">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/20180208112533496">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/Ou1Q34TIaU52.png">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/1567386917332.png">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/1567388045381.png">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/1570690570733.png">
<meta property="og:updated_time" content="2019-11-11T06:05:48.944Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="cpp-review">
<meta name="twitter:description" content="好吧，这是为了面试而准备的，顺便查漏补缺">
<meta name="twitter:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/1568370381628.png">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="bliss7&#39;s blog" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>cpp-review | bliss7&#39;s blog</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">bliss7</a></h1>
        </hgroup>

        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-11/">C++11</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-11，trivial/">C++11，trivial</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Concurrency/">Concurrency</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OS/">OS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STL/">STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP-IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/code-review/">code-review</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp/">cpp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp11/">cpp11</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/data-structure/">data structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design-pattern/">design pattern</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/interview/">interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux-cmd/">linux-cmd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/muduo/">muduo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network-program/">network-program</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/object-model/">object model</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/object-model/">object-model</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/object-model/">object_model</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/review/">review</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/singleton/">singleton</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thread/">thread</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程服务器/">多线程服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/操作系统/">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/零碎/">零碎</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">bliss7</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">bliss7</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-cpp-review" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/08/30/cpp-review/" class="article-date">
      <time datetime="2019-08-30T00:30:52.000Z" itemprop="datePublished">2019-08-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      cpp-review
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/review/">review</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <ul>
<li>好吧，这是为了面试而准备的，顺便查漏补缺</li>
</ul>
<a id="more"></a>

<ul>
<li><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1></li>
</ul>
<h2 id="成员变量初始化顺序"><a href="#成员变量初始化顺序" class="headerlink" title="成员变量初始化顺序"></a>成员变量初始化顺序</h2><ul>
<li><p>成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关</p>
</li>
<li><p>如果不使用初始化列表初始化，在构造函数内初始化时，此时与成员变量在构造函数中的位置有关</p>
<ul>
<li><p><strong>变量的初始化顺序</strong>就应该是：</p>
<p>1 基类的静态变量或全局变量</p>
<p>2 派生类的静态变量或全局变量</p>
<p>3 基类的成员变量</p>
<p>4 派生类的成员变量</p>
</li>
</ul>
</li>
<li></li>
</ul>
<h2 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h2><ul>
<li>运行时类型信息，它提供了运行时确定对象类型的方法</li>
<li>三个支持RTTI的元素</li>
<li>dynamamic_cast<ul>
<li>讲一个执行基类的指针转换为指向派生类的指针，负责返回空指针</li>
</ul>
</li>
<li>typied运算符返回一个指出对象的类型的值，<strong>typeid是一个返回类型为type_info类型</strong>的函数</li>
<li>type_info结构存储了有关特定类型的信息</li>
</ul>
<p>指针占用几个字节</p>
<ul>
<li><p>16为地址，指针即为2个字节，</p>
<p>现在一般是32位系统，所以是4个字节，</p>
<p>以后64位，则就为8个字节</p>
</li>
<li><p>内存是由字节组成的，每个字节都有一个编号。指针变量主要是存放相同数据类型的变量的首地址。这里的这个地址其实就是内存的某个字节的编号。而这个编号的确定是与地址总线有关。如果地址总线是32位，则它的寻址范围是0<del>2^32（0</del>4G）。那么为一个字节的编址就会由32个0或者1组成。例如第一个字节的编址是32个0，最后一个的编址是32个1。一个字节有8位，32位则需要4个字节。</p>
</li>
<li><p>简单的说32位的操作系统就是指：地址总线是32位的系统。那么，也就是说操作系统的位数决定了指针变量所占的字节数</p>
</li>
</ul>
<h2 id="strcpy-strncpy"><a href="#strcpy-strncpy" class="headerlink" title="strcpy strncpy"></a>strcpy strncpy</h2><ul>
<li>strcpy(dest,src);    strcpy把src所指向以’\0’结尾的字符串复制到dest所指的数组中，返回指向dest的指针。<ul>
<li>当sizeof(dest)&gt;=sizeof(src)时，拷贝正确，并在dest字符串后面加入’\0’;</li>
<li>当sizeof(dest)&lt;sizeof(src)时，拷贝出错。</li>
</ul>
</li>
<li>strncpy(dest,src,n);    strncpy把src所指向以’\0’结尾的字符串的前n个字符复制到dest所指的数组中，返回指向dest的指针。<ul>
<li>当n&gt;=sizeof(src)时，拷贝正确，并在dest字符串后面加入’\0’;</li>
<li>当n&lt;sizeof(src)时，只拷贝src前n-1个字符串到dest，不会为dest字符串后面加入’\0’;</li>
</ul>
</li>
</ul>
<h2 id="ASCII-utf-8-unicode"><a href="#ASCII-utf-8-unicode" class="headerlink" title="ASCII-utf-8-unicode"></a>ASCII-utf-8-unicode</h2><ul>
<li>ASCII 英语字符与二进制位之间的关系，ASCII 码一共规定了128个字符的编码,这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0</li>
<li>Unicode一种所有符号的编码<ul>
<li>Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储</li>
<li>这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的</li>
</ul>
</li>
<li>UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式<ul>
<li>种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度</li>
<li>对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</li>
<li>对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</li>
</ul>
</li>
</ul>
<h2 id="为什么static函数不能const修饰和virtual修饰"><a href="#为什么static函数不能const修饰和virtual修饰" class="headerlink" title="为什么static函数不能const修饰和virtual修饰"></a>为什么static函数不能const修饰和virtual修饰</h2><ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是C++的规则，<span class="keyword">const</span>修饰符用于表示函数不能修改成员变量的值，该函数必须是含有<span class="keyword">this</span>指针的类成员函数，函数调用方式为thiscall，而类中的<span class="keyword">static</span>函数本质上是全局函数，调用规约是__cdecl或__stdcall,不能用<span class="keyword">const</span>来修饰它。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="判断一个对象调用是否经过虚函数表"><a href="#判断一个对象调用是否经过虚函数表" class="headerlink" title="判断一个对象调用是否经过虚函数表"></a>判断一个对象调用是否经过虚函数表</h2><ul>
<li>调用通过Memset把虚函数表指针置0</li>
</ul>
<h2 id="lambda实现原理"><a href="#lambda实现原理" class="headerlink" title="lambda实现原理"></a>lambda实现原理</h2><ul>
<li><h2 id="C-C的类型安全"><a href="#C-C的类型安全" class="headerlink" title="C++/C的类型安全"></a>C++/C的类型安全</h2></li>
<li><p>c的类型安全只在局部上下文中体现，例如试图将一种类型的指针转换成其他类型的指针时，编译器会报错，malloc和new相比也并不是类型安全的。</p>
</li>
<li><p>c++类型安全：</p>
<ul>
<li>操作符new返回的指针类型严格与对象匹配，而不是void*；</li>
<li>C中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的；</li>
<li>引入const关键字代替#define constants，它是有类型、有作用域的，而#define constants只是简单的文本替换；</li>
<li>一些#define宏可被改写为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全；</li>
<li>C++提供了dynamic_cast关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。</li>
</ul>
</li>
</ul>
<h2 id="auto-VS-decltype"><a href="#auto-VS-decltype" class="headerlink" title="auto VS decltype"></a>auto VS decltype</h2><ul>
<li>auto auto关键字来让编译器帮助我们分析表达式或者函数所属的类型，用一个对象的类型和值来初始化另一个对象。</li>
<li>auto VS const<ul>
<li>auto会忽略掉顶层const, 保留底层const.</li>
</ul>
</li>
<li>auto VS 引用<ul>
<li>如果表达式是引用类型, 那么auto的类型是这个引用的对象的类型.</li>
<li>如果要声明一个引用, 就必须要加上&amp;, 如果要声明为一个指针, 既可以加上也可以不加</li>
</ul>
</li>
<li>decltype  只是为了推断出表达式的类型而不用这个表达式的值来初始化对象..</li>
<li>decltype vs const<ul>
<li><strong>不论是顶层const还是底层const, decltype都会保留</strong></li>
</ul>
</li>
<li>decltype和引用<ul>
<li>如果表达式是引用类型, 那么decltype的类型也是引用</li>
<li>如果表达式是引用类型, 但是想要得到这个引用所指向的类型, 需要修改表达式:</li>
<li>对指针的解引用操作返回的是引用类型</li>
<li>如果一个表达式的类型不是引用, 但是我们需要推断出引用, 那么可以加上一对括号, 就变成了引用类型了</li>
</ul>
</li>
</ul>
<h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><ul>
<li><p>访问范围：</p>
<ul>
<li>private: 只能由该类中的函数、其友元函数访问,不能被任何其他访问，该类的对象也不能访问.<br>protected: 可以被该类中的函数、子类的函数、以及其友元函数访问,但不能被该类的对象访问<br>public: 可以被该类中的函数、子类的函数、其友元函数访问,也可以由该类的对象访问</li>
<li>注：友元函数包括两种：设为友元的全局函数，设为友元类中的成员函数<br>父类与其直接子类的访问关系如上，无论是哪种继承方式（private继承、protected继承、public继承）。</li>
</ul>
</li>
<li><p>对于三种继承关系的不同：</p>
<ul>
<li>public继承：public继承后，从父类继承来的函数属性不变（private、public、protected属性不变，）。<br>private继承：private继承后，从父类继承来的函数属性都变为private<br>protected继承：protected继承后，从父类继承过来的函数，public、protected属性变为protected，private还是private。</li>
</ul>
</li>
</ul>
<h2 id="程序优化"><a href="#程序优化" class="headerlink" title="程序优化"></a>程序优化</h2><ul>
<li><strong>编译优化</strong></li>
<li><strong>位运算代替乘除法</strong></li>
<li><strong>内联频繁调用的短小函数</strong></li>
<li><strong>空间换时间</strong></li>
<li><strong>提前计算</strong></li>
<li><strong>字符数组的初始化</strong></li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul>
<li><p>C++ 通过 throw 语句和 try…catch 语句实现对异常的处理</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> 表达式;<span class="comment">//抛出异常</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>try…catch 语句的执行过程是：</p>
</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(异常类型)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(异常类型)&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行 try 块中的语句，如果执行的过程中没有异常拋出，那么执行完后就执行最后一个 catch 块后面的语句，所有 catch 块中的语句都不会被执行；</li>
</ul>
</li>
<li><p>如果 try 块执行的过程中拋出了异常，那么拋出异常后立即跳转到第一个“异常类型”和拋出的异常类型匹配的 catch 块中执行（称作异常被该 catch 块“捕获”），执行完后再跳转到最后一个 catch 块后面继续执行。</p>
</li>
</ul>
</li>
</ul>
<h2 id="四种类型转换"><a href="#四种类型转换" class="headerlink" title="四种类型转换"></a>四种类型转换</h2><ul>
<li>static_cast 静态转换，也就是编译时转换。可以完成基础类型的转换，然后任意类型指针与void指针的转换，还可以完成同一个继承体系中类型的转换。上行转换（派生类—-&gt;基类）是安全的；下行转换（基类—-&gt;派生类）由于没有动态类型检查，所以是不安全的。</li>
<li>dynamamic_cast 是运行时转换，用于将基类的指针或引用安全的转换成派生类的指针或引用—向下转换。因为向上转换upcast是没有问题的（子类转换为父类），因为父类的行为（函数）都包含在子类中。</li>
<li>const_cast 去除掉常量属性或者增加常量属性</li>
<li>reinterpret_cast  对二进制形式重新解释，但不改变其值。</li>
</ul>
<h2 id="C-C-函数调用的压栈模型"><a href="#C-C-函数调用的压栈模型" class="headerlink" title="C/C++函数调用的压栈模型"></a>C/C++函数调用的压栈模型</h2><ul>
<li><p><img src="cpp-review/1568370381628.png" alt="1568370381628"></p>
</li>
<li><p>对c++而言，以上几种调用惯例的名字修饰策略都略有所改变，因为c++支持函数重载以及命名空间和成员函数等等，因此实际上一个 函数名可以对应多个函数定义，那么上面提到的名字修饰策略显然无法区分各个不同同名函数定义的。所以c++有自己更加复杂的名字修饰策略。</p>
<p>最后，c++还有自己一种特殊的调用惯例，称为thiscall，专门用于类成员函数的调用，其特点随编译器不同而不同，在vc里是将this指针存放于eax寄存器，</p>
<p>参数从右到左压栈，而对于gcc、thiscall和cdecl完全一样，只是将this看作是函数的第一参数</p>
</li>
<li><h2 id="成员初始化列表"><a href="#成员初始化列表" class="headerlink" title="成员初始化列表"></a>成员初始化列表</h2><ul>
<li>在类构造函数中，不在函数体内对变量赋值，而在参数列表后，跟一个冒号和初始化列表</li>
<li>必须<ul>
<li>需要初始化const修饰的类成员或初始化引用成员数据；</li>
<li>子类初始化父类的私有成员；</li>
<li>数据成员是对象，并且这个对象只有含参数的构造函数，没有无参数的构造函数；</li>
</ul>
</li>
<li>初始化顺序为申明顺序</li>
<li>高效 少了1次默认构造过程<ul>
<li>对象成员变量的初始化动作发生在进入构造函数之前。当然对于内置类型没什么影响，但如果有些成员是类，那么在进入构造函数之前，会先调用一次默认构造函数，进入构造函数后所做的事其实是一次赋值操作(对象已存在)，所以是一次默认构造加一次赋值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><ul>
<li>申请了一块内存空间，使用完毕后没有释放掉。内存泄漏并非指内存在物理上的消失，而是<a href="http://baike.baidu.com/view/330120.htm" target="_blank" rel="noopener">应用程序</a>分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。<ul>
<li>堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc<br>new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete<br>删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak. </li>
<li>系统资源泄露（Resource Leak）.主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。 </li>
</ul>
</li>
<li>工具软件BoundsChecker</li>
<li><strong>解决内存泄漏最有效的办法就是使用智能指针（Smart Pointer）</strong></li>
</ul>
<h2 id="结构体内存对齐"><a href="#结构体内存对齐" class="headerlink" title="结构体内存对齐"></a>结构体内存对齐</h2><ul>
<li>数据成员对齐规则：数据成员对齐规则：结构（struct或联合union）的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置: min(#pragma pack()指定的数,这个数据成员的自身长度)的倍数</li>
<li>结构体作为成员:如果一个结构里有某些结构体成员，则结构体成员要从min(#pragram pack() ,<br>内部长度最长的数据成员)的整数倍地址开始存储。（struct a里存有struct<br>b，b里有char，int，double等元素，那b应该从min(#pragram pack(), 8)的整数倍开始存储。）</li>
<li>收尾工作:结构体的总大小,也就是sizeof的结果,.必须是 min(#pragram pack() , 长度最长的数据成员) 的整数倍</li>
<li>#pragram pack() 默认为4(32位), 8(64位)<ul>
<li>为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</li>
<li>平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。 </li>
</ul>
</li>
</ul>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul>
<li>默认构造函数。不需要任何参数</li>
<li>拷贝构造</li>
<li>赋值构造</li>
<li>移动构造</li>
<li>移动赋值</li>
</ul>
<h2 id="引用和指针实现多态"><a href="#引用和指针实现多态" class="headerlink" title="引用和指针实现多态"></a>引用和指针实现多态</h2><ul>
<li>子类指针赋值给父类指针，仅仅是让基类指针指向子类对象的地址，而子类对象的虚函数表中保存的是自己的子类虚函数的地址，已经对父类的虚函数进行过覆盖。</li>
<li>子类对象赋值给父类对象。首先，普通的赋值函数不会进行虚函数表的赋值，其次，对象去访问成员的虚函数并不通过虚函数表。</li>
<li>引用本质上也是通过指针的解引用（即*_point)来实现的</li>
<li>引用在C++中的内部实现是一个常量指针</li>
<li>一个空的class的对象的大小为1个字节， 编译器之所以要这么做，是为了区别同一个类类型的不同对象！</li>
</ul>
<h2 id="构造函数的几种关键字-default-delete-0"><a href="#构造函数的几种关键字-default-delete-0" class="headerlink" title="构造函数的几种关键字(default  delete   0)"></a>构造函数的几种关键字(default  delete   0)</h2><ul>
<li>= default：将拷贝控制成员定义为=default显式要求编译器生成合成的版本</li>
<li>= delete：将拷贝构造函数和拷贝赋值运算符定义删除的函数，阻止拷贝（析构函数不能是删除的函数 C++Primer P450）</li>
<li>= 0：将虚函数定义为纯虚函数（纯虚函数无需定义，= 0只能出现在类内部虚函数的声明语句处；当然，也可以为纯虚函数提供定义，不过函数体必须定义在类的外部）</li>
</ul>
<h2 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h2><ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">版权声明：本文为CSDN博主「醉美遇见你倾城」的原创文章，遵循 CC <span class="number">4.0</span> BY-SA 版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/yy19961124/article/details/88562009</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一个类（普通类/模板类）都可以包含本身是模板的成员函数。成员模板不能是虚函数</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&#123;</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> It&gt; Blob(It a,It b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在类模板外部进行其成员模板的函数体定义时，需要同时为类模板和成员模板提供模板参数列表。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">Blob&lt;T&gt;::Blob(It a,It b)</span><br><span class="line">:</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; s2(vi.begin(),vi.end());</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>显示实例化。由于模板被使用时才会被实例化，但是有时候相同的实例可能在不同的对象文件中会使用到，当多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数，每个文件中就都会有一个模板的实例，所产生的开销将会很大。</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;string&gt;;</span>             <span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">comare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>;    <span class="comment">//定义</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">编译器遇上extern模板声明时，不会再本文件中实例化。同时，将一个实例化声明为extern表示承诺在程序其他位置有该实例化的一个非extern声明(定义)。对于一个特定版本的实例化，可能有多个extern，但必须只有一个定义。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>类型转换和模板类型参数。<strong>将实参传递给带模板类型的函数形参时，能够自动应用类型转换的只有const转换及数组或函数到指针的转换</strong>。</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">const转换：可以将一个非const对象的引用(或指针)传递给一个const的引用(或指针)形参。</span></span><br><span class="line"><span class="comment">数组或函数指针转换：如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换。一个数组实参可以转化为一个指向其首元素的指针。类似，一个函数实参可以转化为一个指向该函数类型的指针。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">fobj</span><span class="params">(T, T)</span></span>; <span class="comment">//实参将被拷贝</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">fref</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;   <span class="comment">//引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"a value"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">"another value"</span>)</span></span>;</span><br><span class="line">fobj(s1, s2);   <span class="comment">//调用fobj(string, string)；const被忽略</span></span><br><span class="line">fref(s1, s2);   <span class="comment">//调用fref(const string&amp;, const string&amp;)；将s1转化为const是允许的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>], b[<span class="number">20</span>];</span><br><span class="line">fobj(a, b); <span class="comment">//调用fobj(int*, int*)</span></span><br><span class="line">fref(a, b); <span class="comment">//错误，对于一个引用形参参数来说，数组不会转化为指针。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>函数模板显式实参。有时候希望允许用户控制模板的实例化，可以指定显式模板实参。</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">例如，定义一个sum函数，允许用户指定返回结果类型来控制精度</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T1 <span class="title">sum</span><span class="params">(T2, T3)</span></span>; <span class="comment">//没有任何实参类型给编译器去推断T1的类型</span></span><br><span class="line">                <span class="comment">//因此每次调用sum时都必须为T1提供一个显式模板实参</span></span><br><span class="line"><span class="keyword">auto</span> val3 = sum&lt;<span class="keyword">long</span>,<span class="keyword">long</span>&gt;(i, lng); <span class="comment">//通过指定和实参，编译器推断为long long sum(int, long)</span></span><br><span class="line"></span><br><span class="line">##注意##</span><br><span class="line">    显式模板实参按从左向右的顺序与对应的模板参数匹配。只有尾部的显式模板实参才可以忽略。</span><br><span class="line">    <span class="comment">//糟糕的设计：用于必须指定所有三个模板参数</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line">    <span class="function">T3 <span class="title">sum</span><span class="params">(T1, T2)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> val2 = sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>, <span class="keyword">long</span>&gt;(i, lng);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>除了用户指定模板实参类型，可以选择通过尾置返回类型来判定。</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用尾置来声明返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">auto fcn(T beg, T end) -&gt; decltyp(*beg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//处理序列</span></span><br><span class="line">    <span class="keyword">return</span> *beg;    <span class="comment">//返回一个元素的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>进行类型转化的标准库模板类</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">有时候，我们希望返回一个元素的值，而并非引用。</span><br><span class="line">为了获得元素类型，我们可以使用标准库的类型转换模板，这些模板定义在头文件type_traits中。</span><br><span class="line"><span class="comment">//为了使用模板参数的成员，必须typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">auto fcn2(T beg, T end) -&gt; typename remove_reference&lt;decltype(*beg)&gt;::type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//处理序列</span></span><br><span class="line">    <span class="keyword">return</span> *beg;    <span class="comment">//返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>当参数类型无法确定模板实参的唯一类型，必须显式指出实例化哪个类型。</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">//pf1指向实例int compare(const int&amp;, const int&amp;)</span></span><br><span class="line"><span class="keyword">int</span> (*pf1)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;) = compare;</span><br><span class="line">pf1中参数的类型决定了T的模板实参的类型。例子中T的模板实参类型为<span class="keyword">int</span>。</span><br><span class="line">指针pf1指向compare的<span class="keyword">int</span>版本</span><br><span class="line">当出现重载版本，每个版本接收一个不同的函数指针类型，则需要显式指出实例化哪个版本</span><br><span class="line"><span class="comment">//func重载</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>(*)(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>(*)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;))</span></span>;</span><br><span class="line">func(compare);  <span class="comment">//错误用法，产生歧义，无法确定使用哪个版本的compare</span></span><br><span class="line"><span class="comment">//正确用法</span></span><br><span class="line">func(compare&lt;<span class="keyword">int</span>&gt;);     <span class="comment">//显式指出T为int类型，即compare(const int&amp;, const int&amp;)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>引用折叠</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">某些函数需要将其一个或多个实参连同类型不变的转发给其他函数。</span><br><span class="line"><span class="comment">//接收一个可调用对象和另外两个参数的模板</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip1</span><span class="params">(F f, T1 t1, T2 t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(t1, t2);</span><br><span class="line">&#125;</span><br><span class="line">版本一在一般情况下可以较好的工作，但当我们希望能用它调用一个接收引用的参数时，就会出现问题：</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v1 &lt;&lt; <span class="string">" "</span> &lt;&lt; ++v2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">这段f函数，改变了绑定到v2上的实参的值；</span><br><span class="line">但是，通过flip1调用f时，f所作的改变不会影响到实参</span><br><span class="line">f(<span class="number">42</span>, i);   <span class="comment">//f改变了实参i</span></span><br><span class="line">flip1(f, <span class="number">42</span>, j);    <span class="comment">//通过flip1调用f不会改变j</span></span><br><span class="line">#原因#</span><br><span class="line">    从模板参数列表中可以看到，由实参j推断出T1为<span class="keyword">int</span>类型，于是j被传递过去的是<span class="keyword">int</span>而不是<span class="keyword">int</span>&amp;。</span><br><span class="line">    模板被实例化为<span class="function"><span class="keyword">void</span> <span class="title">flip1</span><span class="params">(<span class="keyword">void</span>(*fcn)(<span class="keyword">int</span>, <span class="keyword">int</span>&amp;), <span class="keyword">int</span> t1, <span class="keyword">int</span> t2)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v1 &lt;&lt; <span class="string">" "</span> &lt;&lt; ++v2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip2</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(t1, t2);</span><br><span class="line">&#125;</span><br><span class="line">此处模板参数列表为右值引用，如果我们调用flip2(f, <span class="number">42</span>, j)，则会传递给参数t2一个左值j</span><br><span class="line">但是，在flip2中，推断出的T2类型为<span class="keyword">int</span>&amp;，意味着t2的类型会折叠为<span class="keyword">int</span>&amp;。</span><br><span class="line">由于是引用类型，t2被绑定到j上，flip2调用f时，f的引用参数v2也绑定到t2，即绑定到f上。</span><br><span class="line">因此f递增v2也同时改变了j的值。</span><br><span class="line">#Note#</span><br><span class="line">    如果一个函数参数是指向模板类型参数的右值引用(如T&amp;&amp;)，它对应的实参的<span class="keyword">const</span>属性和左值/右值属性可以得到保持</span><br><span class="line"></span><br><span class="line">由于flip2解决了一般问题。它对于接收一个左值引用的函数工作的很好，但不能接收右值引用参数的函数</span><br><span class="line">即：</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> &amp;&amp;i, <span class="keyword">int</span> &amp;j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">当试图通过flip2调用g，则参数t2将被传递给g的右值引用参数。</span><br><span class="line">flip2(g, <span class="number">42</span>, j);    <span class="comment">//错误，不能从一个左值实例化int&amp;&amp;</span></span><br><span class="line"><span class="number">42</span> 为右值，传递给flip2时T1推到为T1&amp;&amp;&amp;&amp;=T1&amp;&amp; 但是，无论传递参数为左值还是右值，普通传参都会将参数作为左值进行转发。所以T1 作为T1&amp; 传递给f，由于f的第一个参数为<span class="keyword">int</span>&amp;&amp;右值引用，只能绑定到右值上，so,出错！！！！！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//版本三</span></span><br><span class="line">使用forward的新标准库来爆出原始实参类型，类似move，forward定义在头文件utility中</span><br><span class="line">forward必须通过显式模板实参来调用，forward返回该显式实参类型的右值引用。即</span><br><span class="line">forward&lt;T&gt; 返回类型为T&amp;&amp;</span><br><span class="line"><span class="comment">//重写flip</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">void</span> flip(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span><br><span class="line">&#123;</span><br><span class="line">    f(<span class="built_in">std</span>::forward&lt;T2&gt;(t2), <span class="built_in">std</span>::forward&lt;T1&gt;(t1));</span><br><span class="line">&#125;</span><br><span class="line">#Note#</span><br><span class="line">    与<span class="built_in">std</span>::move一样，使用时不用<span class="keyword">using</span>声明，直接加上<span class="built_in">std</span>::使用，<span class="built_in">std</span>::forward</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"左值引用"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="keyword">int</span>&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"右值引用"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pass</span><span class="params">(T&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"普通传参:"</span>;</span><br><span class="line">    reference(v);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"std::move 传参:"</span>;</span><br><span class="line">    reference(<span class="built_in">std</span>::move(v));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"std::forward 传参:"</span>;</span><br><span class="line">    reference(<span class="built_in">std</span>::forward&lt;T&gt;(v));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"传递右值:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    pass(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"传递左值:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> v = <span class="number">1</span>;</span><br><span class="line">    pass(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">传递右值:</span></span><br><span class="line"><span class="comment">普通传参:左值引用</span></span><br><span class="line"><span class="comment">std::move 传参:右值引用</span></span><br><span class="line"><span class="comment">std::forward 传参:右值引用</span></span><br><span class="line"><span class="comment">传递左值:</span></span><br><span class="line"><span class="comment">普通传参:左值引用</span></span><br><span class="line"><span class="comment">std::move 传参:右值引用</span></span><br><span class="line"><span class="comment">std::forward 传参:左值引用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>函数模板特例化</p>
<ul>
<li><p>必须为原函数模板的每个模板参数都<strong>提供实参</strong>，且使用关键字template后跟一个空尖括号对&lt;&gt;,表明将原模板的所有模板参数提供实参。</p>
</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp; t1,<span class="keyword">const</span> T&amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;https:<span class="comment">//www.cnblogs.com/inception6-lxc/p/8686156.html#4355778</span></span><br><span class="line">    <span class="keyword">if</span>(t1&gt;t2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(t1&lt;t2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; t1,<span class="keyword">const</span> <span class="built_in">string</span>&amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(t1,t2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>模板类特例化</p>
<ul>
<li><p>在类中，我们可以对模板进行特例化，也可以对类进行部分特例化。对类进行特例化时，仍然用template&lt;&gt;表示是一个特例化版本</p>
</li>
<li><p>参数个数的特例化</p>
</li>
<li><p>参数范围的特例化</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Alloc=......&gt;</span><br><span class="line">class <span class="built_in">vector</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Alloc=....&gt;</span><br><span class="line">class <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>,Alloc&gt;</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;Typename T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&lt;T*&gt;&#123;</span>&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="final-VS-override"><a href="#final-VS-override" class="headerlink" title="final  VS override"></a>final  VS override</h2><ul>
<li><p>final 限定某个类不能被继承或某个<strong>虚函数</strong>不能被重写。(非虚函数不能final)</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> final</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> <span class="title">final</span>:</span> A()</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>override关键字保证了派生类中声明重写的函数与基类虚函数有相同的签名</p>
</li>
</ul>
<h2 id="struct-VS-class"><a href="#struct-VS-class" class="headerlink" title="struct VS class"></a>struct VS class</h2><ul>
<li><p>1.默认的继承访问权。class默认的是private,strcut默认的是public。</p>
</li>
<li><p>2.默认访问权限：struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。</p>
</li>
<li><p>“class”这个关键字还用于定义模板参数，就像“typename”。但关键字“struct”不用于定义模板参数</p>
</li>
<li><p><strong>关于使用大括号初始化</strong></p>
</li>
<li><p><strong>class和struct如果定义了构造函数的话，都不能用大括号进行初始化</strong></p>
<ul>
<li><strong>如果没有定义构造函数，struct可以用大括号初始化。</strong></li>
<li><strong>如果没有定义构造函数，且所有成员变量全是public的话，class可以用大括号初始化。</strong></li>
</ul>
</li>
<li><p>—–以{}的方式来赋初值，只是用一个初始化列表来对数据进行按顺序的初始化</p>
</li>
</ul>
<h2 id="指针和引用区别"><a href="#指针和引用区别" class="headerlink" title="指针和引用区别"></a>指针和引用区别</h2><ul>
<li>指针是一个变量，这个变量存储指向内存的一个地址；而引用跟原来的变量是同一个东西，是原变量的一个别名</li>
<li>可以有const指针，没有const引用</li>
<li>指针可以有多级，引用只能有一级（int**p,int&amp;&amp;a）</li>
<li>指针的值可以为Null，可以不用初始化，而引用在定义时必须初始化</li>
<li>指针在初始化后可以改变其所指向的内存，指向其他的存储单元，而对象一经绑定，不可更改</li>
<li>sizeof（引用）得到的是原来的变量的大小，而sizeof（指针）是指针本身的大小</li>
<li>指针和引用自增意义不同</li>
</ul>
<h2 id="main函数之前"><a href="#main函数之前" class="headerlink" title="main函数之前"></a>main函数之前</h2><ul>
<li>main函数执行之前，初始化系统资源<ul>
<li>设置栈指针</li>
<li>初始化static静态和global全局变量，即data段内容</li>
<li>将未初始化部分的全局变量赋值，数值型short，int，long等为0，bool为FALSE，指针为NULL，等等，即.bss段的内容</li>
</ul>
</li>
</ul>
<h2 id="main返回值"><a href="#main返回值" class="headerlink" title="main返回值"></a>main返回值</h2><ul>
<li>main函数的返回值，用于说明程序的退出状态。</li>
<li>如果返回0，则代表程序正常退出；返回其它数字的含义则由系统决定。</li>
<li>main函数的返回值将被操作系统用作进程的退出代码，利用这个特性，我们可以使用返回值来标识某项任务是否成功执行。</li>
</ul>
<h2 id="C-内存模型"><a href="#C-内存模型" class="headerlink" title="C++内存模型"></a>C++内存模型</h2><ul>
<li><img src="cpp-review/20180805132942260.jpg" alt="20180805132942260"></li>
<li>栈区-&gt;堆区-&gt;未初始化数据段(bss)，由exec是初始化为0-&gt;初始化的数据（全局变量、静态变量和常量数据）-&gt;正文</li>
<li>正文 CPU执行机器指令部分</li>
<li>初始化数据段，程序中明确赋初值的变量（全局变量、静态变量、常量数据（虚函数表））</li>
<li>未初始化数据。内核将此段中数据初始化为0或空指针</li>
<li>栈，自动变量以及每次函数调用时所需要保存的信息。</li>
<li>堆 动态内存分配</li>
</ul>
<h2 id="面向对象的四个特性"><a href="#面向对象的四个特性" class="headerlink" title="面向对象的四个特性"></a>面向对象的四个特性</h2><ul>
<li>抽象。将一些事物的共性和相似点剥离出来，并将这些属性归为一个类</li>
<li>封装。为了隐藏内部实现细节。</li>
<li>继承。继承是子类自动共享父类数据和方法的机制，这是类之间的一种关系，提高了软件的可重用性和可扩展性。</li>
<li>多态。程序定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编译期并不确定，而是在程序运行期间才确定（称之为动态绑定），即一个引用变量指向的是哪个类的实例对象，在编译期间并不确定，在运行阶段才能决定。</li>
</ul>
<h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><ul>
<li>堆由低地址向高地址扩展；栈由高地址向低地址扩展。</li>
<li>堆中内存需要手动申请和释放，栈中内存OS自动申请和释放，存放着参数、局部变量等内存</li>
<li>堆中频繁调用malloc和free，产生内存碎片，降低程序效率；栈由于先进后出特性不会产生内存碎片</li>
<li>堆的内存分配效率低，栈的分配效率高</li>
<li>栈效率高原因<ul>
<li>栈为操作系统提供的数据结构，OS提供了一系列支持：分配专门的寄存器存储栈的地址，压栈和入栈有专门的指令执行；而堆是由C++函数库提供的，机制复杂，需要有分配内存、合并内存和释放内存的算法，效率低。</li>
</ul>
</li>
</ul>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ul>
<li>遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问</li>
<li>系统总是重新从它所在的内存读取数据。而且读取的数据立刻被寄存,而不是将数据拷贝到寄存器，再从寄存器中读。</li>
<li>volatile用在如下的几个地方：<ol>
<li>中断服务程序中修改的供其它程序检测的变量需要加volatile；</li>
<li>多任务环境下各任务间共享的标志应该加volatile；</li>
<li>存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；</li>
</ol>
</li>
</ul>
<h2 id="内联函数VS宏定义"><a href="#内联函数VS宏定义" class="headerlink" title="内联函数VS宏定义"></a>内联函数VS宏定义</h2><ul>
<li><p>都是代码的替换。</p>
</li>
<li><p>代码的逻辑都应该是简短的</p>
</li>
<li><p>宏定义函数不会进行类型检查，因为只是进行简单的字符串替换，所以如果不注意的话，执行顺序可能会和预想的不一样，因为不会制作传入参数的临时拷贝，而只是进行简单的替换</p>
</li>
<li><p>在编译阶段，编译器将内联函数展开，替换为等效的实现代码，而不是进行函数调用。</p>
</li>
<li><p>内联函数不一定会被替换，如果代码过于复杂，编译器将不进行替换。而宏定义一定会被替换。</p>
</li>
</ul>
<h2 id="C-VS-C最大特点"><a href="#C-VS-C最大特点" class="headerlink" title="C++ VS C最大特点"></a>C++ VS C最大特点</h2><ul>
<li>面向对象</li>
<li>引用代替指针</li>
<li>const/inline/template 代替宏常量</li>
<li>namespace解决重名问题</li>
<li>STL提供高效的数据结构和算法</li>
<li>模板编程</li>
</ul>
<h2 id="static-assert"><a href="#static-assert" class="headerlink" title="static_assert"></a>static_assert</h2><ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(<span class="keyword">void</span> *) == <span class="number">4</span>, <span class="string">"64-bit code generation is not supported."</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>static_assert关键字，用来实现编译期间的断言，叫静态断言。编译器在遇到一个static_assert语句时，通常立刻将其第一个参数作为常量表达式进行演算，但如果该常量表达式依赖于某些模板参数，则延迟到模板实例化时再进行演算，这就让检查模板参数成为了可能。</p>
</li>
<li><p>assert是运行期的判断，并且会强制终止程序，一般要求只能用于debug版本中，是为了尽可能快的发现问题。assert是要从release版本中去掉。所以一般开发会重新定义assert宏。</p>
</li>
</ul>
<h2 id="c-11新特性"><a href="#c-11新特性" class="headerlink" title="c++11新特性"></a>c++11新特性</h2><ul>
<li>线程库</li>
<li>右值引用与移动语义</li>
<li>auto</li>
<li>decltype</li>
<li>lambda</li>
<li>nullptr</li>
<li>ranged_base for</li>
<li>initialist list</li>
<li>新增STL容器</li>
</ul>
<h2 id="访问类的私有变量"><a href="#访问类的私有变量" class="headerlink" title="访问类的私有变量"></a>访问类的私有变量</h2><ul>
<li>定义get/set接口</li>
<li>友元函数</li>
<li>友元变量</li>
<li>通过类对象的首地址+偏移！！！ ridiculous</li>
</ul>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> aaa[<span class="number">2</span>][<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;<span class="comment">// aaa = 0x004ff850 &#123;0x004ff850 &#123;1, 2, 3&#125;, 0x004ff85c &#123;4, 5, 6&#125;&#125;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; aaa &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//004FF850</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; aaa+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//004FF85C 一维数组指针相加</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *aaa &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//004FF850 数组中第一个元素的地址</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *aaa + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//004FF854 一个元素的指针+1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; **aaa  &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; **aaa +<span class="number">1</span>&lt;&lt; <span class="built_in">endl</span>;<span class="comment">//2</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="虚基类表"><a href="#虚基类表" class="headerlink" title="虚基类表"></a>虚基类表</h2><ul>
<li><strong>在类中增加一个指针(VBPTR)指向一个VBTBL，这个VBTBL的第一项记载的是从VBPTR 与本类的偏移地址，如果本类有虚函数，内存中第一项为虚函数表指针，第二项才是虚基类表指针，所以虚基类表中第一项是FF FF FF FC(也就是-4)，如果没有则是零，第二项起是VBPTR与本类的虚基类的偏移值。</strong></li>
<li>虚基类中第一项父亲1的虚函数表指针地址-父亲1对象的首地址</li>
<li>虚基类中第二项为父亲1的对象的首地址-爷爷虚基类表指针的地址</li>
</ul>
<h2 id="extern-C"><a href="#extern-C" class="headerlink" title="extern C"></a>extern C</h2><ul>
<li><p>c++ 中函数签名是函数名称+函数参数，以此实现函数重载</p>
</li>
<li><p>c中函数签名只有函数名称</p>
</li>
<li><p>告诉编译器，被extern “C”修饰的函数或者变量是按照C语言方式编译和链接的</p>
</li>
<li><p>C++中调用C</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c++ cpp文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"c"</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cexample.h"</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    add(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c .h文件中 extern声明函数</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="comment">//c .c文件中定义add</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>C中调C++</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c++ .h文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="comment">//c  .c文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cppexample.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    add(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="编译型VS解释型VS动态语言VS静态语言"><a href="#编译型VS解释型VS动态语言VS静态语言" class="headerlink" title="编译型VS解释型VS动态语言VS静态语言"></a>编译型VS解释型VS动态语言VS静态语言</h2><ul>
<li>编译型语言首先是将源代码编译生成机器指令，再由机器运行机器码(二进制)。</li>
<li>解释型语言的源代码不是直接翻译成机器指令，而是先翻译成中间代码，再由解释器对中间代码进行解释运行。</li>
<li>动态类型语言，是指数据类型的检查是在运行时做的</li>
<li>静态类型语言，是指数据类型的检查是在运行前（如编译阶段）做的。</li>
</ul>
<h2 id="构造函数-VS析构函数"><a href="#构造函数-VS析构函数" class="headerlink" title="构造函数 VS析构函数"></a>构造函数 VS析构函数</h2><ul>
<li>构造函数<strong>不可以</strong>通过对象、对象的指针、对象引用直接调用</li>
<li>析构函数<strong>可以</strong>通过对象、对象的指针、对象引用直接调用</li>
</ul>
<p>C++对象数组的删除</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A arr[]=<span class="keyword">new</span> A[<span class="number">5</span>];<span class="comment">//调用5次构造函数</span></span><br><span class="line"><span class="keyword">delete</span> []arr;<span class="comment">//析构5次</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不是动态创建时，对象离开作用域时，自动调用析构</span></span><br><span class="line">A arr3[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//如果在作用域内自己手动依次调用析构，那么在离开作用域时，编译器还是会调用析构，切记切记！！！</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="拷贝构造VS-赋值构造"><a href="#拷贝构造VS-赋值构造" class="headerlink" title="拷贝构造VS 赋值构造"></a>拷贝构造VS 赋值构造</h2><ul>
<li><p><strong>拷贝构造函数是一个对象初始化一块内存区域，这块内存就是新对象的内存区，而赋值函数是对于一个已经被初始化的对象来进行赋值操作。</strong></p>
</li>
<li><p><strong>一般来说在数据成员包含指针对象的时候，需要考虑两种不同的处理需求：一种是复制指针对象，另一种是引用指针对象。拷贝构造函数大多数情况下是复制，而赋值函数是引用对象</strong></p>
</li>
<li><p><strong>实现不一样。拷贝构造函数首先是一个构造函数，它调用时候是通过参数的对象初始化产生一个对象。赋值函数则是把一个新的对象赋值给一个原有的对象，所以如果原来的对象中有内存分配要先把内存释放掉，而且还要检察一下两个对象是不是同一个对象，如果是，不做任何操作，直接返回</strong></p>
</li>
<li><p>应用场景</p>
<ul>
<li>拷贝构造<ul>
<li>一个对象需要通过另一个对象进行初始化</li>
<li>函数形参值传递</li>
<li>函数返回值值传递</li>
</ul>
</li>
<li>赋值构造<ul>
<li>调用operator=，且被赋值对象存在时（已分配内存）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="overload-VS-override-VS-overwrite"><a href="#overload-VS-override-VS-overwrite" class="headerlink" title="overload VS override VS overwrite"></a>overload VS override VS overwrite</h2><ul>
<li>overload 函数重载<ul>
<li>相同的范围（同一个类中）</li>
<li>函数名字相同</li>
<li>参数不同（参数类型，参数长度）</li>
</ul>
</li>
<li>override 覆盖 派生类函数覆盖基类虚函数<ul>
<li>不同范围（一个父类，一个子类）</li>
<li>函数名字相同</li>
<li>参数相同</li>
<li>父类有virtual标识</li>
</ul>
</li>
<li>overwrite 重定义派生类屏蔽了与其同名的基类函数<ul>
<li>如果派生类与基类函数同名，但是参数不同。此时无论是否有virtual，基类函数被隐藏</li>
<li>如果派生类与基类函数同名，参数相同。基类没有virtual，基类函数被隐藏。</li>
</ul>
</li>
</ul>
<h2 id="变量的声明和定义"><a href="#变量的声明和定义" class="headerlink" title="变量的声明和定义"></a>变量的声明和定义</h2><ul>
<li><p>声明一个变量：变量名前+extern，并且不要显示的初始化变量</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">int</span> j;<span class="comment">//声明并定义j，定义会分配空间</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> pi=<span class="number">3.1416</span>;<span class="comment">//定义</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="new的变种"><a href="#new的变种" class="headerlink" title="new的变种"></a>new的变种</h2><ul>
<li><p>malloc free标准库函数，new delete C++语言关键字</p>
</li>
<li><p>malloc失败返回空，new失败抛异常</p>
</li>
<li><p>new/delete会调用构造、析构函数，malloc/free不会，所以他们无法满足动态对象的要求。</p>
</li>
<li><p>new返回有类型的指针，malloc返回无类型的指针</p>
</li>
<li><p>malloc是从堆上动态分配内存，new是从<strong>自由存储区</strong>为对象动态分配内存。 自由存储区的位置取决于operator new的实现。自由存储区不仅可以为堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存</p>
</li>
<li><p>new</p>
<ul>
<li>调用operator new分配内存,</li>
<li>在分配的内存上调用构造函数</li>
</ul>
</li>
<li><p>operator new</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span>  <span class="params">( <span class="built_in">std</span>::<span class="keyword">size_t</span> count )</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>placement new</p>
<ul>
<li><p>保持一块内存，反复构造析构，这样可以省略中间的多次分配内存。</p>
</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* ptr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">sizeof</span>(T)]; <span class="comment">// allocate memory  </span></span><br><span class="line">T* tptr = <span class="keyword">new</span>(ptr) T;            <span class="comment">// construct in allocated storage ("place")  </span></span><br><span class="line">tptr-&gt;~T();                      <span class="comment">// destruct  </span></span><br><span class="line"><span class="keyword">delete</span>[] ptr;                    <span class="comment">// deallocate memory</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="特殊对象构建"><a href="#特殊对象构建" class="headerlink" title="特殊对象构建"></a>特殊对象构建</h2><ul>
<li><p><a href="https://blog.csdn.net/hxz_qlh/article/details/13135433#" target="_blank" rel="noopener">https://blog.csdn.net/hxz_qlh/article/details/13135433#</a></p>
</li>
<li><p>一个只能在堆上建立的对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    A()&#123;&#125;</span><br><span class="line">    ~A()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> A* <span class="title">create</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个只能在栈上建立的对象</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> t)</span></span>&#123;&#125;     <span class="comment">// 注意函数的第一个参数和返回值都是固定的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span>&#123;&#125; <span class="comment">// 重载了new就需要重载delete</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A()&#123;&#125;</span><br><span class="line">    ~A()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>不能被继承的类</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="title">final</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">&#125;<span class="comment">//C++11实现</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<pre><code>* <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> T;  <span class="comment">//T为Base的友元 不需要class</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Base()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"base"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Base()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> Base&lt;B&gt;&#123;   <span class="comment">//一定注意 必须是虚继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"B"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


* 某个继承B的类X，在构造的时候必须要构造Base，但是B虚继承至Base，X不能通过B的构造函数来构造Base，但是由于Base的构造是private的，所以X不能构造。

* 虚继承时，由最低层次的派生类的构造函数去初始化虚基类，由于虚基类的构造函数为private

* 友元不可继承，不可传递</code></pre><h2 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h2><ul>
<li><p>栈区，编译器自动分配释放，存放函数的参数，局部变量</p>
</li>
<li><p>堆区，由程序员分配释放，</p>
</li>
<li><p>全局/静态区，全局变量和静态变量存放在一起，编译时分配</p>
</li>
<li><p>文字常量区，存放常量字符串</p>
</li>
<li><p>程序代码区，存放函数体（类成员函数，全局函数）的二进制码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> arr1[] = &#123; <span class="string">"abcdef"</span> &#125;;<span class="comment">//arr1 = 0x00d8fdf0 "abcdef"</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> arr2[] = &#123; <span class="string">"abcdef"</span> &#125;;<span class="comment">//arr2 = 0x00d8fde0 "abcdef"</span></span><br><span class="line"><span class="keyword">char</span> arr3[] = &#123;<span class="string">"abcdef"</span>&#125;;<span class="comment">//arr3 = 0x00d8fdd0 "abcdef"</span></span><br><span class="line"><span class="keyword">char</span> arr4[] = &#123;<span class="string">"abcdef"</span>&#125;;<span class="comment">//arr4 = 0x00d8fdc0 "abcdef"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* arr5 = &#123; <span class="string">"abcdef"</span> &#125;;<span class="comment">//arr5 = 0x00772cf0 "abcdef"</span></span><br><span class="line"><span class="keyword">char</span>* arr6 = &#123; <span class="string">"abcdef"</span> &#125;;<span class="comment">//arr6 = 0x00772cf0 "abcdef"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* arr7 = &#123; <span class="string">"abcdef"</span> &#125;;<span class="comment">//arr7 = 0x00772cf0 "abcdef"</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* arr8 = &#123; <span class="string">"abcdef"</span> &#125;;<span class="comment">//arr8 = 0x00772cf0 "abcdef"</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">字符串常量存放于文字常量区，指针只需要指向就可以。</span></span><br><span class="line"><span class="comment">而数组需要另外开辟一段内存存放该字符串</span></span><br><span class="line"><span class="comment">c字符串比较 strcmp</span></span><br><span class="line"><span class="comment">=0 相等</span></span><br><span class="line"><span class="comment">&gt;0 前大</span></span><br><span class="line"><span class="comment">&lt;0 前小</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="static-const关键字"><a href="#static-const关键字" class="headerlink" title="static const关键字"></a>static const关键字</h2><ul>
<li><p>static和const关键字的作用可以从两个方面回答：一是和类的成员函数或者成员变量相关，二是不属于类的函数或者变量。</p>
<ul>
<li><p>static关键字的作用：</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.static 修饰局部变量，该变量静态生存周期，且只被初始化一次</span></span><br><span class="line"><span class="comment">2.static 修饰全局变量，该变量静态生存周期，以及内部连接性，只能该文件访问</span></span><br><span class="line"><span class="comment">3.static 修饰全局函数，该函数内部连接性，只能本文件访问</span></span><br><span class="line"><span class="comment">4.static 修饰成员函数，该成员函数为类所有，没有this指针，只能访问static成员变量</span></span><br><span class="line"><span class="comment">5.static 修饰成员变量，该成员变量为类所有，对类的所有对象只是一份拷贝</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>const关键字的作用–只读</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、想要阻止一个变量被改变，可以使用const关键字。在定义该const关键字是，通常要对它进行初始化，因为以后再也没有机会去改变它。</span></span><br><span class="line"><span class="comment">2、对于指针来说，可以指定指针本身为const，也可以指定指针所指向的数据为const，或者二者同时指定为const。</span></span><br><span class="line"><span class="comment">3、在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值。</span></span><br><span class="line"><span class="comment">4、对于类的成员函数，若指定为const，则表明其实一个常函数，不能修改类的成员变量。</span></span><br><span class="line"><span class="comment">5、对于类的成员函数，有时候必须制定其返回值为const，以使得其返回值不能为左值。典型operator[]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="define-和const的区别"><a href="#define-和const的区别" class="headerlink" title="define 和const的区别"></a>define 和const的区别</h2><ul>
<li><p>区别</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">（1）就起作用的阶段而言： #define是在编译的预处理阶段起作用，而const是在 编译、运行的时候起作用。</span></span><br><span class="line"><span class="comment">（2）就起作用的方式而言： #define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级的错误。 </span></span><br><span class="line"><span class="comment">（3）就存储方式而言：#define不分配内存，给出的是立即数,只是进行展开，有多少地方使用，就替换多少次，它定义的宏常量在内存中有若干个备份；const,在静态存储区中分配空间,定义的只读变量在程序运行过程中只有一份备份。</span></span><br><span class="line"><span class="comment">（4）从代码调试的方便程度而言： const常量可以进行调试的，define是不能进行调试的，因为在预编译阶段就已经替换掉了。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>const 优点</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">（1）const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。</span></span><br><span class="line"><span class="comment">（2）有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试。</span></span><br><span class="line"><span class="comment">（3）const可节省空间，避免不必要的内存分配，提高效率</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><ul>
<li><p>指向的均为堆中对象，new出来的</p>
</li>
<li><p>unique_ptr</p>
<ul>
<li>独占方式，一次只能有一个指针指向对象，不允许拷贝和赋值</li>
<li>可通过临时对象或者move语义实现赋值</li>
<li>get函数获取原生指针</li>
<li>release放弃内部对象的所有权，内部指针置空，此指针需要手动释放</li>
<li>reset函数，销毁内部对象并接受新的对象</li>
<li>对象被销毁以及内存释放的时机<ul>
<li>当离开作用域或者reset时，释放</li>
</ul>
</li>
</ul>
</li>
<li><p>shared_ptr</p>
<ul>
<li>通过引用计数实现共享，使得多个指针可以同时指向一个对象</li>
<li>use_count查看资源的所有者个数</li>
<li>对象被销毁以及内存释放时机<ul>
<li>最后一个拥有该资源的shared_ptr destored</li>
<li>最后一个拥有该资源的shared_ptr 通过operator=赋值给其他，或者reset，即引用计数为0时</li>
</ul>
</li>
</ul>
</li>
<li><p>weak_ptr</p>
<ul>
<li><p>解决shared_ptr相互应用时的死锁问题</p>
</li>
<li><p>对对象的一种弱引用，不会增加对象的引用计数。和shared_ptr可以相互转换，shared_ptr赋值给weak_ptr，weak_ptr通过lock获得shared_ptr</p>
</li>
<li><p>通过lock返回是否是null或者shared_ptr判断，所指向的对象是否已经被释放</p>
</li>
<li><p>也可通过expired 返回true</p>
</li>
<li><p>以及use_count==0</p>
</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;B&gt; pb_;</span><br><span class="line">    ~A()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"A delete\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; pa_;</span><br><span class="line">    ~B()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"B delete\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;B&gt; pb(<span class="keyword">new</span> B());</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; pa(<span class="keyword">new</span> A());</span><br><span class="line">    pb-&gt;pa_ = pa;</span><br><span class="line">    pa-&gt;pb_ = pb;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pb.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pa.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="built_in">shared_ptr</span>&lt;B&gt; pb(<span class="keyword">new</span> B());</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;A&gt; pa(<span class="keyword">new</span> A());</span><br><span class="line">pb-&gt;pa_ = pa;</span><br><span class="line">pa-&gt;pb_ = pb;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;pb.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;pa.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><ul>
<li><p>移动语义–右值引用</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c；</span><br><span class="line"><span class="keyword">int</span>&amp;&amp; a=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp; b=c;<span class="comment">//error只能绑定右值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在一个有动态内存分配的类中，其拷贝构造函数，一定要实现深拷贝，涉及内存的分配，内存的拷贝</p>
</li>
<li><p>虽然右值引用参数绑定了右值，不过在函数内部，会当做左值来进行 </p>
</li>
<li><ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">X&#123;</span><br><span class="line">    <span class="keyword">private</span> </span><br><span class="line">    <span class="keyword">int</span>* x;</span><br><span class="line">    X(<span class="keyword">const</span> X&amp; other): <span class="comment">// 1</span></span><br><span class="line">		data(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>])</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">std</span>::copy(other.data,other.data+<span class="number">1000000</span>,data);</span><br><span class="line">	&#125;</span><br><span class="line">    X (X&amp;&amp; other): <span class="comment">// 2移动构造函数，实现浅拷贝</span></span><br><span class="line">		data(other.data)</span><br><span class="line">	&#123;</span><br><span class="line">		other.data=<span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_stuff</span><span class="params">(X&amp;&amp; x_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">X <span class="title">a</span><span class="params">(x_)</span></span>; <span class="comment">// 拷贝</span></span><br><span class="line">    <span class="function">X <span class="title">b</span><span class="params">(<span class="built_in">std</span>::move(x_))</span></span>; <span class="comment">// 移动</span></span><br><span class="line">&#125; </span><br><span class="line">do_stuff(X()); <span class="comment">// ok，右值绑定到右值引用上</span></span><br><span class="line">X x;</span><br><span class="line">do_stuff(x);</span><br></pre></td></tr></table></figure>
</li>
<li><p>unique_ptr 只支持移动构造不支持拷贝构造</p>
</li>
</ul>
</li>
<li><p>使用static_cast&lt;X&amp;&amp;&gt;或者move 将左值转换为右值</p>
</li>
</ul>
</li>
<li><p><strong>如果函数模板参数以右值引用作为一个模板参数，当对应位置提供左值的时候，模板会自动将其类型认定为左值引用；当提供右值的时候，会当做普通数据使用</strong> </p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">42</span>); <span class="comment">// foo&lt;int&gt;(42)</span></span><br><span class="line">foo(<span class="number">3.14159</span>); <span class="comment">// foo&lt;double&gt;&lt;3.14159&gt;</span></span><br><span class="line">foo(<span class="built_in">std</span>::<span class="built_in">string</span>()); <span class="comment">// foo&lt;std::string&gt;(std::string())</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line">foo(i); <span class="comment">// foo&lt;int&amp;&gt;(i)//引用的引用还是引用</span></span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">std</span>:</span>:remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">( T&amp;&amp; t )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">//返回值</span></span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt; <span class="title">struct</span> <span class="title">remove_reference</span>      &#123;</span><span class="keyword">typedef</span> T type;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt; <span class="title">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&gt;  &#123;</span><span class="keyword">typedef</span> T type;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt; <span class="title">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&amp;&gt; &#123;</span><span class="keyword">typedef</span> T type;&#125;;</span><br><span class="line"><span class="comment">//move本质上 是一个类型转换，本质上是通过static_cast实现的</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<ul>
<li><p>forward</p>
<ul>
<li><p><strong>解决在使用右值引用参数的函数模板中解决参数的完美转发问题</strong>。只有在它的参数绑定到一个右值上的时候，它才转换它的参数到一个右值</p>
</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常使用模式一个函数func1 去 转接 另一个函数func2时，直接去使用func2时问题不大</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(T1&amp;&amp; t1,T2&amp;&amp; t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func2(forward&lt;T1&gt;(t1),forward&lt;T2&gt;(t2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CoreFun</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"CoreFun"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ICoreFun</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"ICoreFun"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	CoreFun(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. A&amp; &amp;变成A&amp;</span></span><br><span class="line"><span class="comment">2. A&amp; &amp;&amp;变成A&amp;</span></span><br><span class="line"><span class="comment">3. A&amp;&amp; &amp;变成A&amp;</span></span><br><span class="line"><span class="comment">4. A&amp;&amp; &amp;&amp;变成A&amp;&amp;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当我ICoreFun(lvalue);的时候ICoreFun的函数原型是ICoreFun(CMyString&amp;)</span></span><br><span class="line"><span class="comment">当我ICoreFun(rvalue);的时候ICoreFun的函数原型是ICoreFun(CMyString&amp;&amp;)的：</span></span><br><span class="line"><span class="comment">虽然ICoreFun(CMyString("hello this is the rvalue")); 转换为了ICoreFun(CMyString&amp;&amp; t)，但是，t是一个左值，所以CoreFun(t);的时候调用的是拷贝构造函数来构造t</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">有没有办法，在上面的情况中，在CMyString&amp;&amp; t 传递给CoreFun(t)的时候，CoreFun(t)把t当作左值来处理呢？也就在t是CMyString&amp;&amp;类型的时候把t转换为右值，在t是CMyString&amp; t类型的时候不转换。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">实现转发左值就调用拷贝构造函数，抓发右值就调用右值类型的拷贝构造函数，完美。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">-------------------------------------</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CoreFun</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"CoreFun"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ICoreFun</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"ICoreFun"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	CoreFun(<span class="built_in">std</span>::forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<ul>
<li><p>std::forward<t>(u)有两个参数：T 与 u。<strong>当T为左值引用类型时，u将被转换为T类型的左值，否则u将被转换为T类型右值</strong>。如此定义std::forward是为了在使用右值引用参数的函数模板中解决参数的完美转发问题。</t></p>
<p><strong>std::move是无条件的转为右值引用，而std::forward是有条件的转为右值引用</strong>，更准确的说叫做Perfect forwarding(完美转发)，而std::forward里面蕴含着的条件则是Reference Collapsing(引用折叠)。</p>
<p>std::move不move任何东西。std::forward也不转发任何东西。在运行时，他们什么都不做。不产生可执行代码，一个比特的代码也不产生。</p>
</li>
</ul>
<h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><ul>
<li><p>strcpy</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* dst,<span class="keyword">const</span> <span class="keyword">char</span>* src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dst==<span class="literal">nullptr</span> || src==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(dst==src)</span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    <span class="keyword">char</span>* temp=dstt;</span><br><span class="line">    <span class="keyword">while</span>((*dst++ = *src++)!=<span class="string">'\0'</span>);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>手写智能指针的实现（shared_ptr和weak_ptr实现的区别）</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPointer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	SmartPointer(T* ptr)</span><br><span class="line">	&#123;</span><br><span class="line">		ref=ptr;</span><br><span class="line">		ref_count=(<span class="keyword">unsigned</span> <span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</span><br><span class="line">		*ref_count=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	SmartPointer(<span class="keyword">const</span> SmartPointer&lt;T&gt;&amp; other)</span><br><span class="line">	&#123;</span><br><span class="line">		ref=other.ref;</span><br><span class="line">		ref_count=other.ref_count;</span><br><span class="line">		++*ref_count;</span><br><span class="line">	&#125;</span><br><span class="line">	SmartPointer&amp; <span class="keyword">operator</span>=(SmartPointer&lt;T&gt;&amp; other)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>==&amp;other)</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">if</span>(--*ref_count==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			clear();</span><br><span class="line">		&#125;</span><br><span class="line">		ref=other.ref;</span><br><span class="line">		ref_count=other.ref_count;</span><br><span class="line">		++*ref_count;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> *ref;</span><br><span class="line">	&#125;</span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ref;</span><br><span class="line">	&#125;</span><br><span class="line">	~SmartPointer()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(--*ref_count==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			clear();</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">delete</span> ref;</span><br><span class="line">		<span class="built_in">free</span>(ref_count);</span><br><span class="line">		ref=<span class="literal">NULL</span>;</span><br><span class="line">		ref_count=<span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	T* ref;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>* ref_count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUniquePtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">explicit</span> <span class="title">MyUniquePtr</span><span class="params">(T* ptr = <span class="literal">nullptr</span>)</span></span></span><br><span class="line">        :mPtr(ptr)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~MyUniquePtr()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mPtr)</span><br><span class="line">            <span class="keyword">delete</span> mPtr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyUniquePtr(MyUniquePtr &amp;&amp;p) <span class="keyword">noexcept</span>;</span><br><span class="line">    MyUniquePtr&amp; <span class="keyword">operator</span>=(MyUniquePtr &amp;&amp;p) <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line">    MyUniquePtr(<span class="keyword">const</span> MyUniquePtr &amp;p) = <span class="keyword">delete</span>;</span><br><span class="line">    MyUniquePtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyUniquePtr &amp;p) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>*() <span class="keyword">const</span> <span class="keyword">noexcept</span> &#123;<span class="keyword">return</span> mPtr;&#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>-&gt;()<span class="keyword">const</span> <span class="keyword">noexcept</span> &#123;<span class="keyword">return</span> *mPtr;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>&#123;<span class="keyword">return</span> mPtr;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(T* q = <span class="literal">nullptr</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q != mPtr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mPtr)</span><br><span class="line">                <span class="keyword">delete</span> mPtr;</span><br><span class="line">            mPtr = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T* <span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T* res = mPtr;</span><br><span class="line">        mPtr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123;<span class="keyword">return</span> mPtr;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(MyUniquePtr &amp;p)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">        swap(mPtr, p.mPtr);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* mPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">MyUniquePtr&lt;T&gt;&amp; MyUniquePtr&lt;T&gt;::<span class="keyword">operator</span>=(MyUniquePtr &amp;&amp;p) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    swap(*<span class="keyword">this</span>, p);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">MyUniquePtr&lt;T&gt; :: MyUniquePtr(MyUniquePtr &amp;&amp;p) <span class="keyword">noexcept</span> : mPtr(p.mPtr)</span><br><span class="line">&#123;</span><br><span class="line">    p.mPtr == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ul>
</li>
</ul>
<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><ul>
<li><p>六大部件，空间配置器，容器，迭代器，适配器，算法，仿函数</p>
</li>
<li><p>不提供遍历行为的容器（不提供迭代器）</p>
<ul>
<li>stack</li>
<li>queue</li>
<li>priority-queue</li>
</ul>
</li>
<li><p>C++11新增</p>
<ul>
<li>unordered 系列</li>
<li>array</li>
<li>forward_list</li>
<li>tuple</li>
</ul>
</li>
</ul>
<h2 id="空间配置器"><a href="#空间配置器" class="headerlink" title="空间配置器"></a>空间配置器</h2><ul>
<li>构造和析构<ul>
<li>构造调用placement_new，调用相应类的构造函数</li>
<li>析构根据是否trivial_destructor调用不同版本函数模板</li>
</ul>
</li>
<li>空间配置器<ul>
<li>第一级配置器，<ul>
<li>allocate调用malloc，deallocate调用free</li>
<li>模拟C++的set_new_handler处理内存不足情况（客户端责任）</li>
<li>不断释放、配置，再释放、再配置</li>
</ul>
</li>
<li>二级空间配置器，当所申请的内存小于128字节时，调用<ul>
<li>避免小额区块带来的内存碎片以及额外负担（cookie）</li>
<li>维护16个自由链表，负责16种（8-128）小型区块的次配置能力，内存池以malloc配置而得，如果内存不足，转而调用第一级配置器<ol>
<li>如果需求块大于128byte，调用第一级配置器</li>
<li>如果freelist有可用的区块，直接返回节点，链表依次调整（链表头指向下一个可用的list节点）</li>
<li>如果没有可用区块，调整需求为8的倍数，从内存池中取默认20个区块（节点），可能小于20个<ol>
<li>如果内存池剩余空间满足需求，直接返回</li>
<li>如果内存池只能够一个区块，返回</li>
<li>如果内存池一个区块都没有，调整内存池的剩余空间，并malloc配置heap空间补充内存池，期间自调用，确定是否已经完成内存空间的分配，如果不行，再调用第一级空间配置器，如果可以，直接返回</li>
</ol>
</li>
</ol>
</li>
<li>deallocate释放内存时，如果大于128字节，直接free，否则加入到链表中</li>
</ul>
</li>
<li>刚开始初始化内存池时，内存池中没有数据，同时所有链表均为空</li>
<li>只有用户第一次向内存池申请内存，内存池才会完成内存池以及链表的首次填充，此时其他未使用的链表依然是空的</li>
</ul>
</li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ul>
<li>萃取机BIG FIVE<ul>
<li>reference type</li>
<li>difference_type</li>
<li>value_type</li>
<li>pointer</li>
<li>iterator_category</li>
</ul>
</li>
<li>迭代器种类用struct表示， 输入迭代器，输出迭代器，前向迭代器，双向迭代器，随机迭代器<ul>
<li>random-access<ul>
<li>array/vector/deque</li>
</ul>
</li>
<li>bidirectional<ul>
<li>list/rb-tree</li>
</ul>
</li>
<li>forward<ul>
<li>forwared-list</li>
</ul>
</li>
<li>hashtable<ul>
<li>根据底层链表实现</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="vector实现"><a href="#vector实现" class="headerlink" title="vector实现"></a>vector实现</h2><ul>
<li>维护三个迭代器<ul>
<li>start     begin()</li>
<li>finish    end()</li>
<li>end_of_storage 目前可使用空间的尾</li>
</ul>
</li>
<li>动态增加内存，而是以原大小2倍另外重新配置空间，迭代器失效问题</li>
<li>erase 或者insert 之后的迭代器失效，理论上，每次insert、erase后，所有的迭代器重新计算，所以都看作是失效的，原则是不能使用过期的内存。</li>
</ul>
<h2 id="list实现"><a href="#list实现" class="headerlink" title="list实现"></a>list实现</h2><ul>
<li>环状双向链表，用一个指针Node表示，insert、splice均不会引起迭代器失效，</li>
<li>指针Node刻意置于尾端的一个空白节点</li>
<li>以节点为单位存储数据，节点的地址在内存中不一定连续，每次插入或者删除一个元素，就配置或者释放一个元素空间</li>
<li>list merge 将两个list合并成一个，前提是必须经过递增排序</li>
<li>list sort 排序<ul>
<li>将前两个元素合并，再将后两个合并，然后合并这两个子序列为4个元素的子序列，重复，依次得到8,16，。。子序列，最后得到的就是排序后的序列 时间复杂度O（logN）</li>
<li>归并排序</li>
</ul>
</li>
</ul>
<h2 id="deque实现"><a href="#deque实现" class="headerlink" title="deque实现"></a>deque实现</h2><ul>
<li>对deque的排序，可以复制到vector上进行排序，后续复制到deque</li>
<li>deque  VS vector<ul>
<li>deque允许常数时间内对头端进行元素的插入和移除操作</li>
<li>deque没有容量观念，它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并连接起来</li>
</ul>
</li>
<li>deque以分段连续的空间组合构成，通过中控器map连接而成，map为一段连续空间，每个元素（节点）为指针，均指向另一段连续性空间（缓冲区，默认512字节）</li>
<li>deque迭代器<ul>
<li>cur指向当前缓冲区，当前所指元素</li>
<li>first当前缓冲区的头</li>
<li>last当前缓冲区的尾</li>
<li>map_pointer node 指向中控器</li>
</ul>
</li>
<li>deque 维护迭代器<ul>
<li>iterator start 第一个缓冲区的第一个元素 begin（）</li>
<li>iterator end 最后一个缓冲区的最后一个元素的下一个位置 end()</li>
<li>map_pointer map指向中控器</li>
<li>size_type map_size map中有几个指针</li>
</ul>
</li>
<li>push_back时，在最后一个节点的缓冲区从左往右push，如果缓冲区剩余个数大于2个，直接填充，否则，填充一个，缓冲区满，再扩充map</li>
<li>push_front时，在第一个节点的缓冲区从右往左push，若有空间则填充，否则扩充map</li>
</ul>
<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><ul>
<li>没有迭代器，最大堆实现（vector表现的完全二叉树）</li>
</ul>
<h2 id="set-map实现"><a href="#set-map实现" class="headerlink" title="set-map实现"></a>set-map实现</h2><ul>
<li><p>底层红黑树</p>
</li>
<li><p>set 迭代器 const iterator，不可以通过迭代器修改元素</p>
</li>
<li><p>set map 同list相同，当客户端对它进行元素insert和erase后，操作之前的所有迭代器在操作完成之后依然有效</p>
</li>
<li><p>自定义类提供compare函数</p>
</li>
<li><p>红黑树执行插入、删除、查找时间复杂度logN</p>
</li>
<li><p>set/map插入删除效率高</p>
<ul>
<li>不需要内存的拷贝和移动</li>
</ul>
</li>
<li><p>set/map每次insert、erase后之前保存的iterator不会失效</p>
<ul>
<li>插入操作只是结点指针换来换去，结点内存不变，而iterator就像指向结点的指针，内存不变，指向内存的指针也不变</li>
</ul>
</li>
</ul>
<h2 id="unordered-set-map实现"><a href="#unordered-set-map实现" class="headerlink" title="unordered-set/map实现"></a>unordered-set/map实现</h2><ul>
<li>底层 hashtable 不具有排序功能</li>
<li>自定义类提供hash函数以及等于函数</li>
<li>unordered-map VS map<ul>
<li>构造函数：unordered-map 提供hash 函数和等于函数，map提供比较函数</li>
<li>存储结构：unordered-map 底层 hashtable，不提供排序功能，map底层 rb-tree,提供排序功能</li>
<li>hash-map 查找速度快，查找速度和数据量大小无关，常数级别，map查找速度 logN</li>
<li>考虑效率，当元素数量到达一定数量级时，用unordered-map</li>
<li>考虑内存，或者元素数量较少用map</li>
<li>选用unordered-map还是map，关键看关键字查询操作次数，以及所要保证的是查询总体时间还是单个查询的时间。如果很多次操作，要求其整体效率，使用hash-map，平均处理时间短。如果少数次操作，使用hash-map导致不确定的O（N）。map用在平均处理时间相对较慢，单次处理事件恒定，整体稳定性高于整体效率，前提是操作次数少。</li>
</ul>
</li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul>
<li><h1 id="C-11-多线程"><a href="#C-11-多线程" class="headerlink" title="C++11 多线程"></a>C++11 多线程</h1></li>
<li><p>线程安全队列</p>
</li>
<li></li>
<li><p>线程池</p>
</li>
<li><p>自旋锁spinlock VS 互斥锁mutex</p>
<ul>
<li>自旋锁是一种非阻塞锁，也就是说，如果某线程需要获取自旋锁，但该锁已经被其他线程占用时，该线程不会被挂起，而是在不断的消耗CPU的时间，不停的试图获取自旋锁。</li>
<li>互斥量是阻塞锁，当某线程无法获取互斥量时，该线程会被直接挂起，该线程不再消耗CPU时间，当其他线程释放互斥量后，操作系统会激活那个被挂起的线程，让其投入运行。<ul>
<li>如果是多核处理器，如果预计线程等待锁的时间很短，短到比线程两次上下文切换时间要少的情况下，使用自旋锁是划算的。<br>如果是多核处理器，如果预计线程等待锁的时间较长，至少比两次线程上下文切换的时间要长，建议使用互斥量。<br>如果是<strong>单核处理器，一般建议不要使用自旋锁</strong>。因为，在同一时间只有一个线程是处在运行状态，那如果运行线程发现无法获取锁，只能等待解锁，但因为自身不挂起，所以那个获取到锁的线程没有办法进入运行状态，只能等到运行线程把操作系统分给它的时间片用完，才能有机会被调度。这种情况下使用自旋锁的代价很高。</li>
</ul>
</li>
</ul>
<h2 id="linux命令"><a href="#linux命令" class="headerlink" title="linux命令"></a>linux命令</h2><ul>
<li><p>chmod</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rw-r--r--</span><br><span class="line">r:<span class="number">4</span> w:<span class="number">2</span> x:<span class="number">1</span></span><br><span class="line"><span class="comment">//文件所有者权限+文件所属组的权限+其他用户的权限</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>文件系统的理解（EXT4，XFS，BTRFS）</p>
<p>文件处理grep,awk,sed这三个命令必知必会</p>
<p>IO复用的三种方法（select,poll,epoll）深入理解，包括三者区别，内部原理实现？</p>
<p>Epoll的ET模式和LT模式（ET的非阻塞）</p>
<p>查询进程占用CPU的命令（注意要了解到used，buf，cache代表意义）</p>
<p>linux的其他常见命令（kill，find，cp等等）</p>
<p>shell脚本用法</p>
<p>硬连接和软连接的区别</p>
<p>文件权限怎么看（rwx）</p>
<p>文件的三种时间（mtime, atime，ctime），分别在什么时候会改变</p>
<p>Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><ul>
<li><p>内存的连续分配</p>
<ul>
<li><p>单一连续分配</p>
<ul>
<li>内存在此方式下分为系统区、用户区。</li>
<li>系统区提供给操作系统使用，通常在低地址</li>
<li>用户区给用户使用</li>
<li>优点-简单，无内存碎片，可以采用覆盖技术，不需要额外的技术支持</li>
<li>缺点-只能适用于单用户、单任务的操作系统中，有内部碎片，存储器的利用率极低</li>
</ul>
</li>
<li><p>固定分区分配</p>
<ul>
<li>最简单的一种多道程序存储管理方式</li>
<li>将用户空间划分为若干个固定大小的区域，每个分区只装入一道作业</li>
<li>当有空闲分区时，再从外存的后备作业队列中，选择合适大小的作业装入该分区，如此循环</li>
<li>分区可以相等也可以不相等</li>
<li>存在问题<ul>
<li>程序可能太大而放不进去任何一个分区，不得不采用覆盖技术来使用内存空间</li>
<li>主存利用率低，当程序小于固定分区大小时，也占用了一个完整的内存分区空间，产生内部碎片。</li>
</ul>
</li>
</ul>
</li>
<li><p>动态分区分配</p>
<ul>
<li>又称可变分区分配，不预先将内存划分，而是在进程装入内存时，根据进程的大小动态的建立分区，并使分区的大小正适合进程的需要，系统中分区的大小和数目是可变的</li>
<li>动态分区分配算法<ul>
<li>首次适应算法：空闲分区以地址递增的次序连接。分配内存时顺序查找，找到第一个能满足要求的第一个空闲分区</li>
<li>最佳适应算法：空闲分区按照容量递增的顺序连接，找到第一个满足要求的空闲分区</li>
<li>临近适应算法：从当前位置开始，搜索第一个满足进程要求的内存空间</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>内存的非连续分配</p>
<ul>
<li><p>页式存储</p>
<ul>
<li><p>基本思想：用户程序的地址空间划分为固定大小的区域，称为页，相应内存空间也分为若干个物理块或页帧，页和块大小相等。将用户程序的任一页放在内存的任一块中，实现了离散分配；物理块不一定连续。每个页对应一个物理块。</p>
</li>
<li><p>逻辑地址结构：地址结构包含两部分。一个页表项占用四个字节，前20bit表示页号P，后12bit，表示页内偏移W。地址空间最多允许2^20页。</p>
</li>
<li><p>页表：程序数据存放在不同的页面中，而页面又离散的分散在内存中，需要一个页表来记录逻辑地址和实际存储地址之间的映射关系，以实现页号到物理块号的映射。</p>
</li>
<li><p>PS</p>
<ul>
<li><blockquote>
<p>每个进程也以块为单位进行划分。每一个进程都拥有一个自己的页表，PCB表中有指针指向页表。</p>
<p>分页存储管理方式中，又根据运行作业时是否要把作业的所有页面都装入内存才能运行分为<strong>基本分页存储</strong>管理方式和<strong>请求分页存储</strong>管理方式。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>地址变换-将逻辑地址转换为内存中的物理地址，借助于页表</p>
<ul>
<li>当程序执行时，将页表起始地址F和长度M存入页表寄存器</li>
<li>设页大小为L（一般4K（2^12B）），逻辑地址A-》物理地址E</li>
<li><img src="cpp-review/20190128164450968.png" alt="20190128164450968"></li>
<li>计算页号P=A/L和业内偏移量W=A%L；</li>
<li>比较页号P和页表长度M，如P》=M产生越界中断，否则继续执行</li>
<li>页表中页号P对应页表项地址b=页表起始地址F+页号P*页表项长度（4B），取出页表项中的内容，即为物理块号b</li>
<li>计算E=b*L+M，用得到的物理地址E去访问内存</li>
</ul>
</li>
<li><p>存在问题</p>
<ul>
<li>每次访问内存操作都需要进行逻辑地址到物理地址的转换，地址转换必须非常快，否则访问内存效率低</li>
<li>每个进程引入了页表，用于内存映射机制，页表不能太大，否则内存利用率低</li>
</ul>
</li>
<li><p>具有快表的地址变换结构</p>
<ul>
<li>若页表全部放在内存中，则取出一个数据或一条指令至少要访问两次内存</li>
<li>一次：从内存中访问页表，从中找到指定的物理块号，加上页内偏移量得到实际物理地址</li>
<li>二次：根据第一次得到的物理地址访问内存并取出数据</li>
<li>为提高地址变换速度，增设一个具有并行查询能力的特殊高速缓冲存储区，称为联想存储器或快表。存放当前访问的页表项。于此对应，主存中的页表为慢表</li>
<li><img src="cpp-review/20190128165747507.png" alt="20190128165747507"></li>
<li>访问过程<ul>
<li>逻辑地址的页号P直接在快表中查找，如果找到，得到对应的块号，直接转换为物理块号，这样存取数据仅需要一次访问内存就可以实现</li>
<li>若找不到，则访问慢表，在读出页表项后，同时将其存入块表</li>
</ul>
</li>
<li>理论依据：局部性原理<ul>
<li>时间上的局部性：最近访问的页在不久的将来还会被访问</li>
<li>空间上的局部性：内存中被访问的页周围的页很可能也被访问</li>
</ul>
</li>
</ul>
</li>
<li><p>二级页表</p>
<ul>
<li>解决问题：如果内存的逻辑地址很大，将会导致程序的页表项很多，而页表在内存中是连续存放的，所以就需要很大的连续空间。</li>
<li>一个页表项负责一页到一块（一页帧）的转换</li>
<li>一个进程占用2^32=4G字节，页表中每个条目是4字节（一个页表项4B），假设一页4K个字节，需要2^32/4K=2^20个页表项，需要2^20*4字节=4M字节大小</li>
<li>外层页表一次调入且连续存放，内存页表离散存放</li>
<li>一共需要访问3次内存：访问顶级页表-》二级页表-》访问内存中的数据</li>
<li><img src="cpp-review/20160425230849959-1572162931459.gif" alt="20160425230849959"></li>
<li>两级页表中，第一级为页目录，存在一个4K=2^12字节的页面中。页目录表共有1K=2^10个表项，每个表项为4个字节，并指向二级页表。线性地址的最高10bit产生第一级的索引，由索引得到的表项中指定并选择了1k个二级表中的表。</li>
<li>第二级为页表。也存在其一个4K字节的页面中，包含1K个字节的表项，每个表项包含一个页的物理基地址。第二级页表由线性地址的中间10bit进行索引，以获得包含页的物理地址的页表项，这个物理地址的高20bit与线性地址的第12bit形参了最后的物理地址。</li>
<li>一级页目录存放的是，二级页表的表头的地址</li>
<li>二级页表存放的是某页在内存中的物理块号</li>
<li><img src="cpp-review/1334370490_3589.jpg" alt="1334370490_3589"></li>
</ul>
</li>
</ul>
</li>
<li><p>段氏存储</p>
<ul>
<li><p>分页为了提高内存利用率，提升计算机的性能，且分页通过硬件机制实现，对用户完全透明</p>
</li>
<li><p>分段是为了满足程序员在编写代码的时候一些逻辑需求</p>
</li>
<li><p>思想</p>
<ul>
<li>将用户程序地址空间分成若干个大小不等的端，每段定义一组相对完整逻辑信息，每个段内部从0开始编址。存储时，以段为单位，每个段内部连续分配内存，段与段在内存中不相临接，实现了离散分配。例如，用户进程，有主程序、两个子程序、栈和一段数据组成。</li>
</ul>
</li>
<li><p>逻辑地址结构：段号S与段内偏移量W组成。如果为32地址，段号为16，段内偏移为16，则一个作业最多有2^16=65536个段，最大段长65536B即64KB。</p>
<ul>
<li><img src="cpp-review/20190128174333124.png" alt="20190128174333124"></li>
<li><strong>页式</strong>系统中，<strong>逻辑地址</strong>的页号和页内偏移量对用户是<strong>透明</strong>的，但在<strong>段式</strong>系统中，段号和段内偏移量必须由<strong>用户显示提供</strong>，在髙级程序设计语言中，这个工作由<strong>编译程序</strong>完成</li>
</ul>
</li>
<li><p>段表：每个进程都有一张逻辑空间与内存空间映射的段表，其中每一段表项对应进程的一个段。</p>
<ul>
<li><img src="cpp-review/20190128174734675.png" alt="20190128174734675"></li>
<li>访问内存的时候根据<strong>段号</strong>和<strong>段表项的长度</strong>计算当前访问段在<strong>段表中的位置</strong>，然后访问段表，得到该<strong>段的物理地址</strong>，根据该物理地址以及<strong>段内偏移量</strong>就可以得到需要访问的内存</li>
</ul>
</li>
<li><p>地址变换</p>
<ul>
<li><strong>段表寄存器</strong>存了段表始址<strong>F</strong>和段表长度<strong>M，</strong>从<strong>逻辑地址A</strong>到<strong>物理地址E</strong>之间的地址变换过程如下：</li>
<li>从逻辑地址A中取出段号S，段内偏移量W</li>
<li>比较段号S和段表长度M，若S多M，产生越界中断，否则继续执行</li>
<li>计算段号S对应的段表项地址=段表起始地址F+段号S*段表项长度，取出该段表项的前几位得到段长C。若段内偏移量&gt;=C，则产生越界中断，否则继续执行</li>
<li>取出段表项中该段的起始地址b，E=b+W,用得到的物理地址E访问内存</li>
<li><img src="cpp-review/20190128174904564.png" alt="20190128174904564"></li>
</ul>
</li>
<li><p>段的共享</p>
<ul>
<li><p><strong>允许若干个进程共享一个或多个分段</strong></p>
</li>
<li><p>通过两个作业的段表中相应表项执行被共享的段的同一个物理副本来实现的</p>
</li>
<li><p>不能修改的代码称为纯代码或可重入代码（不属于临界资源），这样的代码和不能修改的数据时可以共享的</p>
</li>
<li><p>而可修改的代码和数据不可共享</p>
</li>
<li><p>可重入代码：<strong>允许多个进程同时访问的代码</strong>。为使各个进程所执行的代码完全相同，</p>
<p>绝对不允许可重入代码在执行中有任何改变。因此，<strong>可重入代码</strong>是一种<strong>不允许任何进程对它进行修改的代码</strong></p>
</li>
<li><p>但事实上，大多数代码在执行时都可能有些改变，例如，用于控制程序执行次数的变量以及指针、信号量及数组等。为此，在每个进程中，都必须配以局部数据区，把在执行中可能改变的部分拷贝到该数据区，这样，程序在执行时，只需对该数据区（属于该进程私有）中的内容进行修改，并不去改变共享的代码，这时的可共享代码即成为可重入码</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>分页与分段的区别</p>
<ul>
<li><p>段优点</p>
<ul>
<li>优点-没有内部碎片，因为段大小可变，改变段大小来消除内部碎片</li>
<li>缺点-段换入换出时，产生外部碎片，（比如4k的段换5k的段）产生1k的外碎片</li>
</ul>
</li>
<li><p>页</p>
<ul>
<li>优点-没有外部碎片（页大小相同）</li>
<li>缺点-产生内部碎片（一个页可能填不满）</li>
</ul>
</li>
<li><p>区别</p>
<ul>
<li><p>目的不同：分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了更好的满足用户的需要，是信息的逻辑单位，含有一组意义相对完整的信息。</p>
</li>
<li><p>大小不同：页的大小固定且由系统决定（一般4K），段的长度不固定，由所完成的功能决定</p>
</li>
<li><p>地址空间不同：段向用户提供二维地址空间；页向用户提供一维地址空间；一个段在物理空间是连续的内存。<strong>分页</strong>的作业地址空间是<strong>一维的</strong>，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址；而<strong>分段</strong>的作业地址空间<strong>是二维的</strong>，程序员在标识一个地址时，既需给出<strong>段名</strong>，又需给出<strong>段内地址</strong>。</p>
</li>
<li><p>信息共享：段是信息的逻辑单位，便于存储保护和信息的共享，页是信息的物理单位，保护和共享受限</p>
</li>
<li><p>内存碎片：页没有外碎片，产生内部碎片。段没有内碎片，换入换出时产生外碎片</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>段页式存储</p>
<ul>
<li>页存储能有效的提高内存利用率，而分段存储能反映程序的逻辑结构并有利于段的共享</li>
<li>思想<ul>
<li>作业的地址空间首先被分为若干个逻辑段，每个段有自己的段号</li>
<li>再将每一段分成若干个大小固定的页</li>
<li>对内存空间的管理仍然和分页管理一样，将其分成若干个和页面大小相同的块，对内存的分配以块为单位</li>
<li><img src="cpp-review/20190128180745482.png" alt="20190128180745482"></li>
<li>每个进程建立一张段表，每个分段有一张页表</li>
</ul>
</li>
</ul>
</li>
<li><p>虚拟内存</p>
<ul>
<li>思想<ul>
<li>在程序装入时，将程序的一部分装入内存，将其剩余部分留在外存，启动程序执行。在执行过程中，当所访问的信息不再内存中时，由操作系统将所需要的部分调入内存，然后继续执行</li>
<li>虚拟内存容量=内存+外存</li>
<li>原理-局部性原理</li>
<li>实现方式<ul>
<li>请求分页式存储管理</li>
<li>请求分段式存储管理</li>
<li>请求段页式存储管理</li>
</ul>
</li>
</ul>
</li>
<li>请求分页式存储管理<ul>
<li>地址变换<ul>
<li>将当前需要的<strong>一部分页面</strong>装入内存，便可以启动作业运行。在作业执行过程中，当所要访问的页面不在内存时，再通过<strong>调页功能</strong>将其调入，同时还可以通过置换功能将暂时不用的页面<strong>换出到外存</strong>上，以便腾出内存空间</li>
<li><img src="cpp-review/20190128185944131.png" alt="20190128185944131"></li>
<li>缺页中断处理<ul>
<li>如果内存中有空闲块，则分配一个块，将要调入的页装入该块</li>
<li>若此时内存中没有空闲块，则要淘汰某页</li>
<li>若被淘汰的页在内存期间被修改过，则要将其写回外存</li>
</ul>
</li>
</ul>
</li>
<li>页面置换算法<ul>
<li><strong>最近最久未使用页面置换算法LRU</strong></li>
<li><strong>最优页面置换算法</strong><ul>
<li>所选择的被淘汰页面将是<strong>最长时间内不再被访问</strong>的页面</li>
</ul>
</li>
<li><strong>先进先出页面置换算法（FIFO）</strong><ul>
<li>总是<strong>淘汰最先进入内存的页面</strong>，即选择在内存中驻留时间最久的页面予淘汰。</li>
<li><strong>缺点</strong>：对于有些经常被访问的页面如含有全局变量、常用函数、例程等的页面，不能保证这些不被淘汰。</li>
</ul>
</li>
</ul>
</li>
<li>页面抖动（<strong>颠簸</strong>）<ul>
<li>频繁的页面调度行为，具体来讲，进程发生页面中断，这时，必须置换一页。然而，其他所有的页都在使用，它置换一页后，又立刻需要这个页。因此，会不断产生缺页中断，导致整个系统的效率急剧下降。</li>
<li>解决策略<ul>
<li>如果是页面置换策略失误，修改页面置换算法</li>
<li>如果是运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量</li>
<li>终止该进程或者增加物理内存容量</li>
</ul>
</li>
</ul>
</li>
<li>驻留集大小<ul>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="可重入函数"><a href="#可重入函数" class="headerlink" title="可重入函数"></a>可重入函数</h2><ul>
<li>在实时系统的设计中，经常会出现多个任务调用同一个函数的情况，不同任务调用这个函数时可能修改其他任务调用这个函数的数据，从而导致不可预料的后果</li>
<li>一个可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代码，而返回控制时不会出现什么错误</li>
<li>首先它意味着这个函数可以被中断，其次意味着它除了使用自己栈上的变量以外不依赖于任何环境（包括<br>static），这样的函数就是purecode（纯代码）可重入，可以允许有该函数的多个副本在运行，由于它们使用的是分离的栈，所以不会互相干扰。如果确实需要访问全局变量（包括static），一定要注意实施互斥手段。可重入函数在并行运行环境中非常重要，但是一般要为访问全局变量付出一些性能代价。</li>
<li>保证函数的可重入性的方法<ul>
<li>在写函数时候尽量使用局部变量（例如寄存器、堆栈中的变量）；</li>
<li>对于要使用的全局变量要加以保护（如采取关中断、信号量等互斥方法），这样构成的函数就一定是一个可重入的函数。</li>
</ul>
</li>
<li>满足下列条件的函数多数是不可重入（不安全）的：<ul>
<li>函数体内使用了静态的数据结构；</li>
<li>函数体内调用了malloc() 或者 free() 函数；</li>
<li>函数体内调用了标准 I/O 函数。</li>
</ul>
</li>
<li>将一个不可重入的函数改写成可重入函数<ul>
<li>不要使用全局变量。因为别的代码很可能改变这些变量值。</li>
<li>在和硬件发生交互的时候，切记执行类似 disinterrupt() 之类的操作，就是关闭硬件中断。完成交互记得打开中断，在有些系列上，这叫做“进入/ 退出核心”</li>
<li>不能调用其它任何不可重入的函数</li>
<li>谨慎使用堆栈</li>
</ul>
</li>
<li>常见可重入函数<ul>
<li>accept，socket，send，close，connect，fork，write，shutdown</li>
</ul>
</li>
</ul>
<h2 id="copy-on-write"><a href="#copy-on-write" class="headerlink" title="copy on write"></a>copy on write</h2><ul>
<li><p>linux中fork后，子进程会调用exec函数，</p>
</li>
<li><p>P1  fork P2子进程</p>
<ul>
<li>P2 （虚拟空间和物理空间）有自己的数据段，堆，栈，</li>
<li>P2的代码段的虚拟空间复制P1代码段的虚拟空间，P1 P2共享代码段的物理空间</li>
<li><img src="cpp-review/20180531111209270-1570539021425.jpg" alt="20180531111209270"></li>
</ul>
</li>
<li><p>写时复制</p>
<ul>
<li>P2的正文段，数据段，堆，栈有自己的虚拟空间，P1 P2共享物理空间</li>
<li><img src="cpp-review/2018053111122476.jpg" alt="2018053111122476"></li>
</ul>
</li>
<li><p>vfork</p>
<ul>
<li>P2 P1共享虚拟空间，相应的也共享物理空间</li>
<li><img src="cpp-review/20180531111239523.jpg" alt="20180531111239523"></li>
<li></li>
</ul>
</li>
</ul>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><ul>
<li>地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法</li>
<li>最优页面置换</li>
<li>LRU页面置换</li>
<li>先进先出（FIFO）</li>
<li>最近未使用（NRU）</li>
<li>第二次机会算法</li>
<li>时钟算法</li>
</ul>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><ul>
<li><p>先来先服务算法 FCFS</p>
<ul>
<li>有利于长作业，而不利于短作业，有利于CPU繁忙的作业，而不利于I/O繁忙的作业。</li>
</ul>
</li>
<li><p>最短作业优先（SJF）</p>
<ul>
<li>相比FCFS 算法，该算法可改善平均周转时间和平均带权周转时间，缩短进程的等待时间，提高系统的吞吐量。长进程可能一直得不到执行</li>
</ul>
</li>
<li><p>时间片轮转算法（RR）</p>
<ul>
<li>让就绪进程以FCFS 的方式按时间片轮流使用CPU 的调度方式，即将系统中所有的就绪进程按FCFS 原则，排成一个队列，每次调度时将CPU 分派给队首进程，让其执行一个时间片，时间片的长度从几个ms 到几百ms。在一个时间片结束时，发生时钟中断，调度程序据此暂停当前进程的执行，将其送到就绪队列的末尾，并通过上下文切换执行当前的队首进程，进程可以未使用完一个时间片，就出让CPU（如阻塞）</li>
<li>时间片轮转调度算法的特点是简单易行、平均响应时间短，不利于处理紧急作业，且时间片的选取是否合理也是一个问题</li>
</ul>
</li>
<li><p>多级反馈队列（MFQ）–根据先来先服务原则给就绪队列排序，为就绪队列赋予不同的优先级数，不同的时间片，按照优先级抢占CPU的调度算法</p>
<ul>
<li>按照先来先服务原则排序，设置N个就绪队列为Q1，Q2…QN，每个队列中都可以放很多作业</li>
<li>为这N个就绪队列赋予不同的优先级，第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低；</li>
<li>设置每个就绪队列的时间片，优先权越高，算法赋予队列的时间片越小。时间片大小的设定按照实际作业（进程）的需要调整</li>
<li>进程在进入待调度的队列等待时，首先进入优先级最高的Q1等待。</li>
<li>首先调度优先级高的队列中的进程。若高优先级中队列中已没有调度的进程，则调度次优先级队列中的进程。例如：Q1,Q2,Q3三个队列，只有在Q1中没有进程等待时才去调度Q2，同理，只有Q1,Q2都为空时才会去调度Q3。</li>
<li>对于同一个队列中的各个进程，按照时间片轮转法调度。比如Q1队列的时间片为N，那么Q1中的作业在经历了时间片为N的时间后，若还没有完成，则进入Q2队列等待，若Q2的时间片用完后作业还不能完成，一直进入下一级队列，直至完成。</li>
<li>在低优先级的队列中的进程在运行时，又有新到达的作业，那么在运行完这个时间片后，CPU马上分配给新到达的作业即抢占式调度CPU。</li>
</ul>
</li>
<li><p>linux 进程调度</p>
<ul>
<li><p>O(n)调度器把时间分成大量的微小时间片（Epoch）。在每个时间片开始的时候，调度器会检查所有处在就绪状态的进程。调度器计算每个进程的优先级，然后选择优先级最高的进程来执行。如果进程没有用尽时间片，那么该时间片的剩余时间会增加到下一个时间片中。</p>
<p>O(n)调度器在每次使用时间片前都要检查所有就绪进程的优先级。这个检查时间和进程中进程数目n成正比，这也正是该调度器复杂度为O(n)的原因。当计算机中有大量进程在运行时，这个调度器的性能将会被大大降低。也就是说，O(n)调度器没有很好的可拓展性。O(n)调度器是Linux  2.6之前使用的进程调度器。</p>
</li>
<li><p>O(1)调度器的创新之处在于，它会把进程按照优先级排好，放入特定的数据结构中。在选择下一个要执行的进程时，调度器不用遍历进程，就可以直接选择优先级最高的进程。</p>
</li>
<li><p>O(1)调度器会用两个队列来存放进程。一个队列称为活跃队列，用于存储那些待分配时间片的进程。另一个队列称为过期队列，用于存储那些已经享用过时间片的进程。</p>
<p>O(1)调度器把时间片从活跃队列中调出一个进程。这个进程用尽时间片，就会转移到过期队列。当活跃队列的所有进程都被执行过后，调度器就会把活跃队列和过期队列对调，用同样的方式继续执行这些进程。</p>
<p>操作系统会创建140个活跃队列和过期队列，对应优先级0到139的进程。一开始，所有进程都会放在活跃队列中。</p>
<p>然后操作系统会从优先级最高的活跃队列开始依次选择进程来执行，如果两个进程的优先级相同，他们有相同的概率被选中。执行一次后，这个进程会被从活跃队列中剔除。如果这个进程在这次时间片中没有彻底完成，它会被加入优先级相同的过期队列中。当140个活跃队列的所有进程都被执行完后，过期队列中将会有很多进程。调度器将对调优先级相同的活跃队列和过期队列继续执行下去。</p>
</li>
<li><p>CFS调度器增加了一个虚拟运行时（virtual runtime）的概念。每次一个进程在CPU中被执行了一段时间，就会增加它虚拟运行时的记录。在每次选择要执行的进程时，不是选择优先级最高的进程，而是选择虚拟运行时最少的进程。用一种叫红黑树的数据结构取代了O(1)调度器的140个队列。红黑树可以高效地找到虚拟运行最小的进程。</p>
</li>
</ul>
</li>
</ul>
<h2 id="内存分配方式及错误"><a href="#内存分配方式及错误" class="headerlink" title="内存分配方式及错误"></a>内存分配方式及错误</h2><ul>
<li><p>从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。</p>
</li>
<li><p>在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p>
</li>
<li><p>从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。</p>
</li>
<li><p>常见的内存错误及其对策</p>
<ul>
<li>内存分配未成功，却使用了它<ul>
<li>在使用内存之前检查指针是否为NULL</li>
</ul>
</li>
<li>内存分配虽然成功，但是尚未初始化就引用它</li>
<li>内存分配成功并且已经初始化，但操作越过了内存的边界</li>
<li>忘记了释放内存，造成内存泄露</li>
<li>释放了内存却继续使用它</li>
</ul>
</li>
<li><p><strong>【规则1】</strong>用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。</p>
<p><strong>【规则2】</strong>不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。</p>
<p><strong>【规则3】</strong>避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作。</p>
<p><strong>【规则4】</strong>动态内存的申请与释放必须配对，防止内存泄漏。</p>
<p><strong>【规则5】</strong>用free或delete释放了内存之后，立即将指针设置为NULL，防止产生“野指针”。</p>
</li>
</ul>
<h2 id="内存溢出VS内存泄漏"><a href="#内存溢出VS内存泄漏" class="headerlink" title="内存溢出VS内存泄漏"></a>内存溢出VS内存泄漏</h2><ul>
<li><p>内存溢出—-系统已经不能再分配出你所需要的空间，比如你需要100M的空间，系统只剩90M了，这就叫内存溢出</p>
</li>
<li><p>内存泄漏—-你用资源的时候为他开辟了一段空间，当你用完时忘记释放资源了，这时内存还被占用着，一次没关系，但是内存泄漏次数多了就会导致内存溢出</p>
</li>
<li><p><strong>VS下检测内存泄漏方法：</strong></p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRTDBG_MAP_ALLOC    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;crtdbg.h&gt;    </span></span></span><br><span class="line"><span class="comment">//在入口函数中包含 _CrtDumpMemoryLeaks();    </span></span><br><span class="line"><span class="comment">//即可检测到内存泄露  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以如下测试函数为例：  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* pChars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//delete[]pChars;</span></span><br><span class="line">    _CrtDumpMemoryLeaks();</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/在入口函数中包含 _CrtDumpMemoryLeaks();</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="虚拟内存VS-swap分区"><a href="#虚拟内存VS-swap分区" class="headerlink" title="虚拟内存VS swap分区"></a>虚拟内存VS swap分区</h2><ul>
<li>windows：虚拟内存<br>linux：swap分区</li>
<li>windows即使物理内存没有用完也会去用到虚拟内存，而Linux不一样 Linux只有当物理内存用完的时候才会去动用虚拟内存（即swap分区）</li>
<li>Windows可以设置在windows的任何盘符下面，默认是在C盘，可以和系统文件放在一个分区里。而linux则是独立占用一个分区，方便由于内存需求不够的情况下，把一部分内容放在swap分区里，待内存有空余的情况下再继续执行，也称之为交换分区，交换空间是其中的部分</li>
</ul>
<h2 id="中断VS异常"><a href="#中断VS异常" class="headerlink" title="中断VS异常"></a>中断VS异常</h2><ul>
<li>中断是由于外部设备事件所引起的中断</li>
<li><strong>异常</strong>——是指由于 CPU 内部事件所引起的中断，如程序出错</li>
<li><strong>异常是由于执行了现行指令所引起的。由于系统调用引起的中断属于异常。</strong></li>
<li><strong>中断则是由于系统中某事件引起的，该事件与现行指令无关</strong></li>
<li><strong>相同点：</strong>都是<strong>CPU</strong>对<strong>系统</strong>发生的某<strong>个事情</strong>做出的<strong>一种反应</strong>。</li>
<li><strong>区别：中断</strong>由<strong>外因引起</strong>，<strong>异常</strong>由<strong>CPU本身</strong>原因引起。</li>
<li><strong>中断不是时钟同步的，这意味着中断可能随时到来；异常由于是CPU产生的，所以，它是时钟同步的</strong></li>
<li><strong>当处理中断时，处于中断上下文中；处理异常时，处于进程上下文中</strong></li>
</ul>
<h2 id="进程终止的方式"><a href="#进程终止的方式" class="headerlink" title="进程终止的方式"></a>进程终止的方式</h2><ul>
<li><p><img src="cpp-review/20171208095645231.png" alt="20171208095645231"></p>
</li>
<li><p>5中正常终止</p>
<ul>
<li>main函数执行return，等效于调用exit</li>
<li>调用exit函数。标准C库中一个函数</li>
<li>调用_exit、_Exit函数，系统调用</li>
<li>进程的最后一个线程在启动例程中执行return</li>
<li>进程的最后一个线程调用pthread_exit函数。</li>
</ul>
</li>
<li><p>3中异常终止</p>
<ul>
<li>调用abort。产生SIGABRT信号</li>
<li>当进程收到某些信号时。信号可由进程自身、其他进程或内核产生</li>
<li>最后一个线程对“取消”请求作出回应</li>
</ul>
</li>
</ul>
<h2 id="特殊进程"><a href="#特殊进程" class="headerlink" title="特殊进程"></a>特殊进程</h2><ul>
<li><p>进程ID</p>
<ul>
<li>PID，进程的唯一标识，同一个进程的所有线程getpid函数都返回同一值</li>
<li>PGID进程组ID，每个进程都会有进程组ID，表示该进程所属的进程组</li>
<li>SID，会话ID。默认情况下，新创建的进程会继承父进程的会话ID。</li>
</ul>
</li>
<li><p>孤儿进程</p>
<ul>
<li>一个父进程已终止的进程为孤儿进程，由Init进程进行收养，并由init进程对它们完成状态收集工作。</li>
</ul>
</li>
<li><p>僵尸进程</p>
<ul>
<li>一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中</li>
<li>ps 命令 有Z标识的进程</li>
<li><strong>通过信号机制</strong><ul>
<li>子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程</li>
</ul>
</li>
<li><strong>两次fork()</strong><ul>
<li>原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程</li>
<li>对于父进程的第一个子进程，父进程仍然需要wait/wait_pid</li>
</ul>
</li>
</ul>
</li>
<li><p>守护进程</p>
<ul>
<li>守护进程就是在后台运行，不与任何终端关联的进程，通常情况下守护进程在系统启动时就在运行，它们以root用户或其他特殊用户运行，并能处理一些系统级的任务。</li>
<li>守护进程的名称通常以d结尾</li>
<li>进程组和会话在进程之间形成了两级的层次：进程组是一组相关进程的集合，会话是一组相关进程组的集合</li>
<li>当有新的用户登录linux时，登录进程为这个用户建立一个会话。用户的登录shell就是会话的首进程。会话的首进程ID会作为整个会话的ID。会话时一个或者多个进程组的集合，囊括了登录用户的所有活动。</li>
<li>会话开始于用户登录，终止于用户退出。一个会话包括一个会话首进程、一个前台进程组（只有一个）和一个后台进程组（可以多个）</li>
<li><img src="cpp-review/20160624093011_365.png" alt="20160624093011_365"></li>
<li>创建一个守护进程<ul>
<li>fork创建一个子进程，父进程exit退出<ul>
<li>孤儿进程被Init收养</li>
</ul>
</li>
<li>在子进程调用setsid()创建新会话<ul>
<li>在调用fork之后，子进程全盘拷贝了父进程的会话期，进程组、控制终端等，虽然父进程退出了，但会话期、进程组、控制终端等并没有改变。setsid可以使进程完全独立出来。</li>
<li>setsid创建一个会话。调用进程担任新会话的首进程，其作用有<ul>
<li>使当前进程脱离原会话的控制</li>
<li>使当前进程脱离原进程组的控制</li>
<li>时当前进程脱离原控制终端的控制</li>
</ul>
</li>
</ul>
</li>
<li>再fork一个子进程，父进程exit退出<ul>
<li>现在进程已经成为无终端的会话组长，但它可以重新申请打开一个控制终端，可以同故宫fork一个子进程，该子进程不是会话首进程，不能重新打开控制终端。退出父进程</li>
<li>即，通过再次创建子进程结束当前进程，使进程不再是会话首进程来禁止进程重新打开控制终端。</li>
</ul>
</li>
<li>再子进程中调用chdir(“/“)使得”/“成为子进程的工作目录<ul>
<li>使用fork创建的子进程继承了父进程的当前工作目录</li>
<li>当前目录所在的文件系统（如“/mnt/usb”）是不能卸载的</li>
<li>避免原父进程当前目录带来的一些麻烦</li>
</ul>
</li>
<li>再子进程中调用umaks（0）重设文件权限码为0<ul>
<li>由于使用fork创建子进程继承了父进程的文件权限掩码，则会个就该子进程使用文件带来了诸多的麻烦。因此把文件权限掩码重新设置为0即清楚掩码（权限为777），增强了守护进程的灵活性</li>
<li>相当于把权限开放</li>
</ul>
</li>
<li>在子进程中close不需要的文件描述符<ul>
<li>关闭失去价值的输入、输出、报错等对应的文件描述符</li>
</ul>
</li>
<li>守护进程的退出处理<ul>
<li>kill</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="怎么回收线程"><a href="#怎么回收线程" class="headerlink" title="怎么回收线程"></a>怎么回收线程</h2><ul>
<li>单个线程可以通过3中方式退出，可以在不终止整个进程的情况下，停止它的工作流<ul>
<li>线程可以简单的从启动例程中返回，返回值为线程的退出码</li>
<li>线程可以被同一进程中的其他线程取消</li>
<li>线程调用pthread_exit</li>
</ul>
</li>
<li>线程分为可结合的（joinable）和 分离的（detached）两种，如果没有在创建线程时设置线程的属性为<code>PTHREAD_CREATE_DETACHED</code>，则线程默认是可结合的。 分离的线程在线程退出时系统会自动回收资源。可结合的线程在线程退出后不会立即释放资源，必须要调用pthread_join来显式的结束线程。 <ul>
<li>子线程使用return退出，主线程中使用<code>pthread_join</code>回收线程。 </li>
<li>子线程使用<code>pthread_exit</code>退出，主线程中使用<code>pthread_join</code>接收<code>pthread_exit</code>的返回值，并回收线程。 </li>
<li>主线程中调用<code>pthread_cancel</code>,然后调用<code>pthread_join</code>回收线程。</li>
</ul>
</li>
</ul>
<h2 id="进程-线程数量"><a href="#进程-线程数量" class="headerlink" title="进程/线程数量"></a>进程/线程数量</h2><ul>
<li><strong>Linux中有一个命令可以帮助我们查看系统中的进程上限</strong><ul>
<li>ulimit -u</li>
<li>修改为   5120 ulimit -u 5120</li>
<li>cat /proc/sys/kernel/pid_max</li>
</ul>
</li>
<li>一个进程中最多可以有多少个线程<ul>
<li>创建一个线程会占用多少内存，这取决于分配给线程的调用栈大小，可以用ulimit -s命令来查看大小，显示的单位是KB（一般常见的有10M或者是8M，也可以临时修改）</li>
<li>一个进程的虚拟内存是4G（32位系统，寻址指针4字节，2^32），在Linux32位平台下，内核分走了1G，留给用户用的只有3G，于是我们可以想到，创建一个线程占有了10M内存，总共有3G内存可以使用。于是可想而知，最多可以创建差不多300个左右的线程。</li>
</ul>
</li>
</ul>
<h2 id="一个程序从开始运行到结束的完整过程"><a href="#一个程序从开始运行到结束的完整过程" class="headerlink" title="一个程序从开始运行到结束的完整过程"></a>一个程序从开始运行到结束的完整过程</h2><ul>
<li>预处理—-gcc -E test.c -o test.i，其中，参数E告诉gcc命令值经行编译，不做其他的处理，用参数o指明输出的文件名为test.i。命令运行完毕后就会产生一个名为test.i的文件。<ul>
<li>编译预处理主要是读取c源程序，对其中的伪指令（以#开头的指令）和特殊符号进行处理，条件编译，头文件包含，宏替换的处理。</li>
</ul>
</li>
<li>编译—–gcc - S test.i -o test.s,其中参数S告诉gcc命令只进行编译，不做其他处理<ul>
<li>预编译程序所要作得工作就是通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。</li>
</ul>
</li>
<li>汇编—-“gcc -c test.s -o test.o”,其中，参数c告诉gcc命令只进行汇编<ul>
<li>汇编过程主要的作用是汇编过程实际上指把汇编语言代码翻译成目标机器指令的过程</li>
</ul>
</li>
<li>链接—-“gcc test.o -o test”,运行完成后就会产生一个名为test的可执行文件。<ul>
<li>链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号 同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。</li>
<li>静态链接VS动态链接<ul>
<li>静态链接:后缀是.a，主要在编译的时候将库文件里面代码搬迁到可执行的文件中；</li>
<li>动态链接：后缀是.so,主要在执行的时候将需要的库文件代码搬迁到可以执行的文件中；</li>
<li>静态的链接产生的可执行的文件体积比较的大；而动态链接的可执行文件的体积比较小；</li>
<li>动态的链接的编译的效率比较的高；</li>
<li>静态链接的可执行的文件执行的效率高</li>
<li>静态链接的可执行的文件的“布局”比较好一点；</li>
<li>动态链接更加适合频繁更新的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="用户态VS内核态"><a href="#用户态VS内核态" class="headerlink" title="用户态VS内核态"></a>用户态VS内核态</h2><ul>
<li>当一个进程在执行用户自己的代码时处于用户运行态（用户态），只能受限的访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取</li>
<li>当一个进程因为系统调用陷入内核代码中执行时处于内核运行态（内核态），内核态：cpu可以访问内存的所有数据，包括外围设备</li>
<li>切换<ul>
<li>系统调用</li>
<li>异常</li>
<li>外围设备的中断</li>
</ul>
</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><ul>
<li>死锁是指多个进程在运行过程中因争夺资源而造成的一种僵局。当进程处于这种僵局时，若无外力作用，都将无法在向前推进</li>
<li>原因<ul>
<li>竞争资源。当系统中多个进程共享的资源数目不足以满足进程的需要时，引起进程对资源的竞争</li>
<li>进程间的推进顺序非法。进程在运行过程中，请求和释放资源的顺序不当，也会造成死锁。</li>
</ul>
</li>
<li>必要条件<ul>
<li>互斥条件。进程要求对所分配的资源进行排他性控制，即在一段时间内某资源仅为一进程所有。</li>
<li>请求和保持条件。当进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不可剥夺条件。进程已获得的资源在未使用完之前，不能剥夺，只能在使用完毕时自己释放。</li>
<li>环路等待条件。在发生死锁时，必然存在一个进程–资源的环形链。</li>
</ul>
</li>
<li>解决方法<ul>
<li>避免死锁<ul>
<li>加锁顺序</li>
<li>加锁时限</li>
<li>死锁检测</li>
</ul>
</li>
<li>预防死锁<ul>
<li>资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）</li>
<li>只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏保持条件）</li>
<li>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</li>
<li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h2><ul>
<li><p>管道，半双工的通信方式，数据只能单向流动，而且只能在具有父子进程间使用。</p>
</li>
<li><p>有名管道，半双工的通信方式，但是它允许无亲缘关系进程间的通信 </p>
</li>
<li><p>信号量，一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，<br>防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同<br>一进程内不同线程之间的同步手段 .当信号量为正，进程可以使用该资源。信号量-1.表示使用了一个资源单位。若为0，进程进入到休眠状态，直到信号量大于0，进程被唤醒。</p>
</li>
<li><p>消息队列 ，由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 一个消息由，一个正的长整型类型的字段，一个非负的长度以及实际的数据字节数组成。</p>
</li>
<li><p>信号 ，通知接收进程某个事件已经发生。 </p>
</li>
<li><p>共享内存 ，映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多<br>个进程都可以访问 ，共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率<br>低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和<br>通信。 </p>
</li>
<li><p>套接字，可用于不同设备及其间的进程通信。</p>
</li>
</ul>
<ul>
<li><p>线程间通讯方式</p>
<ul>
<li>锁机制：包括互斥锁、条件变量、读写锁 ，<ul>
<li>互斥锁提供了以排他方式防止数据结构被并发修改的方法。 读写锁允许多个线程同时读共<br>享数据，而对写操作是互斥的。 条件变量可以以原子的方式阻塞进程，直到某个特定条件<br>为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。 </li>
</ul>
</li>
<li>信号量机制(Semaphore)：<ul>
<li>包括无名线程信号量和命名线程信号量 </li>
</ul>
</li>
<li>信号机制(Signal)：类似进程间的信号处理<ul>
<li>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通<br>信机制。 </li>
</ul>
</li>
</ul>
</li>
<li><p>mutex+condition_variable VS  semaphore</p>
<ul>
<li><p>条件变量(condition variable)是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待某个条件为真，而将自己挂起；另一个线程使的条件成立，并通知等待的线程继续。为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起</p>
</li>
<li><p>使用条件变量可以一次唤醒所有等待者，而这个信号量没有的功能，感觉是最大区别</p>
</li>
<li><p>信号量是有一个值（状态的），而条件变量是没有的，没有地方记录唤醒（发送信号）过多少次，也没有地方记录唤醒线程（wait返回）过多少次。从实现上来说一个信号量可以是用mutex + counter + condition variable实现的。因为信号量有一个状态，如果想精准的同步，那么信号量可能会有特殊的地方。信号量可以解决条件变量中存在的唤醒丢失问题。</p>
</li>
<li><p>在Posix.1基本原理一文声称，有了互斥锁和条件变量还提供信号量的原因是：“本标准提供信号量的而主要目的是提供一种进程间同步的方式；这些进程可能共享也可能不共享内存区。互斥锁和条件变量是作为线程间的同步机制说明的；这些线程总是共享(某个)内存区。这两者都是已广泛使用了多年的同步方式。每组原语都特别适合于特定的问题”。尽管信号量的意图在于进程间同步，互斥锁和条件变量的意图在于线程间同步，但是信号量也可用于线程间，互斥锁和条件变量也可用于进程间。应当根据实际的情况进行决定。信号量最有用的场景是用以指明可用资源的数量。</p>
</li>
<li><p>唤醒操作（SetEvent和pthread_cond_signal）原本意图是唤醒一个等待的线程，但是在多核处理器下，可能会激活多个等待的线程，这种效应为“虚假唤醒”</p>
</li>
</ul>
</li>
<li><p>如果在等待条件变量（pthread_cond_wait）前，条件变量就被唤醒激活（pthread_cond_signal），那么这次唤醒就会丢失</p>
</li>
</ul>
<h2 id="linux-IO模型"><a href="#linux-IO模型" class="headerlink" title="linux IO模型"></a>linux IO模型</h2><ul>
<li>IO的本质是socket的读取，数据先拷贝到内核的缓冲区中，然后拷贝到应用程序的地址空间（进程）</li>
<li>阻塞IO，所有套接字默认的都是阻塞的，以recvfrom系统调用为例子，它要等到有数据报到达且被复制到应用进程的缓冲区中或者发生了错误才返回。若没有数据到达那么将一直会阻塞。</li>
<li>同步非阻塞IO，非阻塞等待，每隔一段时间就去检查IO时间是否就绪，没有就绪就可以做其他事。在I/O执行的第二个阶段（数据复制）被block了，而第一个阶段并未阻塞（数据准备），但是在第一个阶段中，用户进程需要盲等，不停的去轮询内核，看数据是否准备好了。<ul>
<li>设置套接字为非阻塞式，并在第一阶段IO准备时，不断去轮询查看IO是否准备就绪，准备就绪后，在IO数据拷贝阶段阻塞执行。</li>
</ul>
</li>
<li>信号驱动IO，linux使用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号，然后处理IO事件。信号驱动I/O执行的第一阶段不阻塞，而第二阶段是阻塞的。用信号让内核在文件描述符准备就绪的时候通知用户进程，即是告知我们什么时候可以启动IO操作。就如数据准备好了，内核就会以一种形式通知用户进程。<ul>
<li>用信号让内核在文件描述符准备就绪的时候通知用户进程，即是告知我们什么时候可以启动IO操作。就如数据准备好了，内核就会以一种形式通知用户进程</li>
</ul>
</li>
<li>IO复用（同步阻塞），linux用slelect epoll实现IO复用，也会使进程阻塞，但是和阻塞IO不同的是，IO复用可以同时阻塞多个IO操作，而且可以同时对多个读/写操作的IO函数进行检测。直到有数据可读、可写时，才调用IO操作函数。<strong>IO多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上。</strong>多路复用I/O执行的两个阶段用户进程都是阻塞的，但是两个阶段是独立的。<ul>
<li>通过系统调用select、poll、epoll、kqueue实现IO复用模型。进程就阻塞在这些系统调用上，而不是阻塞在真正的IO操作上，直到有就绪事件了，这些系统调用就会返回哪些套接字可读写，然后就可以进行把数据包复制到应用进程缓冲区了</li>
</ul>
</li>
<li>异步IO（异步非阻塞）：相对于同步IO，异步IO不是顺序执行。<code>用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情</code>。等到socket数据准备好了，内核直接复制数据给进程，<code>然后从内核向进程发送通知</code>。<code>IO两个阶段，进程都是非阻塞的</code>。<ul>
<li>由用户进程告知内核启动一个操作，并且由内核去操作，操作完后给用户进程发一个通知，通知用户进程操作完了（包括数据从内核缓冲区拷贝到用户缓冲区的过程）。该模型与信号驱动式IO模型不同的就是，异步IO模型中，是由内核通知IO操作什么时候完成，而信号驱动式IO是由内核告知何时启动IO操作</li>
</ul>
</li>
<li><img src="cpp-review/1568374913878.png" alt="1568374913878"></li>
<li>阻塞IO和非阻塞IO的区别：数据准备的过程中,进程是否阻塞。</li>
<li>同步IO和异步IO的区别：数据拷贝的过程中,进程是否阻塞。</li>
<li>阻塞，非阻塞：进程/线程要访问的数据是否就绪，进程线程是否需要等待</li>
<li>同步，异步：访问数据的方式，同步需要主动读写数据，在读写数据的过程中还是会阻塞；异步只需要I/O操作的完成的通知，并不主动读写数据，由操作系统内核完成数据的读写。</li>
<li>阻塞的读<ul>
<li>如果内核的接受缓冲区中没有数据到达，那么就会一直阻塞，read函数在没有数据的时候，被挂起不返回，如果有数据，那么就是有多少就读多少</li>
</ul>
</li>
<li>阻塞的写<ul>
<li>用户进程有多少数据就要将所有数据都写入到内核的可写缓冲区才返回，。如果内核可写缓冲区可以容纳N个字节，而要发送的字节为N+1的话，那么write不返回，它会一直阻塞到那多出来的一个字节装到内核缓冲区才返回。，所以在select中，返回可写条件时，将套接字设置为非阻塞，才可以说一次写操作返回一个正值。</li>
</ul>
</li>
<li>非阻塞的读<ul>
<li>如果没有数据，read调用不会挂起，会立即返回。有数据的话，就有多少就读多少</li>
</ul>
</li>
<li>非阻塞的写<ul>
<li>内核缓冲区够写多少就写多少，能够写多少根据网络阻塞情况为标准，当阻塞严重时，没有足够的缓冲区去写的话，就会出现写不完的情况。</li>
</ul>
</li>
</ul>
<h2 id="select-VS-epoll"><a href="#select-VS-epoll" class="headerlink" title="select VS epoll"></a>select VS epoll</h2><ul>
<li>select 支持的fd数量有限，单个进程能够监视的文件描述符的数量存在限制，通常1024</li>
<li>每次调用select，都会把fd从用户态拷贝到内核态</li>
<li>使用轮询方式，需遍历所有fd</li>
<li>poll的实现和select非常相似，只是描述fd集合的方式不同，poll使用pollfd结构而不是select的fd_set结构，其他的都差不多。 select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。但是解决了select的文件描述符的最大文件描述符数量</li>
<li>本身没有最大并发连接的限制，仅受系统进程能够打开的最多文件数目限制</li>
<li>省去不必要的内存拷贝，epoll通过内核与用户空间map同一块内存实现</li>
<li>效率提升，返回的是fd发生变化的fd</li>
</ul>
<p>select 实现原理</p>
<ul>
<li>从用户空间拷贝fd_set到内核空间</li>
<li>注册回调函数__pollwait；</li>
<li>遍历所有fd，对全部指定设备做一次poll（这里的poll是一个文件操作，它有两个参数，一个是文件fd本身，一个是当设备尚未就绪时调用的回调函数__pollwait，这个函数把设备自己特有的等待队列传给内核，让内核把当前的进程挂载到其中）</li>
<li>当设备就绪时，设备就会唤醒在自己特有等待队列中的【所有】节点，于是当前进程就获取到了完成的信号。poll文件操作返回的是一组标准的掩码，其中的各个位指示当前的不同的就绪状态（全0为没有任何事件触发），根据mask可对fd_set赋值；</li>
<li>如果所有设备返回的掩码都没有显示任何的事件触发，就去掉回调函数的函数指针，进入有限时的睡眠状态，再恢复和不断做poll，再作有限时的睡眠，直到其中一个设备有事件触发为止。</li>
<li>只要有事件触发，系统调用返回，将fd_set从内核空间拷贝到用户空间，回到用户态，用户就可以对相关的fd作进一步的读或者写操作了。</li>
</ul>
<p>epoll 高效关键</p>
<ul>
<li>在调用epoll_create时，内核除了帮我们在epoll文件系统里建了个file结点，在内核cache里建了个红黑树用于存储以后epoll_ctl传来的socket外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可</li>
<li>当我们执行epoll_ctl时，除了把socket放到epoll文件系统里file对象对应的红黑树上之外，还会给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表里。</li>
<li>应用场景</li>
</ul>
<p>进程VS 线如果在并发量低，socket都比较活跃的情况下，select就不见得比epoll慢了（就像我们常常说快排比插入排序快，但是在特定情况下这并不成立）。</p>
<h2 id="进程VS-协程"><a href="#进程VS-协程" class="headerlink" title="进程VS 协程"></a>进程VS 协程</h2><ul>
<li><p>一个线程属于一个进程，一个进程有多个线程，至少有一个线程，线程依赖于进程存在</p>
</li>
<li><p>进程在执行过程中有独立的内存单元，而多个线程共享进程的内存</p>
</li>
<li><p>进程为资源分配的最小单位，线程为CPU调度的最小单位</p>
</li>
<li><p>进程创建、撤销进程时，系统都要为之分配或者回收资源，如内存空间、IO设备等。大于创建、撤销线程的开销。进程切换时，涉及到整个当前进程的CPU环境的保存和新进程的CPU环境的设置，大于线程切换</p>
<ul>
<li>进程切换，需要切换系统指令以及地址空间，而线程共享地址空间，不需要切换地址空间，只切换指令</li>
</ul>
</li>
<li><p>进程间通信IPC，线程间共享地址空间，线程间同步和通信实现简单</p>
</li>
<li><p>进程调试简单可靠性高，线程调试复杂</p>
</li>
<li><p>进程间不会相互影响，线程一个线程挂掉使得整个进程挂掉</p>
</li>
<li><p>进程适合多核、多机分布，线程适用于多核</p>
<p>网络服务器中，多进程VS多线程</p>
<ul>
<li><table>
<thead>
<tr>
<th align="center">对比维度</th>
<th>多进程</th>
<th>多线程</th>
<th>总结</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数据共享、同步</td>
<td>数据共享复杂，需要IPC；数据分开，同步简单</td>
<td>共享进程数据，共享简单，同步复杂</td>
<td>各有优势</td>
</tr>
<tr>
<td align="center">内存、CPU</td>
<td>占用内存多，切换复杂，CPU利用率低</td>
<td>占用内存少，切换简单，CPU利用率高</td>
<td>线程win</td>
</tr>
<tr>
<td align="center">创建销毁、切换</td>
<td>创建销毁、切换复杂，速度慢</td>
<td>创建销毁、切换简单，速度快</td>
<td>线程win</td>
</tr>
<tr>
<td align="center">编程、调试</td>
<td>编程简单，调试简单</td>
<td>编程复杂，调试复杂</td>
<td>进程win</td>
</tr>
<tr>
<td align="center">可靠性</td>
<td>进程间不会相互影响</td>
<td>一个线程挂掉导致整个线程挂掉</td>
<td>进程win</td>
</tr>
<tr>
<td align="center">分布式</td>
<td>适应于多核、多机分布式；扩展多个机器简单</td>
<td>适应于多核分布式</td>
<td>进程win</td>
</tr>
</tbody></table>
<ul>
<li>优先进程<ul>
<li>弱相关</li>
<li>多机分布</li>
</ul>
</li>
<li>优先线程<ul>
<li>频繁创建销毁</li>
<li>大量计算</li>
<li>强相关</li>
<li>多核分布</li>
</ul>
</li>
<li>最拿手的</li>
</ul>
</li>
</ul>
</li>
<li><p>协程</p>
<ul>
<li>更轻量级的线程。用于解决线程间切换和进程间切换的通病（对内核开销过大），协程各个状态（阻塞、运行）的切换是由程序控制，而不是内核控制，减少了开销。</li>
<li>一种用户态的轻量级线程，完全由用户调度控制，拥有自己的寄存器上下文和栈，协程调度切换的时候，先将寄存器上下文和栈保存到其他地方，切换回来的时候再恢复之前保存的寄存器上下文和栈。直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</li>
</ul>
</li>
<li><p>协程VS线程</p>
<ul>
<li><strong>一个线程可以多个协程</strong>，一个进程也可以单独拥有多个协程</li>
<li><strong>线程进程都是同步机制，而协程则是异步</strong></li>
<li><strong>协程能保留上一次调用时的状态</strong>，每次过程重入时，就相当于进入上一次调用的状态</li>
</ul>
</li>
<li><p><strong>协程的好处</strong></p>
<ul>
<li><strong>无需线程上下文切换的开销</strong></li>
<li><strong>无需原子操作锁定及同步的开销</strong></li>
<li><strong>方便切换控制流，简化编程模型</strong></li>
<li><strong>高并发+高扩展性+低成本</strong></li>
</ul>
</li>
<li><p><strong>协程的缺点</strong></p>
<ul>
<li>无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上.</li>
<li>进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序：这一点和事件驱动一样，可以使用异步IO操作来解决</li>
</ul>
</li>
<li><p>C++20 协程，go协程</p>
<h2 id="硬链接、软连接"><a href="#硬链接、软连接" class="headerlink" title="硬链接、软连接"></a>硬链接、软连接</h2><ul>
<li><p>硬链接。硬链接是指通过索引节点来进行链接</p>
</li>
<li><p>在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都会给它分配一个编号，这个编号被称为索引节点编号号(InodeIndex)或者Inode，它是文件或者目录在一个文件系统中的唯一标识，文件的实际数据放置在数据区域（data block），它存储着文件重要参数信息，也就是元数据 （metadata），比如创建时间、修改时间、文件大小、属主、归属的用户组、读写权限、数据所在block号等</p>
</li>
<li><ul>
<li>在Linux系统中，多个文件名指向同一索引节点(Inode)是正常且允许的。一般这种链接就称为硬链接</li>
<li>硬链接的作用之一是允许一个文件拥有多个有效路径名，这样用户就可以建立硬链接到重要的文件，以防止“误删”源数据</li>
<li>文件建立了硬链接就会防止数据误删，是因为文件系统的原理是，只要文件的索引节点还有一个以上的链接（仅删除了该文件的指向），只删除其中一个链接并不影响索引节点本身和其他的链接（数据的实体并未删除），只有当最后一个链接被删除后，此时如果有新数据要存储到磁盘上，被删除的文件的数据块及目录的链接才会被释放，空间被新数据暂用覆盖</li>
</ul>
</li>
</ul>
</li>
<li><p>软连接</p>
<ul>
<li>软链接（也叫符号链接），类似于windows系统中的快捷方式，与硬链接不同，软链接就是一个普通文件，只是数据块内容有点特殊，文件用户数据块中存放的内容是另一文件的路径名的指向，通过这个方式可以快速定位到软连接所指向的源文件实体。软链接可对文件或目录创建。</li>
</ul>
<p><img src="cpp-review/image002.jpg" alt="image002"></p>
</li>
<li><p>软链接：</p>
<ul>
<li>1.软链接是存放另一个文件的路径的形式存在。</li>
<li>2.软链接可以 跨文件系统 ，硬链接不可以。</li>
<li>3.软链接可以对一个不存在的文件名进行链接，硬链接必须要有源文件。</li>
<li>4.软链接可以对目录进行链接。</li>
</ul>
<p>硬链接：</p>
<ul>
<li>硬链接，以文件副本的形式存在。但不占用实际空间。</li>
<li>不允许给目录创建硬链接。</li>
<li>硬链接只有在同一个文件系统中才能创建。</li>
<li>删除其中一个硬链接文件并不影响其他有相同 inode 号的文件。</li>
</ul>
</li>
<li><p>软链接 （符号链接） ln -s   source  target </p>
</li>
<li><p>硬链接 （实体链接）ln     -h  source  target</p>
</li>
</ul>
<h2 id="用户权限"><a href="#用户权限" class="headerlink" title="用户权限"></a>用户权限</h2><ul>
<li><strong>rwxr-xr-x  5 root root  94 Jun 27 2017 xdg</strong></li>
<li>rwx 文件所有者权限 u表示</li>
<li>r-x 所属组权限 g表示</li>
<li>r-x 其他人权限 o表示</li>
<li>r=4 w=2 x=1</li>
<li>chmod u+x a.txt 对所有者添加 x权限</li>
<li>chmod g-x,o-x a.txt，对所属用户组，其他减权限</li>
<li>chmod u=rwx,g=rwx,o=rwx a.txt</li>
<li>chomd a=wx  a.txt a=all添加所有者，用户组，其他权限</li>
<li>chmod a=rw a.txt b.txt</li>
</ul>
<p>用户态、内核态</p>
<ul>
<li><h2 id="linux命令-1"><a href="#linux命令-1" class="headerlink" title="linux命令"></a>linux命令</h2></li>
<li><p>系统信息</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/version ：查看linux版本信息</span><br><span class="line">date ：显示系统日期 </span><br><span class="line">ifconfig ：显示或设置网卡</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ul>
</li>
<li><p>系统性能</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    top ：动态实时显示cpu、内存、进程等使用情况（类似windows下的任务管理器）</span><br><span class="line">    top -d <span class="number">2</span> -p <span class="number">7427</span> ：-d为画面更新的秒数，默认<span class="number">5</span>秒，-p为指定进程pid的信息</span><br><span class="line">    vmstat <span class="number">2</span> <span class="number">10</span> ：每隔<span class="number">2</span>秒采集一次服务器状态，采集<span class="number">10</span>次（查看内存、io读写状态、cpu）</span><br><span class="line">    <span class="built_in">free</span> -h :查看系统内存及虚拟内存使用情况</span><br><span class="line">    df -h :显示磁盘的空间使用情况</span><br><span class="line">    iostat ：可查io读写、cpu使用情况</span><br><span class="line">    sar -u <span class="number">3</span> <span class="number">5</span> :查看cpu使用情况（<span class="number">3</span>秒一次，共<span class="number">5</span>次）</span><br><span class="line">    sar -d <span class="number">2</span> <span class="number">3</span> ：评估磁盘性能</span><br><span class="line">    ps aux|grep firefox ：获取火狐的进程号（PID）（可查看进程占用cpu、内存百分比及进程触发指令的路径）</span><br><span class="line">    kill <span class="number">-9</span> 进程号 ：强制杀死进程</span><br><span class="line">    systemctl ：查看正在运行的服务</span><br><span class="line">    ps –ef|grep tomcat 查看所有有关tomcat的进程</span><br><span class="line">    find / -name filename.txt 根据名称查找/目录下的filename.txt文件。</span><br><span class="line">locate a.txt ：在系统全局范围内查找文件名包含a.txt字样的文件（比find快）;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ps命令</span><br><span class="line"></span><br><span class="line">（用于将某个时间点的进程运行情况选取下来并输出，process之意）</span><br><span class="line">-A ：所有的进程均显示出来</span><br><span class="line">-a ：不与terminal有关的所有进程</span><br><span class="line">-u ：有效用户的相关进程</span><br><span class="line">-x ：一般与a参数一起使用，可列出较完整的信息</span><br><span class="line">-l ：较长，较详细地将PID的信息列出</span><br><span class="line"></span><br><span class="line">ps aux # 查看系统所有的进程数据</span><br><span class="line">ps ax # 查看不与terminal有关的所有进程</span><br><span class="line">ps -lA # 查看系统所有的进程数据</span><br><span class="line">ps axjf # 查看连同一部分进程树状态</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>查看文件内容</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat [-n] 文件名 :显示文件内容，连行号一起显示</span><br><span class="line">less 文件名 ：一页一页的显示文件内容（搜索翻页同man命令）</span><br><span class="line">head [-n] 文件名 ：显示文件头n行内容，n指定显示多少行</span><br><span class="line">tail [-nf] 文件名:显示文件尾几行内容,n指定显示多少行,f用于实时追踪文件的所有更新，常用于查阅正在改变的日志文件（如tail -f -n <span class="number">3</span> a.<span class="built_in">log</span> 表示开始显示最后<span class="number">3</span>行，并在文件更新时实时追加显示，没有-n默认<span class="number">10</span>行）</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>任务</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">python3 test.py &amp; 虽然会后台运行，但是会输出结果，如果关闭xshell窗口，进程会结束，也就是结束后台运行。</span><br><span class="line">nohup python3 test.py&amp; 如果让程序始终在后台执行，即使关闭当前的终端也执行（之前的&amp;做不到），这时候需要nohup。</span><br><span class="line">jobs 查看当前有多少在后台运行的命令</span><br><span class="line"></span><br><span class="line">后台进程的终止：</span><br><span class="line">方法一：</span><br><span class="line">通过jobs命令查看job号（假设为num），然后执行kill %num</span><br><span class="line">方法二：</span><br><span class="line">通过ps命令查看job的进程号（PID，假设为pid），然后执行kill pid</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ul>
</li>
</ul>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><ul>
<li>TCP/IP协议体系</li>
<li>链路层<ul>
<li>以太网帧的格式</li>
<li>MTU</li>
<li>ARP/RARP</li>
</ul>
</li>
<li>网络层<ul>
<li>IP首部格式</li>
<li>IP分片</li>
<li>IP选路</li>
<li>ICMP协议<ul>
<li>报文格式</li>
<li>分类 查询+差错</li>
<li>两种+五种</li>
<li>传输层</li>
</ul>
</li>
</ul>
</li>
<li>传输层<ul>
<li>UDP<ul>
<li>特点</li>
<li>首部字段</li>
</ul>
</li>
<li>TCP<ul>
<li>特点</li>
<li>首部字段</li>
<li>可靠机制</li>
<li>连接控制</li>
<li>流量控制机制</li>
<li>超时重传</li>
</ul>
</li>
</ul>
</li>
<li>应用层<ul>
<li>DNS<ul>
<li>命名空间</li>
<li>指针查询（反向查找或逆向解析）基本原理</li>
<li>DNS缓存</li>
</ul>
</li>
<li>FTP协议——————<ul>
<li>两条连接。控制流、数据流</li>
<li>两种工作模式PASV PORT</li>
<li>各种指令和相应码</li>
<li>断点续传和匿名FTP概念</li>
</ul>
</li>
<li>HTTP协议<ul>
<li>报文格式：请求报文，响应报文，请求各种字段，响应头各种字段</li>
<li>HTTP状态码</li>
</ul>
</li>
<li>HTTPS协议<ul>
<li>握手具体过程</li>
<li>摘要算法，数字签名，数字证书的原理和过程</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="TCP-IP协议体系"><a href="#TCP-IP协议体系" class="headerlink" title="TCP/IP协议体系"></a>TCP/IP协议体系</h2><ul>
<li><p>OSI 有哪几层，会画出来，知道主要几层的各自作用 </p>
<p>​     1. 应用层（数据）：确定进程之间通信的性质以满足用户需要以及提供网络与用户应用</p>
<ol start="2">
<li>表示层（数据）：主要解决用户信息的语法表示问题，如加密解密</li>
<li>会话层（数据）：提供包括访问验证和会话管理在内的建立和维护应用之间通信的机<br>制，如服务器验证用户登录便是由会话层完成的</li>
<li>传输层（段）：实现网络不同主机上用户进程之间的数据通信，可靠<br>与不可靠的传输，传输层的错误检测，流量控制等</li>
<li>网络层（包）：提供逻辑地址（IP）、选路，数据从源端到目的端的传输</li>
<li>数据链路层（帧）：将上层数据封装成帧，用 MAC 地址访问媒介，错误检测与修正</li>
<li>物理层（比特流）：设备之间比特流的传输，物理接口，电气特性等 </li>
</ol>
</li>
<li><p>知道各个层使用的是哪个数据交换设备。（交换机、路由器、网关） </p>
<ul>
<li><strong>网关：应用层、传输层（网关在传输层上以实现网络互连，是最复杂的网络互连设</strong><br><strong>备，仅用于两个高层协议不同的网络互连。网关的结构也和路由器类似，不同的是</strong><br><strong>互连层。网关既可以用于广域网互连，也可以用于局域网互连）</strong></li>
</ul>
<ol start="2">
<li><strong>路由器：网络层（路由选择、存储转发）</strong></li>
<li><strong>交换机：数据链路层、网络层（识别数据包中的 MAC 地址信息，根据 MAC 地址进</strong></li>
</ol>
<p><strong>行转发，并将这些 MAC 地址与对应的端口记录在自己内部的一个地址表中）</strong></p>
<ol start="4">
<li>网桥：数据链路层（将两个 LAN 连起来，根据 MAC 地址来转发帧）</li>
<li>集线器（Hub）：物理层（纯硬件设备，主要用来连接计算机等网络终端）</li>
<li>中继器：物理层（在比特级别对网络信号进行再生和重定时，从而使得它们能够在<br>网络上传输更长的距离） </li>
</ol>
</li>
</ul>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><ul>
<li>ARP  <ul>
<li>IP地址到对应的硬件地址之间提供动态映射。动态—自动完成</li>
<li>RARP被那些没有磁盘驱动器的系统使用，需要系统管理员进行手动设置</li>
<li>点对点网络无需地址解析协议</li>
<li>ARP高效运行的关键是，<strong>每个主机都有一个ARP高速缓存/存放了最近Internet地址到硬件地址之间的映射记录</strong>。高速缓存每一项的生存时间一般为20分钟，起始时间从被创建时开始。</li>
<li>ARP报文<ul>
<li><img src="cpp-review/c9Rd4j0YFFdr.png" alt="mark"></li>
<li>帧类型0800 IP 0806 ARP 0835 RARP</li>
<li>硬件类型 以太网 =1</li>
<li><strong>协议类型 IPv4 0x0800</strong></li>
<li>硬件长度 <strong>以太网地址长度6 字节</strong></li>
<li>协议长<strong>度 IPv4=4字节</strong></li>
<li>操作码 1 request 2 reply 3 RARP请求 4 RARP 应答</li>
</ul>
</li>
</ul>
</li>
<li>ARP 协议有什么弱点？ <ul>
<li>1）缓存：主机的地址映射是基于高速缓存的，动态更新的。地址刷新是有时间限制的。 可<br>以通过下次更新之前修改计算机上的地址缓存，造成拒绝服务攻击或者 ARP 欺骗。<br>2）广播: 攻击者可以伪装 ARP 应答。<br>3） ARP 应答没有认证，都是合法的。可以在不接受到请求的时候就发出应答包。 </li>
</ul>
</li>
<li>ARP 代理的概念和应用场景 <ul>
<li>若 ARP 请求是从一个网络的主机发送给另一个网络上的主机，那么连接这两个网络的路由<br>器就可以回答该请求，这个过程叫做 ARP 代理。 ARP 代理路由器响应 ARP 请求的 MAC 地<br>址为路由器的 MAC 地址而非 ARP 请求的主机的 MAC 地址。 </li>
<li>ARP 代理的应用环境：<br>两个物理网络之间的路由是使用相同的网络号，两个路由器设置成 ARP 代理，实现相互隐<br>瞒物理网络</li>
</ul>
</li>
<li>免费 ARP <ul>
<li>主机发送 ARP 查找自己的 IP 地址，即数据链路层 SIP=DIP </li>
<li>作用有两个：<br>1）一个主机使用免费 ARP 确定是有存在有其他主机设置了相同的 IP 地址–检测IP冲突<br>2）如果发送免费 ARP 的主机改变了 MAC 地址，可以通过发送免费 ARP 的方式告知其他<br>主机端更新 ARP 表 –更新ARP表,网络设备冷备</li>
</ul>
</li>
<li>数据链路层 MTU 的最大值和最小值是多少 <ul>
<li>数据链路层的最小 MTU 为 64 字节。 </li>
<li>数据链路层的最大 MTU 为 1500 字节，即数据字段的最大长 </li>
</ul>
</li>
<li>ARP请求过程<ul>
<li>假设主机A和主机B在同一个网段内<ul>
<li>主机A首先查看自己的ARP表，确定其中是否包含主机B对应的ARB表项，找到，对IP数据包进行帧封装，并将数据包发送给主机B</li>
<li>如果A自己的ARP表没有，向局域网的所有主机广播一个ARP请求，寻找B主机，当B主机收到A主机广播的ARP请求后，一方面将主机A的IP-MAC存放在自己的缓存中，另外就会直接给A主机回复一个ARP数据包，当A主机收到B主机发送过来的请求后，将B的MAC地址写入高速缓存中</li>
</ul>
</li>
<li>AB不在一个网段内<ul>
<li>就通过ARP询问默认网关对应的MAC地址, 将数据转发给网关, 网关进行与主机A类似的ARP解析过程,将数据发送给主机B,或者转发给下一个网关继续进行路由,直到到达主机B</li>
</ul>
</li>
<li>ARP请求广播，ARP响应单播</li>
</ul>
</li>
</ul>
<h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><ul>
<li><p>IP提供不可靠的无连接的数据报传送服务</p>
<ul>
<li>不可靠（unreliable）指的是不能保证IP数据报能成功到达目的地。如果发生某种错误。IP有一个简单的错误处理算法，丢弃该数据报，然后发送ICMP消息给信源端。任何要求的可靠性必须由上层来提供（tcp/ip）</li>
<li>无连接（connectionless）IP并不维护任何关于后续数据报的状态信息。IP 数据可以不按顺序发送和接收。 A 发送连续的数据报，到达 B 不一定是连续的，来回路由选择可能不一样，路线也不一样，到达先后顺序也不一样。 TCP对数据包排序，顺序不对时，缓存。</li>
</ul>
</li>
<li><p>IP报文格式</p>
<ul>
<li><img src="cpp-review/lp02PfVJt4c9.png" alt="mark"></li>
<li>版本号：4-IPV4,6-IPV6</li>
<li>首部长度：单位为4字节，即一行。最小为5（20字节，无可选项），最大为15（60字节）</li>
<li>Tos，忽略</li>
<li>总长度，IP首部+数据部分，最大2^16=65536字节</li>
<li>标识字段，16bit，四字节，用于分片重组</li>
<li>标志，3bit，表示是否可分片，分片的情况下，是否是最后一片</li>
<li>片位移：13bit，标识被分片的每一个片段相对于原始数据的位置，单位为8字节，是2^13=8192*8=65536，最多表示原始数据的65536字节的位置</li>
<li>TTL生存时间：可以中转多少个路由器，每经过一个路由就减1，防止环形路由</li>
<li>协议：8bit，表示IP首部的下一个是什么协议，ICMP<strong>:1  |  **TCP</strong>:6  |  <strong>UDP</strong>:17  |  GRE:47  |  ESP:50  |  AH:51**</li>
<li>首部检验和：只校验IP首部，不校验数据部分</li>
<li>可选项：最多40字节，</li>
<li>填充pad，确保首部长度为32bit的整数倍</li>
</ul>
</li>
<li><p>为什么IP首部需要总长度字段</p>
<ul>
<li>因为一些数据链路（以太网）需要填充一些数据以达到最小长度。因为以太网帧的最小长度<br>是 46 个字节，但是 IP 长度可能更短，所以需要总长度来确定 IP 数据部分的内容。 </li>
</ul>
</li>
<li><p>IP 首部校验和怎么计算的，与 ICMP， IGMP， TCP， UDP 的首部校验和有什么区<br>别与共同点？ </p>
</li>
<li><p>（1） 先把校验和字段置 0。<br>  （2） 对首部中每个 16 位比特进行二进制求和，多余4个字节的，把大于4字节的同剩下的四个字节继续相加。<br>  （3） 结果取反 保存在检验和字段中。<br>  （4） 收到一份 IP 数据包后，同样对首部中每个 16bit 二进制求和，同样大于四个字节的同剩下四个字节相加，并取反<br>  （5） 最后结果全为 1，表示正确，否则表示错误。<br>  （6） 如果是错误的， IP 就丢弃该数据报，但是不生成差错报文，由上层去处理。 </p>
<ul>
<li>共同点：用到的算法都是一样的。<br>区别： IP 计算的时候没有将数据包括在内。<br>ICMP， IGMP， TCP， UDP 同时覆盖首部和数据检验码。 </li>
</ul>
</li>
<li><p>IP路由</p>
<ul>
<li>IP路由选择的过程<ul>
<li>根据最长匹配原则，找到条目，发送到指定的路由器。如果不能找到，返回一个“主机不可<br>达”或“网络不可达”的错误。 </li>
</ul>
</li>
<li>IP路由选择的特点<ul>
<li>IP 路由选择是逐跳进行的。 IP 并不知道到达任何目的的完整路径，只提供下一跳地址。 </li>
<li>为一个网络指定一个路由器，而不是为每个主机指定一个路由器 ，这样可以缩小路由表规模。 </li>
</ul>
</li>
<li>IP搜索路由表的步骤<ul>
<li>搜索匹配的主机地址（网络号和主机号都要匹配） —-》搜索匹配的网络地址 —-》搜索默认选项 </li>
</ul>
</li>
<li>如果路由表中没有默认项，而又没有找到匹配项，这时如何处理？ <ul>
<li>数据报是由本机产生的，那么就给发送该数据报的应用程序返回一个差错，或者是“主<br>机不可达差错”或者是“网络不可达差错”。 </li>
<li>如果是被转发的数据报，就给原始发送端发送一份 ICMP 主机不可达的差错报文。 </li>
</ul>
</li>
</ul>
</li>
<li><p>IP地址分类</p>
<ul>
<li><ol>
<li><p>A 类地址：首位为 0， 1.0.0.1~~126.255.255.254；主机号 24 位</p>
</li>
<li><p>B 类地址：首位为 10， 128.0.0.1~~191.255.255.254；主机号 16 位</p>
</li>
<li><p>C 类地址：首位为 110， 192.0.0.1~~223.255.255.254；主机号 8 位</p>
</li>
<li><p>D 类地址（多播地址，也叫做组播地址）：首位为 1110， 224.0.0.1~~239.255.255.254</p>
</li>
<li><p>E 类地址：此类地址是保留地址，首位为 11110， 240.0.0.1~~254.255.255.254 </p>
</li>
</ol>
</li>
<li><p>网络地址就是：把IP地址转成二进制和子网掩码进行与运算</p>
</li>
<li><p>主机的数量=2^二进制位数的主机-2（1个网络地址，1个广播地址）</p>
</li>
<li><p>广播地址：网络地址的主机位全部变成1 </p>
</li>
<li><p>网络地址+1即为第一个主机地址，广播地址-1即为最后一个主机地址</p>
</li>
</ul>
</li>
<li><p>ICMP</p>
<ul>
<li>ICMP报<strong>文前四个字节都相同</strong>，IP 首部20字节。</li>
<li><img src="cpp-review/IAyD5lcoVH3k.png" alt="mark"></li>
<li>ICMP 协议在 IP头部中 协议为1  <strong>ICMP</strong>:1  |  <strong>TCP</strong>:6  |  <strong>UDP</strong>:17  |  GRE:47  |  ESP:50  |  AH:51</li>
<li>echo request 类型为8 代码为0</li>
<li>echo reply 类型为0 代码为0</li>
<li>校验和：<ul>
<li>以太网管自己的，IP校验和–IP头部，TCP /ICMP 管自己头部和后面所有的</li>
</ul>
</li>
<li>ICMP报文分类<ul>
<li>一类是 ICMP 查询报文，另一类是 ICMP 差错报文。 </li>
<li><img src="cpp-review/1567476237158.png" alt="1567476237158"></li>
<li>ICMP 的主机不可达报文是在什么情况下发出的？ <ul>
<li>三层设备（路由器）给该主机寻路时，没有找到相应路径，向源 IP 发回 ICMP 主机不可达 </li>
</ul>
</li>
</ul>
</li>
<li>什么情况不会导致产生 ICMP 差错报文？为了防止过去允许ICMP差错报文对广播分组响应所带来的广播风暴<ul>
<li><strong>ICMP差错报文，但是ICMP查询报文可能会产生差错报文</strong></li>
<li>目的地址是广播地址或多播地址的IP数据报</li>
<li>作为链路层广播的数据报</li>
<li>不是IP分片的第一片，因为只有第一片才有四层端口号的信息。</li>
<li>源地址不是单个主机的数据报。即源地址不能为零地址、环回地址、广播地址、多播地址</li>
</ul>
</li>
<li>ping<ul>
<li>第一个是看看是不是超时</li>
<li>第二个看看是不是延迟太高<ul>
<li>A 电脑（ <code>192.168.2.135</code>）发起 <code>ping</code>请求， <code>ping192.168.2.179</code></li>
<li>A 电脑广播发起 <code>ARP</code>请求，查询 <code>192.168.2.179</code>的 MAC地址。</li>
<li>B 电脑应答 <code>ARP</code>请求，向 A电脑发起单向应答，告诉 A电脑自己的 MAC地址为 <code>90:A4:DE:C2:DF:FE</code></li>
<li>知道了 MAC地址后，开始进行真正的 ping请求，由于 B电脑可以根据A电脑发送的请求知道 <strong>源 MAC地址</strong>，所以就可以根据源 MAC地址进行响应了。</li>
<li>发送ICMP ECHO request （ 类型为8 代码为0）报文，响应ICMP reply（类型为0 代码为0）报文</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><ul>
<li><img src="cpp-review/1567391865764.png" alt="1567391865764"></li>
<li>UDP 长度：是 UDP 的报文总长度，是多于8的。 IP 总长度减去首部长度就是此值 </li>
<li>UDP 校验和：注意点：校验和是可选的。 （TCP 是必选的）校验和覆盖 UDP 首部和数据<br>（TCP 也一样覆盖首部和数据，但是 IP 只覆盖首部）</li>
<li>UDP校验和如何计算<ul>
<li>UDP 的校验和要计算首部和数据部分。首部还包括伪首部 </li>
<li><img src="cpp-review/1567391955508.png" alt="1567391955508"></li>
<li>多了 12 个字节的伪首部。 </li>
<li>为什么加伪头部<ul>
<li><strong>目的是让 UDP 两次检查数据是否已经正确到达目的地</strong>。IP 接受正确的目的地址，传送到正确的上层程序。所有伪首部包括：源 IP 地址，目的 IP 地址， 0，协议号， UDP 长度。 </li>
</ul>
</li>
</ul>
</li>
<li>TCP、 UDP 为什么存在伪包头？ <ul>
<li>UDP(TCP)检验和：是根据 UDP(TCP)数据报和伪报头计算得到的差错检测值。 </li>
<li>伪报头包含源和目的 IP 地址，以及来自 IP 数据报报头的协议值。 IP 数据报在网络中传送时<br>包含 UDP（TCP） 数据报。 </li>
<li>伪报头并不会在网络中传送，校验和中所包含的伪报头内容可以避免目的端错误地接收错误路由的数据报。校验和值的计算方法和 IP 报头检验和的计算方法类似 </li>
</ul>
</li>
<li>UDP实现可靠传输<ul>
<li>RUDP  RTP UDT </li>
<li>传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。</li>
<li>实现确认机制，重传机制，窗口确认机制</li>
<li>添加seq/ack机制，确保数据发送到对端</li>
<li>添加发送和接收缓冲区，主要是用户超时重传</li>
<li>添加超时重传机制</li>
</ul>
</li>
</ul>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><ul>
<li><p><img src="cpp-review/8AMLnhHgXyzf.png" alt="mark"></p>
</li>
<li><p>TCP VS UDP</p>
<ul>
<li>UDP 没有复杂控制，提供面向无连接通信服务的一种协议，将部分控制转移给应用程序</li>
<li>TCP 对传输、发送、通信进行控制的协议，仅在确认对端存在时才发送数据，控制通信流量，提供可靠的传输机制</li>
</ul>
</li>
<li><p>TCP面向连接，UDP面向无连接</p>
<ul>
<li>TCP面向报文，UDP面向字节流</li>
<li>TCP提供可靠传输服务，UDP传输不可靠</li>
<li>TCP协议速度慢，UDP快</li>
<li>TCP协议对资源要求多（头部开销大），UDP协议要求少</li>
</ul>
</li>
<li><p>TCP的可靠性</p>
<ul>
<li>拥塞控制：应用数据被分割为TCP最为合适发送的大小</li>
<li>超时重传：TCP发送一个字段后，启动一个定时器，等待目的端收到报文段，如果不能及时收到ACK,将重新发送</li>
<li>延迟应答：TCP收到数据，发送延迟的ack（200ms），delayed_ack</li>
<li>校验和：TCP保持首部和数据的校验和</li>
<li>序列号：TCP会对收到的数据进行重新排序</li>
<li>TCP提供对流的控制。TCP连接的每一方都有固定大小的缓冲空间。<strong>TCP的接收端只允许另一端发送  接收端缓冲区所能容纳的数据。</strong>这将防止较快主机致使较慢主机的缓冲区溢出</li>
</ul>
</li>
<li><p>序号</p>
<ul>
<li>序号标识从TCP发送端到接收端的字节流，标识这个报文段中第一个数据字节的序号，不会从0开始，在建立连接时（发送SYN时），由计算机生成的随机数作为初始值。序号无符号32bit，达到2^32后，变为0重新开始</li>
<li>确认序号是上次已成功收到数据字节序号加1（SYN占用一个序号）。只有ACK标志位1时确认序号字段才有效。</li>
</ul>
</li>
<li><p>窗口大小，16bit，用于通知从相同的TCP首部应答好所指位置开始能接受的数据大小，TCP不能发送超过次值大小的数据段，窗口为0表示可以发送窗口探测，以了解最新窗口大小。但这个数据必须为1个字节。</p>
<ul>
<li>接收端能够接收的字节数，（即允许当前发送端发送的字节数）</li>
</ul>
</li>
<li><p>MSS，每个连接方通常在通信的第一个报文段（SYN段），设置本端所能接受的报文段的最大长度</p>
</li>
<li><p>连接</p>
<ul>
<li>三次握手<ul>
<li>客户端发送SYN，     序列号 A，ACK号=0   进入SYN_SENT状态</li>
<li>服务器发送SYN+ACK, 序列号B    ACK号   A+1 进入 SYN_RCVD</li>
<li>客户端发送ACK，序列号 A+1     ACK号B+1   进入ESTABLISHED</li>
<li>服务器收到ACK后，进入 ESTABLISHED</li>
</ul>
</li>
</ul>
</li>
<li><p>断开</p>
<ul>
<li>四次挥手<ul>
<li>客户端发送FIN    序列号A    ACK 号          进入FIN_WAIT_1</li>
<li>服务器发送ACK  序列号 B,   ACK号 A+1 进入CLOSE_WAIT </li>
<li>接收端收到ACK后，进入FIN_WAIT_2，继续接受来自服务器的数据</li>
<li>服务器发送FIN   进入LAST_ACK</li>
<li>客户端发送ACK  进入TIME_WAIT，等待2MSL后进入CLOSED状态</li>
<li>服务器收到ACK后，进入CLOSED</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么三次？为什么四次</p>
<ul>
<li>3 次握手：防止已过期的连接请求报文突然又传送到服务器，因而产生错误 <ul>
<li>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤</li>
<li>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认</li>
<li>如果只有两次确定一个连接的话。当客户端发送SYN后，丢失，再次发送SYN，服务器发送SYN +ACK，这时就已经建立好连接，之后传递数据并断开连接。这时，之前丢的那个SYN回来了，那么客户端知道这个连接已经结束了，但是服务器认为这是一个新的连接，于是为它建立连接（占据一定资源），并等待对方发送数据</li>
<li>而如果采用三次的话，如果第三次ACK不来，服务器就会知道该SYN无效，释放资源。</li>
<li>另一种情况是，由于种种原因，失败。客户端认为字节连接好了，会给服务器发送数据，而服务器由于没有收到ACK，发送RST给客户端，收到RST的客户端知道第三次握手没有成功，会重新连接。</li>
</ul>
</li>
<li>4 次挥手：确保数据能够完成传输，但关闭连接时，当收到对方的 FIN 报文通知时，它<br>仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以<br>未必会马上会关闭 SOCKET,也即你可能还需要发送一些数据给对方之后，再发送 FIN 报文<br>给对方来表示你同意现在可以关闭连接了，所以它这里的 ACK 报文和 FIN 报文多数情况下<br>都是分开发送的 </li>
</ul>
</li>
<li><p>状态变迁图</p>
</li>
<li><ul>
<li><p><img src="cpp-review/201012122157476286.png" alt="201012122157476286"></p>
</li>
<li><p><img src="cpp-review/201012122157494693.png" alt="201012122157494693"></p>
</li>
<li><p><img src="cpp-review/20180208112533496" alt="https://img-blog.csdn.net/20180208112533496"></p>
</li>
<li><p><img src="cpp-review/Ou1Q34TIaU52.png" alt="mark"></p>
</li>
<li><p>2MSL </p>
<ul>
<li><p>TIME_WAIT状态又称2MSL状态。每个具体TCP实现选择一个报文段最大生存时间MSL，它是任何报文段被丢弃前在网络内的最长时间</p>
</li>
<li><p>原因</p>
<ul>
<li>如果服务器在发送FIN后，没有收到ACK，超过超时重传时间后，服务器重新发送FIN，客户端再发送ACK。如果没有TIME_WAIT状态，服务器可能一直收不到ACK，一直保持该会话</li>
<li>如果在第一个连接结束后，迅速建立第二个连接，而且是相同的四元组，那么TCP认为是同一个连接，上一个连接遗留的包会对下一个连接造成错误，所以等待一会时间。</li>
<li>2MSL其中一个是被动段发送的ACK丢失时，另一个是主动段发送的FIN包丢失的最大生存时间。</li>
</ul>
</li>
<li><p><strong>可靠的实现TCP全双工连接的终止</strong></p>
</li>
</ul>
</li>
<li><p><strong>允许老的重复连接在网络中消失</strong></p>
<ul>
<li><p>效果</p>
<ul>
<li>等待2MSL期间，这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能在被使用。这个连接只能在2MSL结束后才能被使用</li>
<li>连接处于2MSL等待时，任何迟到的报文段将被丢弃。因为处于2MSL等待的、由该插口对定义的连接在这段时间不能被再用</li>
</ul>
</li>
<li><p>客户执行主动关闭并进入TIME_WAIT状态是正常的。服务器通常执行被动关闭，不会进入TIME_WAIT状态。这暗示如果终止一个客户程序并重新启动这个客户程序，则这个新客户程序将不能重用相同的本地端口。</p>
</li>
<li><p>对于服务器，使用熟知端口。如果我们终止一个已经建立连接的服务器程序，并试图立即重新启动这个服务器程序，服务器程序将不能把它的这个熟知端口赋值给它的端点，因为那个端口处于2MSL连接的一部分。</p>
</li>
<li><p>解决</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">bool</span> option=TRUE;</span><br><span class="line">    <span class="keyword">int</span> optlen=<span class="keyword">sizeof</span>(option)</span><br><span class="line">setsocketopt(serv_sock，SOL_SOCKET,SO_REUSEADDR,(<span class="keyword">void</span>*)&amp;option,optlen)</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>FIN_WAIT_2</p>
<ul>
<li><p>长时间停在FIN_WAIT_2状态，对端停留在CLOSE_WAIT状态</p>
</li>
<li><p>一般防火墙都有解决半关闭（FIN_WAIT_2）的超时时间设置，如果超时，防火墙会向双方发送RSET(伪装源)来踢掉连接。</p>
</li>
<li><p>父进程打开了socket，然后用派生子进程来处理业务，父进程继续对网络请求进行监听，永远不会终止。客户端发FIN过来的时候，处理业务的子进程的read返回0，子进程发现对端已经关闭了，直接调用close()对本端进行关闭。实际上，仅仅使socket的引用计数减1，socket并没关闭。从而导致系统中又多了一个CLOSE_WAIT的socket。</p>
</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子进程的关闭处理应该是这样的：</span></span><br><span class="line">shutdown(sockfd, SHUT_RDWR);</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="comment">//这样处理，服务器的FIN会被发出，socket进入LAST_ACK状态，等待最后的ACK到来，就能进入初始状态CLOSED。</span></span><br><span class="line"><span class="comment">//在多进程中如果一个进程中shutdown(sfd, SHUT_RDWR)后其它的进程将无法进行通信. 如果一个进程close(sfd)将不会影响到其它进程.</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<pre><code>* 一般情况下，当TCP连接主动关闭时，会向对端发送一个FIN，对端会获得一个读事件，调用read时返回0，表示读到一个EOF，读结束。</code></pre><ul>
<li><p>TCP交互式数据流</p>
<ul>
<li>延迟的ACK<ul>
<li>通常TCP在接收到数据后并不立即发送ACK，相反，它推迟发送，以便将ACK与需要沿该方向发送的数据一起发送（<strong>数据捎带ACK</strong>），绝大多数实现采用的时延为200ms，即，TCP将以最大200ms的时延等待是否有数据一起发送</li>
</ul>
</li>
<li>Nagle算法<ul>
<li>要求<strong>一个TCP连接上最多只有一个未被确认的未完成的小分组，在该分组的确认到达前不能发送其他的小分组</strong>，这时可以缓冲接下来要发送的数据包，<strong>TCP收集这些少量的分组，并在确认到来时以一个分组的方式发出去</strong>。该算法的<strong>优越性在于它是自适应的</strong>：确认到达的越快，数据也就发送的越快。而在希望减少微小分组数目的低速广域网上，则会发送更少的分组</li>
<li>关闭Nagle算法，实时预览的通讯程序而言，e.g.小消息必须无时延的发送<ul>
<li>将套接字描述符设置TCP_NODELAY选项可以禁止nagle算法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>TCP成块的数据流</p>
<ul>
<li>正常数据流<ul>
<li>确认机制<ul>
<li>通常使用的“<strong>隔一个报文段确认”</strong>策略，A发送一个报文给B，A再发送一个报文给B，B发送ACK确认收到的两个报文给A</li>
<li><strong>delay_ed ACK, 如果tcp对每个数据包都发送一个ack确认，那么只是一个单独的数据包为了发送一个ack代价比较高，所以tcp会延迟一段时间，如果这段时间内有数据发送到对端，则捎带发送ack，如果在延迟ack定时器触发(200ms)时候，发现ack尚未发送，则立即单独发送</strong></li>
</ul>
</li>
</ul>
</li>
<li>滑动窗口<ul>
<li><strong>接受方的流控，发送方快，接收方慢，协调双方工作节奏</strong></li>
<li>MSS 最大消息长度，在建立连接时确定，为IP中不会被分片的最大数据长度（(MTU)1500-(IP头部)20-（TCP头部）20=1460）</li>
<li>滑动窗口本质上是描述接受方的TCP数据报缓冲区大小的数据，发送方根据这个数据来计算自己最多能发送多长的数据。</li>
<li>窗口左边右移<ul>
<li>发生在数据被发送（发送端）和确认时（接收端）</li>
<li>发送端的slide window 左侧是自己发出，并被对方确认的字节序列号，右侧是左侧+ B通告window size。</li>
</ul>
</li>
<li>窗口右边右移<ul>
<li>收到已经确认的数据并释放了TCP接收缓存时</li>
</ul>
</li>
<li>发送端状态<ul>
<li>已发送已收到ACK，已发送未收到ACK,准备发送，未发送</li>
</ul>
</li>
<li>接收端状态<ul>
<li>已收到ACK，已收到未发送ACK，未收到</li>
</ul>
</li>
<li>发送方根据接收方的窗口连续发送数据窗口大小的数据不用收到ACK，收到ACK后窗口左边右移</li>
<li>接收方则确认ACK 连续的数据分组，对于乱序的分组则先接收下来，避免网络重复传递，丢失的触发超时重传</li>
</ul>
</li>
<li>慢启动<ul>
<li><strong>拥塞窗口是由发送方使用的流量控制，而通告窗口则是接收方使用的流量控制</strong></li>
<li>TCP采用慢启动算法来<strong>降低一开始就发送过多的数据到网络</strong>,采用slow start 算法来快速摸到传输路径带宽的峰值。（一开始发送大量数据，在发送方和接收方之间存在多个路由器和速率较慢的链路时，就有可能出现一些问题。一些中间路由器必须缓存分组，并有可能耗尽存储器的空间，然后发生丢包）</li>
<li>发送方有一个拥塞窗口（cwnd），拥塞窗口被初始化为1个报文段，每收到一个ACK，拥塞窗口就增加一个报文段（<strong>cwnd以字节为单位，但是慢启动以报文段为单位进行增加</strong>），收到一个ACK，1-&gt;2，收到两个ACK,2-&gt;4，指数增加，</li>
<li>发送方取拥塞窗口与通告窗口中的最小值作为发送上限。</li>
<li>不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。这里用报文段的个数的拥塞窗口大小举例说明慢开始算法，实时拥塞窗口大小是以字节为单位的。 </li>
<li>为了防止 cwnd 增长过大引起网络拥塞，设置一个慢开始门限（ssthresh 状态变量） <ul>
<li>当 cnwd＜ssthresh，使用慢开始算法</li>
<li>当 cnwd=ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法</li>
<li>当 cnwd＞ssthresh，使用拥塞避免算法 <ul>
<li>拥塞避免并非完全能够避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。 </li>
<li>思路：让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTTI就把发送方的拥塞控制窗口加一。 </li>
<li>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把<strong>慢开始门限设置为出现拥塞时的发送窗口大小的一半</strong>。然后把拥塞窗口设置为 1，执行慢开始算法。 </li>
<li><img src="cpp-review/1567386917332.png" alt="1567386917332"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>TCP的超时和重传</p>
<ul>
<li><p>对每个连接，TCP管理4个不同的定时器</p>
<ul>
<li>重传定时器用于当发送一个数据报文时，在规定时间内，发送方需要收到另一端发出的接收报文确认。</li>
<li>坚持persist定时器使窗口大小信息保持不断流动，即使另一端关闭了其接收窗口 chapter23</li>
<li>保活keepalive定时器用于检测一个空闲连接的另一端是否依然保持连接。chapter23</li>
<li>2MSL定时器测量一个连接处于TIME_WAIT状态的时间。chapter18.6</li>
</ul>
</li>
<li><p>快重传算法</p>
<ul>
<li>要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</li>
<li>由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量 </li>
<li>快速重传后执行的不是慢启动，而是拥塞避免算法</li>
</ul>
</li>
<li><p>快速恢复算法</p>
<ul>
<li>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把 ssthresh 门限减半。<br>但是接下去并不执行慢开始算法 </li>
</ul>
</li>
<li><p>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络<br>  可能没有出现拥塞。所以此时不执行慢开始算法，而是将 cwnd 设置为 ssthresh 的大小，<br>  然后执行拥塞避免算法。 </p>
<ul>
<li><img src="cpp-review/1567388045381.png" alt="1567388045381"></li>
</ul>
</li>
</ul>
</li>
<li><p>TCP坚持定时器</p>
<ul>
<li>解决通告窗口的ACK丢失时，双方的死锁问题</li>
<li>解决问题：接收端的缓存满的时候，接收端回向发送端回复一个窗口为0的ACK，而后接收端在向发送端发送窗口大于0的ACK报文，而此ACK的输出是不可靠的，如果此ａｃｋ丢失了，那么，发送端永远不会向接收端发送数据，因为他认为接收端的缓存是满的，而接收端却在等待发送端发送数据（因为发送了一个大于0的窗口），这就产生了死锁。</li>
<li>解决方案： 使用坚持定时器。<strong>当发送端接收到接收端窗口为０的回复，那么发送端启动坚持定时器，然后定期向接收端发送一个字节的报文段的，直到接收端回复缓存可用为止</strong>。（TCP总是允许在关闭连接前发送一个字节的数据）</li>
<li>工作过程<ul>
<li>1.发送端收到0窗口通告后，启动坚持定时器，并在定时器溢出的时候向客户端查询窗口是否已经增大</li>
<li>2在定时器未到，就收到非0通告，则关闭定时器。并发送数据</li>
<li>3若定时器已到，还没有收到非0通告，就发送探查报文</li>
<li>4如果探查报文ACK的通告窗口为0，将坚持定时器的值加倍，TCP的坚持定时器使用1,2,4,8,18。。64这样的普通指数退避来作为每一次的溢出时间，重复1,2,3步，直至通告窗口非0，发送数据，关闭定时器。</li>
</ul>
</li>
<li>糊涂窗口综合征<ul>
<li>可发生在两端中的任何一端：接收方可以通告一个小的窗口（而不是一直等到有大的窗口时才通告），而发送方也可以发送少量的数据（而不是等待其他的数据以便发送一个大的报文段）</li>
<li>解决方案<ul>
<li>接收方不通告小窗口</li>
<li>发送方避免出现糊涂窗口综合症的措施是仅在满足下列条件时才发送数据<ul>
<li>可以发送一个满长度的报文</li>
<li>可以发送至少是接收方通告最大窗口大小一半的报文</li>
<li>没有还未被确认的数据时或者TCP连接上禁止使用Nagle算法（能够发送手头的所有数据并且不希望接收ACK，或者该连接禁止了Nagle算法时，可以发送任意数据。）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>TCP保活定时器</p>
<ul>
<li>许多时候一个服务器希望知道客户主机是否关机或者崩溃又重新启动。许多实现提供的保活定时器可以提供这种能力</li>
</ul>
</li>
</ul>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><ul>
<li>域名解析， <a href="http://www.xxx.com" target="_blank" rel="noopener">www.xxx.com</a> 转换成 ip </li>
<li>DNS 协议运行在 UDP 协议之上，使用端口号 53 </li>
<li>主机解析域名的顺序 <ul>
<li>浏览器缓存 </li>
<li>找本机的 hosts 文件 </li>
<li>路由缓存 </li>
<li>找 DNS 服务器(本地域名、顶级域名、根域名) <ul>
<li>迭代查询、递归查询 </li>
</ul>
</li>
</ul>
</li>
<li>一、主机向本地域名服务器的查询一般都是采用递归查询。<ul>
<li>递归查询就是如果主机所询问的本地域名服务器不知道查询域名的IP，那么本地域名服务器已DNS客户的形式向其他跟域名服务器继续发出查询报文请求（替主机继续查询），而不是让主机自己进行下一步查询。因此，递归查询的查询结果或者是所要查询的IP，或者报错，表示找不到IP</li>
</ul>
</li>
<li>本地域名服务器向根域名服务器的查询为迭代查询<ul>
<li>当根域名服务器收到本地域名服务器发出的迭代查询报文时，要么给出所要查询的IP地址，要么告诉本地服务器，你下一步应当向哪一个域名服务器进行查询。然后让本地服务器进行后续查询。根域名服务器通常把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器再收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后知道了所要解析的IP地址，然后把这个结果返回给发起查询的主机。</li>
</ul>
</li>
<li>DNS_CLIENT客户端查看HOSTS文件以及本地DNS缓存，没有找到对应记录</li>
<li>DNS-CLIENT联系本地DNS服务器，查询域名<a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a></li>
<li>DNS-Server 联系根域名服务器 查询 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a></li>
<li>根域名服务器返回 com顶级域名服务器的IP</li>
<li>DNS-Server联系 com DNS Server</li>
<li>com DNS Server 返回 google.com域的DNS服务器IP</li>
<li>DNS服务器联系 google.com DNS Server，</li>
<li>google.com DNS Server 返回IP地址</li>
<li>DNS Server 向DNS-Client 返回<a href="http://www.google.com的IP" target="_blank" rel="noopener">www.google.com的IP</a></li>
<li>DNS-Client向该IP发送数据传出请求</li>
</ul>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ul>
<li><p>超文本传输协议，</p>
<ul>
<li>请求报文由请求行，请求头，空行，消息体实现</li>
<li>响应报文由状态行，响应头，空行，消息体实现</li>
</ul>
</li>
<li><p>返回码</p>
<ul>
<li>1xx，指示信息-表示请求已接收，继续处理</li>
<li>2xx，成功-表示请求已被成功接收、理解、接受</li>
<li>3xx，重定向-要完成请求必须进行更进一步的操作</li>
<li>4xx，客户端错误-请求有语法错误或者请求无法实现</li>
<li>5xx，服务器错误=服务器未能实现合法的请求</li>
<li>200 OK，客户端请求成功</li>
<li>204 No Content。服务器聚堆对PUT POST或者DELETE请求返回任何状态信息或表示</li>
<li>206 partial content 服务器已经正确处理部分GET请求，实现断点续传或同时分片下载，该请求必须包含Range请求头来指示客户端期望得到的范围</li>
<li>300 multiple choice（可选重定向）若被请求的资源在服务器端存在多个表示，而服务器不知道客户端想要的是哪一个表示时，发送这个响应代码</li>
<li>301 moved permanently(永久重定向)，该资源已被永久移动到新位置，将来任何对该资源的访问都要使用本响应返回的若干个URI之一，服务器知道客户端试图访问的是哪个资源，但它不喜欢客户端用当前URI来请求该资源。它希望客户端记住另一个URI，并在今后的请求中使用那个新的URI</li>
<li>302 move temporarily(临时重定向)；请求的资源现在临时从不同的URI中获得</li>
<li>304 not modified 如果客户端发送一个待条件的GET请求并且该请求已经被允许，而文档内容未改变，则返回304，响应不包含内容体</li>
<li>403 forbidden 服务器收到请求，但是拒绝提供服务,</li>
<li>400 :Bad Request，请求出错，由于语法格式有误，服务器无法理解此请求。不做修改，客户程序就无法重复</li>
<li>401:Unauthorized，客户端对一个受保护的资源进行操作，却又没有提供正确的认证证书。</li>
<li>404:Not Found，404表明服务器无法把客户端请求的URI转换为一个资源</li>
<li>500：Internal Server Error。通用的服务器错误响应</li>
<li>503(“Service Unavailable”)。响应代码表明HTTP服务器正常，只是下层web服务服务不能正常工作。最可能的原因是资源不足：服务器突然收到太多请求，以至于无法全部处理。由于此问题多半由客户端反复发送请求造成，因此HTTP服务器可以选择拒绝接受客户端请求而不是接受它，并发送503响应代码。</li>
<li>505(“HTTP Version Not Supported”)，当服务器不支持客户端试图使用的HTTP版本时发送此响应代码。</li>
</ul>
</li>
<li><p>GET VS POST</p>
</li>
<li><ul>
<li><p>get请求通过url传递，url中传递的参数有长度限制，只能进行url编码</p>
</li>
<li><p>post请求放在request body中，没有长度限制，安全，有多种编码方式</p>
</li>
<li><p>GET请求，产生一个TCP数据包，浏览器会将http header 和data一并发送出去，服务器响应200（返回数据）</p>
</li>
<li><p>POST请求，产生两个TCP数据包，浏览器首先发送header，服务器响应100，浏览器再发送data，服务器响应200</p>
</li>
<li><p>get请求参数会完整保留在浏览历史记录中，post参数不会</p>
</li>
</ul>
</li>
<li><p>Cookie VS Session</p>
<ul>
<li>cookie 是一种发送到客户浏览器的文本串句柄，并保存在客户机硬盘上，可以用来在<br>某个 WEB 站点会话间持久的保持数据 </li>
<li>session 其实指的就是访问者从到达某个特定主页到离开为止的那段时间。 Session 其<br>实是利用 Cookie 进行信息处理的，当用户首先进行了请求后，服务端就在用户浏览器<br>上创建了一个 Cookie，当这个 Session 结束时，其实就是意味着这个 Cookie 就过期了 </li>
<li>cookie 数据保存在客户端， session 数据保存在服务器端 </li>
</ul>
</li>
<li><p>一次完整的HTTP请求</p>
<ul>
<li>客户端浏览器通过DNS解析IP地址。</li>
<li>发起TCP的3次握手</li>
<li>建立TCP连接后发起http请求 </li>
<li>服务器响应http请求，浏览器得到html代码 </li>
<li>浏览器解析html代码，并请求html代码中的资源</li>
<li>浏览器对页面进行渲染呈现给用户</li>
</ul>
</li>
<li><p>HTTP VS HTTPS</p>
<ul>
<li>HTTP协议以明文方式在网络中传输数据，HTTPS协议传输的数据经TLS加密后传输</li>
<li>HTTPS在经过TCP三次握手后，还要进行SSL的handshake，协商加密使用的对称加密秘钥</li>
<li>HTTPS需要服务端申请证书，浏览器安装相应证书</li>
<li>HTTP端口80，HTTPS端口443</li>
<li>HTTPS传输过程中使用秘钥加密，安全</li>
<li>HTTPS认证用户和服务器，确保数据发送到正确的用户和服务器</li>
</ul>
</li>
<li><p>HTTP 1.0 VS HTTP1.1</p>
<ul>
<li>增加了缓存控制策略，Entity tag，If-Unmodified-Since, If-Match, If-None-Match</li>
<li><strong>带宽优化及网络连接的使用</strong>，请求头引入了range头域，允许只请求资源的某个部分，即返回码是206（Partial Content）。</li>
<li><strong>错误通知的管理</strong>，在HTTP1.1中新增了24个错误状态响应码。如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除</li>
<li><strong>Host头处理</strong>，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）</li>
<li><strong>长连接</strong>，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟</li>
</ul>
</li>
<li><p>HTTP1.1 VS HTTP2.0</p>
<ul>
<li>HTTP2.0采用二进制格式而不是文本格式</li>
<li>HTTP2.0完全的多路复用，非有序阻塞，只要有一个连接就可以实现并行</li>
<li>使用报头压缩，HTTP2.0降低了开销</li>
<li>HTTP2.0让服务器可以将响应主动推送到客户端缓存中</li>
</ul>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><ul>
<li><p>非对称加密算法：RSA，DSA/DSS </p>
<pre><code>对称加密算法：AES，RC4，3DES 
HASH算法：MD5，SHA1，SHA256</code></pre></li>
<li><p>握手过程</p>
<ul>
<li>客户端发送HTTP连接请求<ul>
<li><strong>浏览器将自己支持的一套加密规则发送给网站</strong></li>
</ul>
</li>
<li>服务器响应<ul>
<li>选择合适的加密算法，和hash算法，并将自己的身份信息已证书形式发送给浏览器。（证书包含，服务端加密的公钥，以及证书的颁发机构，证书的数字签名，网站地址，）</li>
</ul>
</li>
<li>客户端验证服务器端数字签名，发送秘钥给服务器<ul>
<li>验证证书中的数字签名</li>
<li>生成随机数a，作为对称加密的秘钥，使用服务端公钥对a进行加密得到b</li>
<li>生成握手消息，以a为秘钥进行对称加密得到c。</li>
<li>计算握手消息的hash值，得到d</li>
<li>将b，c，d发送给服务端</li>
</ul>
</li>
<li>服务端确认加密秘钥<ul>
<li>使用私钥解密b，得到a</li>
<li>以a为秘钥，解密c得到握手消息</li>
<li>计算握手消息的hash，验证是否与d相等</li>
<li>生成新的握手消息，以a为秘钥进行对称加密，得到e</li>
<li>计算新的握手消息的hash，得到f</li>
<li>将e，f发送客户端</li>
</ul>
</li>
<li>握手过程完成，客户端发送加密数据给服务端<ul>
<li>以a为秘钥对e进行对称解密，得到握手消息</li>
<li>计算握手消息的hash，验证是否与f相等</li>
<li>至此，握手结束，之后所有数据已a为秘钥进行对称加密后传输</li>
</ul>
</li>
</ul>
</li>
<li><p>客户端验证服务端数字签名</p>
<ul>
<li><p>获取对应证书颁发机构的公钥</p>
<ul>
<li>根据证书的数字签名，获取对应证书颁发机构的公钥，该公钥被根证书颁发机构使用其私钥加密过的</li>
</ul>
</li>
</ul>
</li>
<li><p>解密并获得证书颁发机构的公钥</p>
<ul>
<li><p>使用本地根证书公钥，解密获得证书颁发机构的公钥。本地根证书公钥是在用户安装操作系统时，由操作系统写入浏览器</p>
</li>
<li><p>解密数字签名，验证服务端公钥</p>
<ul>
<li>使用证书颁发机构的公钥，解密数字签名得到服务端公钥的hash，</li>
</ul>
</li>
<li><p>计算服务端公钥的hash，验证两者是否相同</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="KEEP-ALIVE"><a href="#KEEP-ALIVE" class="headerlink" title="KEEP-ALIVE"></a>KEEP-ALIVE</h2><ul>
<li>HTTP<ul>
<li>通过使用keep-alive机制，可以减少tcp连接建立次数，也意味着可以减少TIME_WAIT状态连接，以此提高性能和提高httpd服务器的吞吐率(更少的tcp连接意味着更少的系统内核调用,socket的accept()和close()调用)</li>
<li>keep-alive并不是免费的午餐,长时间的tcp连接容易导致系统资源无效占用。配置不当的keep-alive，有时比重复利用连接带来的损失还更大。所以，正确地设置keep-alive timeout时间非常重要</li>
</ul>
</li>
<li>TCP<ul>
<li>链接建立之后，如果应用程序或者上层协议一直不发送数据，或者隔很长时间才发送一次数据，当链接很久没有数据报文传输时如何去确定对方还在线，到底是掉线了还是确实没有数据传输，链接还需不需要保持，这种情况在TCP协议设计中是需要考虑到的。</li>
<li>TCP协议通过一种巧妙的方式去解决这个问题，当超过一段时间之后，TCP自动发送一个数据为空的报文给对方，如果对方回应了这个报文，说明对方还在线，链接可以继续保持，如果对方没有报文返回，并且重试了多次之后则认为链接丢失，没有必要保持链接</li>
</ul>
</li>
</ul>
<h2 id="套接字socket"><a href="#套接字socket" class="headerlink" title="套接字socket"></a>套接字socket</h2><ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>; <span class="comment">//epoll的事件注册函数，注册监控的文件描述符以及所监控的事件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events,<span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;<span class="comment">//等待事件产生，返回需要处理的时间的数目</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>边缘触发</p>
<ul>
<li>设置socket非阻塞 </li>
<li>epoll_ctl设置边缘触发</li>
<li>在读取数据时需要读完，read返回-1，errno=EAGAIN</li>
</ul>
</li>
</ul>
<h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><h2 id="稳定排序"><a href="#稳定排序" class="headerlink" title="稳定排序"></a>稳定排序</h2><ul>
<li>有两个排序关键字的时候，稳定排序可以让第一个关键字排序的结果服务于第二个关键字排序中数值相等的那些数。</li>
</ul>
<h2 id="各种树"><a href="#各种树" class="headerlink" title="各种树"></a>各种树</h2><ul>
<li><p>rb tree  VS AVL tree</p>
</li>
<li><ul>
<li><p>AVL 树要求严格，对于任何一个节点，其左右子树的高度差最多等于1，</p>
</li>
<li><p>对于有n个节点的红黑树，最差情况下，它的最大高度可能会达到2logn（仍是O（logn）级别的复杂度）</p>
</li>
<li><p><strong>对红黑树进行增删改查操作，复杂度都是O（logn）。</strong> 可以看出，在红黑树中查找元素其实比AVL要慢（因为AVL高度为O（logn），但是，在红黑树中增加和删除元素要比AVL快。</p>
</li>
<li><p>红黑树不追求”完全平衡”，即不像AVL那样要求节点的 <code>|balFact| &lt;= 1</code>，它只要求部分达到平衡，但是提出了为节点增加颜色，红黑是用非严格的平衡来换取增删节点时候旋转次数的降低，任何不平衡都会在三次旋转之内解决，而AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多。</p>
</li>
<li><p>就插入节点导致树失衡的情况，AVL和RB-Tree都是最多两次树旋转来实现复衡rebalance，旋转的量级是O(1)</p>
</li>
<li><p>删除节点导致失衡，AVL需要维护从被删除节点到根节点root这条路径上所有节点的平衡，旋转的量级为O(logN)，而RB-Tree最多只需要旋转3次实现复衡，只需O(1)，所以说RB-Tree删除节点的rebalance的效率更高，开销更小！</p>
</li>
<li><p>AVL的结构相较于RB-Tree更为平衡，插入和删除引起失衡，如2所述，RB-Tree复衡效率更高；当然，由于AVL高度平衡，因此AVL的Search效率更高啦。</p>
</li>
<li><p>针对插入和删除节点导致失衡后的rebalance操作，红黑树能够提供一个比较”便宜”的解决方案，降低开销，是对search，insert ，以及delete效率的折衷，总体来说，RB-Tree的统计性能高于AVL.</p>
</li>
<li><p>AVL树适合用于插入与删除次数比较少，但查找多的情况；<strong>相对于要求严格的AVL树来说，红黑树的旋转次数少，所以对于搜索、插入、删除操作较多的情况下，我们就用红黑树</strong> </p>
</li>
</ul>
</li>
<li><p>B tree B+ Tree</p>
<ul>
<li>B-树 即B树</li>
<li>B 树=有序数组+二叉搜索树</li>
<li>B+树=有序链表+二叉搜索树</li>
<li>B+树比B树更适合数据库索引<ul>
<li><strong>B+树的磁盘读写代价更低</strong>，B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了</li>
<li><strong>B+树的查询效率更加稳定</strong>：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当</li>
<li>由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次<strong>中序遍历</strong>按序来扫，所以B+树更加适合在<strong>区间查询</strong>的情况，所以通常B+树用于数据库索引</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="hashtable-哈希表"><a href="#hashtable-哈希表" class="headerlink" title="hashtable 哈希表"></a>hashtable 哈希表</h2><ul>
<li><p>负载系数=元素个数/表格大小</p>
</li>
<li><p>避免地址冲突</p>
<ul>
<li><p>线性探测：如果hash函数计算某个元素的插入位置后，如果该位置的空间已经被占据，则继续向下寻找，直到找到一个可用空间为止，尝试H+1，H+2，H+3，H+4</p>
</li>
<li><p>二次探测：如果计算的位置被占用，依次尝试H+1^2，H+2^2，H+3^2，H+4^2，</p>
<ul>
<li>设置表格大小为质数，永远保持负载系数在0.5以下（超过0.5重新配置并整理表格），确定没插入一个元素所需要的探测次数不多于2</li>
</ul>
</li>
<li><p>开链，维护buckets，bucket个数为质数，每个表格元素bucket维护一个list，在那个list中执行插入，删除，前提list够短，负载&gt;1，当元素个数大于bucket个数时，链表打散rehashing，bucket大小变为两倍大小左右的素数</p>
<ul>
<li>vector 维护buckets</li>
<li>通过hash函数%表长，获得bucket索引，之后再bucket所维护的链表中轮询，如果相等，直接插入前面，否则，新建节点添加到头部<h2 id="二叉树性质"><a href="#二叉树性质" class="headerlink" title="二叉树性质"></a>二叉树性质</h2></li>
</ul>
</li>
</ul>
</li>
<li><p>​        性质1 ： 二叉树的第 i 层上至多有 2^(i-1) 个结点 (i&gt;=1)</p>
<p>​        性质2 ：  深度为 k 的二叉树至多有 2^k -1 个结点( k&gt;=1)</p>
<p>​        性质3 ：  对任意的一颗二叉树 T ，若叶子结点数为 n0,而其度数为 2 的结点数为 n2,则 n0 = n2+1</p>
<p>​        性质4 ：  具有 n 个结点的完全二叉树的深度 [log2n]+1</p>
<p>​        性质 5：  如果有一颗有n个节点的完全二叉树的节点按层次序编号，对任一层的节点i（1&lt;=i&lt;=n）有</p>
<p>​                        (1).如果i=1，则节点是二叉树的根，无双亲，如果i&gt;1，则其双亲节点为[i/2]，向下取整</p>
<p>​                        (2).如果2i&gt;n那么节点i没有左孩子，否则其左孩子为2i</p>
<p>​                        (3).如果2i+1&gt;n那么节点没有右孩子，否则右孩子为2i+1</p>
<ul>
<li>具有n个结点的完全二叉树（包括满二叉树）的高度为[log2n+1] （向下取整）<br>or｛log2(n+1)｝（向上取整）</li>
</ul>
</li>
</ul>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><ul>
<li><p>二叉搜索树</p>
</li>
<li><p>AVL-TREE</p>
</li>
<li><p>RB-tree 是二叉搜索树</p>
<ul>
<li>每个节点不是黑色就是红色</li>
<li>根节点为黑色</li>
<li>若节点为红色，子节点一定为黑</li>
<li>任一节点到NULL（树尾端）的任何路径，所含黑节点个数必须相同</li>
</ul>
</li>
<li><p>AA-TREE</p>
</li>
</ul>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><ul>
<li><p>epoll</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ul>
</li>
<li><p>线程池实现</p>
<ul>
<li>领导者跟随者模式<ul>
<li>在LF线程池中，线程可处在3种线程状态之一：leader、follower或processor。处于leader状态的线程负责监听网络端口，当有消息到达时，该线程负责消息分离，并从处于 follower状态中的线程中按照某种机制如FIFO或基于优先级等选出一个来当新的leader，然后将自己设置为processor状态去分配和处理该事件。处理完毕后线程将自身的状态设置为follower状态去等待重新成为leader。在整个线程池中同一时刻只有一个线程可以处于leader状态，这保证了同一事件不会被多个线程重复处理</li>
<li>一个线程安全的queue维护一个任务队列，（类，有thread_handle函数）</li>
<li>创建N个线程，每个线程的处理函数都process_task函数，</li>
<li>在process_task中，提升一个领导者，然后从任务队列中pop一个，添加一个跟随者，执行线程处理函数</li>
</ul>
</li>
<li></li>
</ul>
</li>
</ul>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="singleton"><a href="#singleton" class="headerlink" title="singleton"></a>singleton</h2><ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    Singleton()&#123;&#125;</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp;)&#123;&#125;</span><br><span class="line">    ~Singleton();</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">static</span> Singleton ss;</span><br><span class="line">         <span class="keyword">return</span> ss;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><ul>
<li><p><img src="cpp-review/1570690570733.png" alt="1570690570733"></p>
</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Attach</span><span class="params">(Observer *)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Detach</span><span class="params">(Observer *)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Notify</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> :</span> <span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ConcreteObserver(Subject *pSubject) : m_pSubject(pSubject)&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ConcreteObserver get the update. New State:"</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Subject *m_pSubject;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver2</span> :</span> <span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ConcreteObserver2(Subject *pSubject) : m_pSubject(pSubject)&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ConcreteObserver2 get the update. New State:"</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Subject *m_pSubject;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> :</span> <span class="keyword">public</span> Subject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Attach</span><span class="params">(Observer *pObserver)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Detach</span><span class="params">(Observer *pObserver)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Notify</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetState</span><span class="params">(<span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_iState = state;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;Observer *&gt; m_ObserverList;</span><br><span class="line">    <span class="keyword">int</span> m_iState;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> ConcreteSubject::Attach(Observer *pObserver)</span><br><span class="line">&#123;</span><br><span class="line">    m_ObserverList.push_back(pObserver);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> ConcreteSubject::Detach(Observer *pObserver)</span><br><span class="line">&#123;</span><br><span class="line">    m_ObserverList.remove(pObserver);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> ConcreteSubject::Notify()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;Observer *&gt;::iterator it = m_ObserverList.begin();</span><br><span class="line">    <span class="keyword">while</span> (it != m_ObserverList.end())</span><br><span class="line">    &#123;</span><br><span class="line">        (*it)-&gt;Update(m_iState);</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Create Subject</span></span><br><span class="line">    ConcreteSubject *pSubject = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Create Observer</span></span><br><span class="line">    Observer *pObserver = <span class="keyword">new</span> ConcreteObserver(pSubject);</span><br><span class="line">    Observer *pObserver2 = <span class="keyword">new</span> ConcreteObserver2(pSubject);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Change the state</span></span><br><span class="line">    pSubject-&gt;SetState(<span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Register the observer</span></span><br><span class="line">    pSubject-&gt;Attach(pObserver);</span><br><span class="line">    pSubject-&gt;Attach(pObserver2);</span><br><span class="line"> </span><br><span class="line">    pSubject-&gt;Notify();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Unregister the observer</span></span><br><span class="line">    pSubject-&gt;Detach(pObserver);</span><br><span class="line"> </span><br><span class="line">    pSubject-&gt;SetState(<span class="number">3</span>);</span><br><span class="line">    pSubject-&gt;Notify();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">delete</span> pObserver;</span><br><span class="line">    <span class="keyword">delete</span> pObserver2;</span><br><span class="line">    <span class="keyword">delete</span> pSubject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ul>
<h1 id="场景问题"><a href="#场景问题" class="headerlink" title="场景问题"></a>场景问题</h1><ul>
<li>N个有序的数组，每个都有M个元素，排序</li>
<li></li>
</ul>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2019/08/30/cpp-review/">cpp-review</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">bliss7</a></p>
        <p><span>发布时间:</span>2019-08-30, 08:30:52</p>
        <p><span>最后更新:</span>2019-11-11, 14:05:48</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2019/08/30/cpp-review/" title="cpp-review">blissseven.top/2019/08/30/cpp-review/</a>
            <span class="copy-path" data-clipboard-text="原文: blissseven.top/2019/08/30/cpp-review/　　作者: bliss7" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2019/09/05/code-review/">
                    code-review
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2019/08/28/network-program/">
                    network-program
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C"><span class="toc-number">1.</span> <span class="toc-text">C++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#成员变量初始化顺序"><span class="toc-number">1.1.</span> <span class="toc-text">成员变量初始化顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RTTI"><span class="toc-number">1.2.</span> <span class="toc-text">RTTI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#strcpy-strncpy"><span class="toc-number">1.3.</span> <span class="toc-text">strcpy strncpy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASCII-utf-8-unicode"><span class="toc-number">1.4.</span> <span class="toc-text">ASCII-utf-8-unicode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么static函数不能const修饰和virtual修饰"><span class="toc-number">1.5.</span> <span class="toc-text">为什么static函数不能const修饰和virtual修饰</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#判断一个对象调用是否经过虚函数表"><span class="toc-number">1.6.</span> <span class="toc-text">判断一个对象调用是否经过虚函数表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda实现原理"><span class="toc-number">1.7.</span> <span class="toc-text">lambda实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-C的类型安全"><span class="toc-number">1.8.</span> <span class="toc-text">C++/C的类型安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#auto-VS-decltype"><span class="toc-number">1.9.</span> <span class="toc-text">auto VS decltype</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#访问权限"><span class="toc-number">1.10.</span> <span class="toc-text">访问权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#程序优化"><span class="toc-number">1.11.</span> <span class="toc-text">程序优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异常"><span class="toc-number">1.12.</span> <span class="toc-text">异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四种类型转换"><span class="toc-number">1.13.</span> <span class="toc-text">四种类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-C-函数调用的压栈模型"><span class="toc-number">1.14.</span> <span class="toc-text">C/C++函数调用的压栈模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#成员初始化列表"><span class="toc-number">1.15.</span> <span class="toc-text">成员初始化列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存泄漏"><span class="toc-number">1.16.</span> <span class="toc-text">内存泄漏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结构体内存对齐"><span class="toc-number">1.17.</span> <span class="toc-text">结构体内存对齐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造函数"><span class="toc-number">1.18.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#引用和指针实现多态"><span class="toc-number">1.19.</span> <span class="toc-text">引用和指针实现多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造函数的几种关键字-default-delete-0"><span class="toc-number">1.20.</span> <span class="toc-text">构造函数的几种关键字(default  delete   0)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#成员模板"><span class="toc-number">1.21.</span> <span class="toc-text">成员模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final-VS-override"><span class="toc-number">1.22.</span> <span class="toc-text">final  VS override</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-VS-class"><span class="toc-number">1.23.</span> <span class="toc-text">struct VS class</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指针和引用区别"><span class="toc-number">1.24.</span> <span class="toc-text">指针和引用区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#main函数之前"><span class="toc-number">1.25.</span> <span class="toc-text">main函数之前</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#main返回值"><span class="toc-number">1.26.</span> <span class="toc-text">main返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-内存模型"><span class="toc-number">1.27.</span> <span class="toc-text">C++内存模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象的四个特性"><span class="toc-number">1.28.</span> <span class="toc-text">面向对象的四个特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆和栈的区别"><span class="toc-number">1.29.</span> <span class="toc-text">堆和栈的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile"><span class="toc-number">1.30.</span> <span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内联函数VS宏定义"><span class="toc-number">1.31.</span> <span class="toc-text">内联函数VS宏定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-VS-C最大特点"><span class="toc-number">1.32.</span> <span class="toc-text">C++ VS C最大特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static-assert"><span class="toc-number">1.33.</span> <span class="toc-text">static_assert</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-11新特性"><span class="toc-number">1.34.</span> <span class="toc-text">c++11新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#访问类的私有变量"><span class="toc-number">1.35.</span> <span class="toc-text">访问类的私有变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二维数组"><span class="toc-number">1.36.</span> <span class="toc-text">二维数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚基类表"><span class="toc-number">1.37.</span> <span class="toc-text">虚基类表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#extern-C"><span class="toc-number">1.38.</span> <span class="toc-text">extern C</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编译型VS解释型VS动态语言VS静态语言"><span class="toc-number">1.39.</span> <span class="toc-text">编译型VS解释型VS动态语言VS静态语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造函数-VS析构函数"><span class="toc-number">1.40.</span> <span class="toc-text">构造函数 VS析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拷贝构造VS-赋值构造"><span class="toc-number">1.41.</span> <span class="toc-text">拷贝构造VS 赋值构造</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#overload-VS-override-VS-overwrite"><span class="toc-number">1.42.</span> <span class="toc-text">overload VS override VS overwrite</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量的声明和定义"><span class="toc-number">1.43.</span> <span class="toc-text">变量的声明和定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new的变种"><span class="toc-number">1.44.</span> <span class="toc-text">new的变种</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#特殊对象构建"><span class="toc-number">1.45.</span> <span class="toc-text">特殊对象构建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存分配方式"><span class="toc-number">1.46.</span> <span class="toc-text">内存分配方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static-const关键字"><span class="toc-number">1.47.</span> <span class="toc-text">static const关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#define-和const的区别"><span class="toc-number">1.48.</span> <span class="toc-text">define 和const的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#智能指针"><span class="toc-number">1.49.</span> <span class="toc-text">智能指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#移动语义"><span class="toc-number">1.50.</span> <span class="toc-text">移动语义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义函数"><span class="toc-number">1.51.</span> <span class="toc-text">自定义函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#STL"><span class="toc-number">2.</span> <span class="toc-text">STL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#空间配置器"><span class="toc-number">2.1.</span> <span class="toc-text">空间配置器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#迭代器"><span class="toc-number">2.2.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vector实现"><span class="toc-number">2.3.</span> <span class="toc-text">vector实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#list实现"><span class="toc-number">2.4.</span> <span class="toc-text">list实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#deque实现"><span class="toc-number">2.5.</span> <span class="toc-text">deque实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#priority-queue"><span class="toc-number">2.6.</span> <span class="toc-text">priority_queue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set-map实现"><span class="toc-number">2.7.</span> <span class="toc-text">set-map实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unordered-set-map实现"><span class="toc-number">2.8.</span> <span class="toc-text">unordered-set/map实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法"><span class="toc-number">2.9.</span> <span class="toc-text">算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-11-多线程"><span class="toc-number">3.</span> <span class="toc-text">C++11 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#linux命令"><span class="toc-number">3.1.</span> <span class="toc-text">linux命令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#操作系统"><span class="toc-number">4.</span> <span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#内存管理"><span class="toc-number">4.1.</span> <span class="toc-text">内存管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可重入函数"><span class="toc-number">4.2.</span> <span class="toc-text">可重入函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#copy-on-write"><span class="toc-number">4.3.</span> <span class="toc-text">copy on write</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#页面置换算法"><span class="toc-number">4.4.</span> <span class="toc-text">页面置换算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程调度"><span class="toc-number">4.5.</span> <span class="toc-text">进程调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存分配方式及错误"><span class="toc-number">4.6.</span> <span class="toc-text">内存分配方式及错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存溢出VS内存泄漏"><span class="toc-number">4.7.</span> <span class="toc-text">内存溢出VS内存泄漏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟内存VS-swap分区"><span class="toc-number">4.8.</span> <span class="toc-text">虚拟内存VS swap分区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断VS异常"><span class="toc-number">4.9.</span> <span class="toc-text">中断VS异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程终止的方式"><span class="toc-number">4.10.</span> <span class="toc-text">进程终止的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#特殊进程"><span class="toc-number">4.11.</span> <span class="toc-text">特殊进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#怎么回收线程"><span class="toc-number">4.12.</span> <span class="toc-text">怎么回收线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程-线程数量"><span class="toc-number">4.13.</span> <span class="toc-text">进程/线程数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一个程序从开始运行到结束的完整过程"><span class="toc-number">4.14.</span> <span class="toc-text">一个程序从开始运行到结束的完整过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用户态VS内核态"><span class="toc-number">4.15.</span> <span class="toc-text">用户态VS内核态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#死锁"><span class="toc-number">4.16.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程间通信方式"><span class="toc-number">4.17.</span> <span class="toc-text">进程间通信方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux-IO模型"><span class="toc-number">4.18.</span> <span class="toc-text">linux IO模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#select-VS-epoll"><span class="toc-number">4.19.</span> <span class="toc-text">select VS epoll</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程VS-协程"><span class="toc-number">4.20.</span> <span class="toc-text">进程VS 协程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#硬链接、软连接"><span class="toc-number">4.21.</span> <span class="toc-text">硬链接、软连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用户权限"><span class="toc-number">4.22.</span> <span class="toc-text">用户权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux命令-1"><span class="toc-number">4.23.</span> <span class="toc-text">linux命令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#计算机网络"><span class="toc-number">5.</span> <span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-IP协议体系"><span class="toc-number">5.1.</span> <span class="toc-text">TCP/IP协议体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据链路层"><span class="toc-number">5.2.</span> <span class="toc-text">数据链路层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP"><span class="toc-number">5.3.</span> <span class="toc-text">IP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP"><span class="toc-number">5.4.</span> <span class="toc-text">UDP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP"><span class="toc-number">5.5.</span> <span class="toc-text">TCP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DNS"><span class="toc-number">5.6.</span> <span class="toc-text">DNS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP"><span class="toc-number">5.7.</span> <span class="toc-text">HTTP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS"><span class="toc-number">5.8.</span> <span class="toc-text">HTTPS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KEEP-ALIVE"><span class="toc-number">5.9.</span> <span class="toc-text">KEEP-ALIVE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#套接字socket"><span class="toc-number">5.10.</span> <span class="toc-text">套接字socket</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数据结构和算法"><span class="toc-number">6.</span> <span class="toc-text">数据结构和算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#稳定排序"><span class="toc-number">6.1.</span> <span class="toc-text">稳定排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#各种树"><span class="toc-number">6.2.</span> <span class="toc-text">各种树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashtable-哈希表"><span class="toc-number">6.3.</span> <span class="toc-text">hashtable 哈希表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树性质"><span class="toc-number">6.4.</span> <span class="toc-text">二叉树性质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#平衡二叉树"><span class="toc-number">6.5.</span> <span class="toc-text">平衡二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#排序算法"><span class="toc-number">6.6.</span> <span class="toc-text">排序算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数据库"><span class="toc-number">7.</span> <span class="toc-text">数据库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#项目"><span class="toc-number">8.</span> <span class="toc-text">项目</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#设计模式"><span class="toc-number">9.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#singleton"><span class="toc-number">9.1.</span> <span class="toc-text">singleton</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#观察者模式"><span class="toc-number">9.2.</span> <span class="toc-text">观察者模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#场景问题"><span class="toc-number">10.</span> <span class="toc-text">场景问题</span></a></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"cpp-review　| bliss7's blog　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2019/09/05/code-review/" title="上一篇: code-review">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2019/08/28/network-program/" title="下一篇: network-program">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/09/29/linux-cmd/">linux-cmd</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/25/cpp-interview/">cpp-interview</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/05/code-review/">code-review</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/30/cpp-review/">cpp-review</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/28/network-program/">network-program</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/27/cpp11-singleton/">cpp11-singleton</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/22/object-model3/">object-model3</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/21/muduo-note/">muduo_note</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/14/OS/">OS</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/01/object-model2/">C++对象模型探索-2</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/30/cpp-trivial/">cpp_trivial</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/17/数据结构补全计划/">数据结构补全计划</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/13/object-model/">C++对象模型探索-1</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/13/hello-hexo-blog/">hello-hexo-blog</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/13/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/04/tcp-ip-note/">TCP/IP网络协议</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/17/concurrency-in-cpp11-2/">C++11 多线程编程2</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/03/concurrency-in-cpp11/">C++11 多线程编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/17/C-11-note/">C++ 11 新特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/10/design-pattern-note/">Design Pattern</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/08/STL-note/">STL_note</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2020 bliss7
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
				<a href="http://www.beian.miit.gov.cn">豫ICP备18036478号</a>
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 7;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>