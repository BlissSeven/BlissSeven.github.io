<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="bliss7">



<meta name="description" content="好吧，这是为了面试而准备的，顺便查漏补缺">
<meta name="keywords" content="cpp,review">
<meta property="og:type" content="article">
<meta property="og:title" content="cpp-review">
<meta property="og:url" content="blissseven.top/2019/08/30/cpp-review/index.html">
<meta property="og:site_name" content="bliss7&#39;s blog">
<meta property="og:description" content="好吧，这是为了面试而准备的，顺便查漏补缺">
<meta property="og:locale" content="default">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/c9Rd4j0YFFdr.png">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/lp02PfVJt4c9.png">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/IAyD5lcoVH3k.png">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/1567476237158.png">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/1567391865764.png">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/1567391955508.png">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/8AMLnhHgXyzf.png">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/20180208112533496">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/Ou1Q34TIaU52.png">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/1567386917332.png">
<meta property="og:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/1567388045381.png">
<meta property="og:updated_time" content="2019-09-07T05:02:28.706Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="cpp-review">
<meta name="twitter:description" content="好吧，这是为了面试而准备的，顺便查漏补缺">
<meta name="twitter:image" content="blissseven.top/2019/08/30/cpp-review/cpp-review/c9Rd4j0YFFdr.png">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="bliss7&#39;s blog" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>cpp-review | bliss7&#39;s blog</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">bliss7</a></h1>
        </hgroup>

        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-11/">C++11</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-11，trivial/">C++11，trivial</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Concurrency/">Concurrency</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OS/">OS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STL/">STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP-IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/code-review/">code-review</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp/">cpp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp11/">cpp11</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/data-structure/">data structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design-pattern/">design pattern</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/muduo/">muduo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network-program/">network-program</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/object-model/">object model</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/object-model/">object-model</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/object-model/">object_model</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/review/">review</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/singleton/">singleton</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thread/">thread</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程服务器/">多线程服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/操作系统/">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/零碎/">零碎</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">bliss7</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">bliss7</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-cpp-review" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/08/30/cpp-review/" class="article-date">
      <time datetime="2019-08-30T00:30:52.000Z" itemprop="datePublished">2019-08-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      cpp-review
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/review/">review</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <ul>
<li>好吧，这是为了面试而准备的，顺便查漏补缺</li>
</ul>
<a id="more"></a>

<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="变量的声明和定义"><a href="#变量的声明和定义" class="headerlink" title="变量的声明和定义"></a>变量的声明和定义</h2><ul>
<li><p>声明一个变量：变量名前+extern，并且不要显示的初始化变量</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">int</span> j;<span class="comment">//声明并定义j，定义会分配空间</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> pi=<span class="number">3.1416</span>;<span class="comment">//定义</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="new的变种"><a href="#new的变种" class="headerlink" title="new的变种"></a>new的变种</h2><ul>
<li><p>new</p>
<ul>
<li>调用operator new分配内存</li>
<li>在分配的内存上调用构造函数</li>
</ul>
</li>
<li><p>operator new</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span>  <span class="params">( <span class="built_in">std</span>::<span class="keyword">size_t</span> count )</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>placement new</p>
<ul>
<li><p>保持一块内存，反复构造析构，这样可以省略中间的多次分配内存。</p>
</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* ptr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">sizeof</span>(T)]; <span class="comment">// allocate memory  </span></span><br><span class="line">T* tptr = <span class="keyword">new</span>(ptr) T;            <span class="comment">// construct in allocated storage ("place")  </span></span><br><span class="line">tptr-&gt;~T();                      <span class="comment">// destruct  </span></span><br><span class="line"><span class="keyword">delete</span>[] ptr;                    <span class="comment">// deallocate memory</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li></li>
</ul>
<h2 id="特殊对象构建"><a href="#特殊对象构建" class="headerlink" title="特殊对象构建"></a>特殊对象构建</h2><ul>
<li><p><a href="https://blog.csdn.net/hxz_qlh/article/details/13135433#" target="_blank" rel="noopener">https://blog.csdn.net/hxz_qlh/article/details/13135433#</a></p>
</li>
<li><p>一个只能在堆上建立的对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    A()&#123;&#125;</span><br><span class="line">    ~A()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> A* <span class="title">create</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个只能在栈上建立的对象</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> t)</span></span>&#123;&#125;     <span class="comment">// 注意函数的第一个参数和返回值都是固定的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span>&#123;&#125; <span class="comment">// 重载了new就需要重载delete</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A()&#123;&#125;</span><br><span class="line">    ~A()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>不能被继承的类</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="title">final</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">&#125;<span class="comment">//C++11实现</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<pre><code>* <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> T;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Base()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"base"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Base()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> Base&lt;B&gt;&#123;   <span class="comment">//一定注意 必须是虚继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"B"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


* </code></pre><h2 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h2><ul>
<li>栈区，编译器自动分配释放，存放函数的参数，局部变量</li>
<li>堆区，由程序员分配释放，</li>
<li>全局/静态区，全局变量和静态变量存放在一起，编译时分配</li>
<li>文字常量区，存放常量字符串</li>
<li>程序代码区，存放函数体（类成员函数，全局函数）的二进制码</li>
</ul>
<h2 id="static-const关键字"><a href="#static-const关键字" class="headerlink" title="static const关键字"></a>static const关键字</h2><ul>
<li><p>static和const关键字的作用可以从两个方面回答：一是和类的成员函数或者成员变量相关，二是不属于类的函数或者变量。</p>
<ul>
<li><p>static关键字的作用：</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.static 修饰局部变量，该变量静态生存周期，且只被初始化一次</span></span><br><span class="line"><span class="comment">2.static 修饰全局变量，该变量静态生存周期，以及内部连接性，只能该文件访问</span></span><br><span class="line"><span class="comment">3.static 修饰全局函数，该函数内部连接性，只能本文件访问</span></span><br><span class="line"><span class="comment">4.static 修饰成员函数，该成员函数为类所有，没有this指针，只能访问static成员变量</span></span><br><span class="line"><span class="comment">5.static 修饰成员变量，该成员变量为类所有，对类的所有对象只是一份拷贝</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>const关键字的作用</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、想要阻止一个变量被改变，可以使用const关键字。在定义该const关键字是，通常要对它进行初始化，因为以后再也没有机会去改变它。</span></span><br><span class="line"><span class="comment">2、对于指针来说，可以指定指针本身为const，也可以指定指针所指向的数据为const，或者二者同时指定为const。</span></span><br><span class="line"><span class="comment">3、在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值。</span></span><br><span class="line"><span class="comment">4、对于类的成员函数，若指定为const，则表明其实一个常函数，不能修改类的成员变量。</span></span><br><span class="line"><span class="comment">5、对于类的成员函数，有时候必须制定其返回值为const，以使得其返回值不能为左值。典型operator[]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="define-和const的区别"><a href="#define-和const的区别" class="headerlink" title="define 和const的区别"></a>define 和const的区别</h2><ul>
<li><p>区别</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">（1）就起作用的阶段而言： #define是在编译的预处理阶段起作用，而const是在 编译、运行的时候起作用。</span></span><br><span class="line"><span class="comment">（2）就起作用的方式而言： #define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级的错误。 </span></span><br><span class="line"><span class="comment">（3）就存储方式而言：#define只是进行展开，有多少地方使用，就替换多少次，它定义的宏常量在内存中有若干个备份；const定义的只读变量在程序运行过程中只有一份备份。</span></span><br><span class="line"><span class="comment">（4）从代码调试的方便程度而言： const常量可以进行调试的，define是不能进行调试的，因为在预编译阶段就已经替换掉了。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>const 优点</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">（1）const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。</span></span><br><span class="line"><span class="comment">（2）有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试。</span></span><br><span class="line"><span class="comment">（3）const可节省空间，避免不必要的内存分配，提高效率</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><ul>
<li><p>指向的均为堆中对象，new出来的</p>
</li>
<li><p>unique_ptr</p>
<ul>
<li>独占方式，一次只能有一个指针指向对象，不允许拷贝和赋值</li>
<li>可通过临时对象或者move语义实现赋值</li>
<li>get函数获取原生指针</li>
<li>release放弃内部对象的所有权，内部指针置空，此指针需要手动释放</li>
<li>reset函数，销毁内部对象并接受新的对象</li>
<li>对象被销毁以及内存释放的时机<ul>
<li>当离开作用域或者reset时，释放</li>
</ul>
</li>
</ul>
</li>
<li><p>shared_ptr</p>
<ul>
<li>通过引用计数实现共享，使得多个指针可以同时指向一个对象</li>
<li>use_count查看资源的所有者个数</li>
<li>对象被销毁以及内存释放时机<ul>
<li>最后一个拥有该资源的shared_ptr destored</li>
<li>最后一个拥有该资源的shared_ptr 通过operator=赋值给其他，或者reset，即引用计数为0时</li>
</ul>
</li>
</ul>
</li>
<li><p>weak_ptr</p>
<ul>
<li><p>解决shared_ptr相互应用时的死锁问题</p>
</li>
<li><p>对对象的一种弱引用，不会增加对象的引用计数。和shared_ptr可以相互转换，shared_ptr赋值给weak_ptr，weak_ptr通过lock获得shared_ptr</p>
</li>
<li><p>通过lock返回是否是null或者shared_ptr判断，所指向的对象是否已经被释放</p>
</li>
<li><p>也可通过expired 返回true</p>
</li>
<li><p>以及use_count==0</p>
</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;B&gt; pb_;</span><br><span class="line">    ~A()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"A delete\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; pa_;</span><br><span class="line">    ~B()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"B delete\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;B&gt; pb(<span class="keyword">new</span> B());</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; pa(<span class="keyword">new</span> A());</span><br><span class="line">    pb-&gt;pa_ = pa;</span><br><span class="line">    pa-&gt;pb_ = pb;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pb.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pa.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="built_in">shared_ptr</span>&lt;B&gt; pb(<span class="keyword">new</span> B());</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;A&gt; pa(<span class="keyword">new</span> A());</span><br><span class="line">pb-&gt;pa_ = pa;</span><br><span class="line">pa-&gt;pb_ = pb;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;pb.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;pa.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><ul>
<li><p>移动语义–右值引用</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c；</span><br><span class="line"><span class="keyword">int</span>&amp;&amp; a=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp; b=c;<span class="comment">//error只能绑定右值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在一个有动态内存分配的类中，其拷贝构造函数，一定要实现深拷贝，涉及内存的分配，内存的拷贝</p>
</li>
<li><p>虽然右值引用参数绑定了右值，不过在函数内部，会当做左值来进行 </p>
</li>
<li><ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">X&#123;</span><br><span class="line">    <span class="keyword">private</span> </span><br><span class="line">    <span class="keyword">int</span>* x;</span><br><span class="line">    X(<span class="keyword">const</span> X&amp; other): <span class="comment">// 1</span></span><br><span class="line">		data(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>])</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">std</span>::copy(other.data,other.data+<span class="number">1000000</span>,data);</span><br><span class="line">	&#125;</span><br><span class="line">    X (X&amp;&amp; other): <span class="comment">// 2移动构造函数，实现浅拷贝</span></span><br><span class="line">		data(other.data)</span><br><span class="line">	&#123;</span><br><span class="line">		other.data=<span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_stuff</span><span class="params">(X&amp;&amp; x_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">X <span class="title">a</span><span class="params">(x_)</span></span>; <span class="comment">// 拷贝</span></span><br><span class="line">    <span class="function">X <span class="title">b</span><span class="params">(<span class="built_in">std</span>::move(x_))</span></span>; <span class="comment">// 移动</span></span><br><span class="line">&#125; </span><br><span class="line">do_stuff(X()); <span class="comment">// ok，右值绑定到右值引用上</span></span><br><span class="line">X x;</span><br><span class="line">do_stuff(x);</span><br></pre></td></tr></table></figure>
</li>
<li><p>unique_ptr 只支持移动构造不支持拷贝构造</p>
</li>
</ul>
</li>
<li><p>使用static_cast&lt;X&amp;&amp;&gt;或者move 将左值转换为右值</p>
</li>
</ul>
</li>
<li><p>如果函数模板参数以右值引用作为一个模板参数，当对应位置提供左值的时候，模板会自动将其类型认定为左值引用；当提供右值的时候，会当做普通数据使用 </p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">42</span>); <span class="comment">// foo&lt;int&gt;(42)</span></span><br><span class="line">foo(<span class="number">3.14159</span>); <span class="comment">// foo&lt;double&gt;&lt;3.14159&gt;</span></span><br><span class="line">foo(<span class="built_in">std</span>::<span class="built_in">string</span>()); <span class="comment">// foo&lt;std::string&gt;(std::string())</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line">foo(i); <span class="comment">// foo&lt;int&amp;&gt;(i)//引用的引用还是引用</span></span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">std</span>:</span>:remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">( T&amp;&amp; t )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">//返回值</span></span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt; <span class="title">struct</span> <span class="title">remove_reference</span>      &#123;</span><span class="keyword">typedef</span> T type;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt; <span class="title">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&gt;  &#123;</span><span class="keyword">typedef</span> T type;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt; <span class="title">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&amp;&gt; &#123;</span><span class="keyword">typedef</span> T type;&#125;;</span><br><span class="line"><span class="comment">//move本质上 是一个类型转换，本质上是通过static_cast实现的</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<ul>
<li>forward<ul>
<li><strong>解决在使用右值引用参数的函数模板中解决参数的完美转发问题</strong>。只有在它的参数绑定到一个右值上的时候，它才转换它的参数到一个右值</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常使用模式一个函数func1 去 转接 另一个函数func2时，直接去使用func2时问题不大</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(T1&amp;&amp; t1,T2&amp;&amp; t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func2(forward&lt;T1&gt;(t1),forward&lt;T2&gt;(t2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CoreFun</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"CoreFun"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ICoreFun</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"ICoreFun"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	CoreFun(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. A&amp; &amp;变成A&amp;</span></span><br><span class="line"><span class="comment">2. A&amp; &amp;&amp;变成A&amp;</span></span><br><span class="line"><span class="comment">3. A&amp;&amp; &amp;变成A&amp;</span></span><br><span class="line"><span class="comment">4. A&amp;&amp; &amp;&amp;变成A&amp;&amp;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当我ICoreFun(lvalue);的时候ICoreFun的函数原型是ICoreFun(CMyString&amp;)</span></span><br><span class="line"><span class="comment">当我ICoreFun(rvalue);的时候ICoreFun的函数原型是ICoreFun(CMyString&amp;&amp;)的：</span></span><br><span class="line"><span class="comment">虽然ICoreFun(CMyString("hello this is the rvalue")); 转换为了ICoreFun(CMyString&amp;&amp; t)，但是，t是一个左值，所以CoreFun(t);的时候调用的是拷贝构造函数来构造t</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">有没有办法，在上面的情况中，在CMyString&amp;&amp; t 传递给CoreFun(t)的时候，CoreFun(t)把t当作左值来处理呢？也就在t是CMyString&amp;&amp;类型的时候把t转换为右值，在t是CMyString&amp; t类型的时候不转换。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">实现转发左值就调用拷贝构造函数，抓发右值就调用右值类型的拷贝构造函数，完美。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">-------------------------------------</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CoreFun</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"CoreFun"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ICoreFun</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"ICoreFun"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	CoreFun(<span class="built_in">std</span>::forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<ul>
<li><p>std::forward<t>(u)有两个参数：T 与 u。<strong>当T为左值引用类型时，u将被转换为T类型的左值，否则u将被转换为T类型右值</strong>。如此定义std::forward是为了在使用右值引用参数的函数模板中解决参数的完美转发问题。</t></p>
<p><strong>std::move是无条件的转为右值引用，而std::forward是有条件的转为右值引用</strong>，更准确的说叫做Perfect forwarding(完美转发)，而std::forward里面蕴含着的条件则是Reference Collapsing(引用折叠)。</p>
<p>std::move不move任何东西。std::forward也不转发任何东西。在运行时，他们什么都不做。不产生可执行代码，一个比特的代码也不产生。</p>
</li>
</ul>
<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><ul>
<li>六大部件，空间配置器，容器，迭代器，适配器，算法，仿函数</li>
<li>不提供遍历行为的容器（不提供迭代器）<ul>
<li>stack</li>
<li>queue</li>
<li>priority-queue</li>
</ul>
</li>
</ul>
<h2 id="空间配置器"><a href="#空间配置器" class="headerlink" title="空间配置器"></a>空间配置器</h2><ul>
<li>构造和析构<ul>
<li>构造调用placement_new，调用相应类的构造函数</li>
<li>析构根据是否trivial_destructor调用不同版本函数模板</li>
</ul>
</li>
<li>空间配置器<ul>
<li>第一级配置器，<ul>
<li>allocate调用malloc，deallocate调用free</li>
<li>模拟C++的set_new_handler处理内存不足情况（客户端责任）</li>
<li>不断释放、配置，再释放、再配置</li>
</ul>
</li>
<li>二级空间配置器，当所申请的内存小于128字节时，调用<ul>
<li>避免小额区块带来的内存碎片以及额外负担（cookie）</li>
<li>维护16个自由链表，负责16种（8-128）小型区块的次配置能力，内存池以malloc配置而得，如果内存不足，转而调用第一级配置器<ol>
<li>如果需求块大于128byte，调用第一级配置器</li>
<li>如果freelist有可用的区块，直接返回节点，链表依次调整（链表头指向下一个可用的list节点）</li>
<li>如果没有可用区块，调整需求为8的倍数，从内存池中取默认20个区块（节点），可能小于20个<ol>
<li>如果内存池剩余空间满足需求，直接返回</li>
<li>如果内存池只能够一个区块，返回</li>
<li>如果内存池一个区块都没有，调整内存池的剩余空间，并malloc配置heap空间补充内存池，期间自调用，确定是否已经完成内存空间的分配，如果不行，再调用第一级空间配置器，如果可以，直接返回</li>
</ol>
</li>
</ol>
</li>
<li>deallocate释放内存时，如果大于128字节，直接free，否则加入到链表中</li>
</ul>
</li>
<li>刚开始初始化内存池时，内存池中没有数据，同时所有链表均为空</li>
<li>只有用户第一次向内存池申请内存，内存池才会完成内存池以及链表的首次填充，此时其他未使用的链表依然是空的</li>
</ul>
</li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ul>
<li>萃取机BIG FIVE<ul>
<li>reference type</li>
<li>difference_type</li>
<li>value_type</li>
<li>pointer</li>
<li>iterator_category</li>
</ul>
</li>
<li>迭代器种类用struct表示， 输入迭代器，输出迭代器，前向迭代器，双向迭代器，随机迭代器<ul>
<li>random-access<ul>
<li>array/vector/deque</li>
</ul>
</li>
<li>bidirectional<ul>
<li>list/rb-tree</li>
</ul>
</li>
<li>forward<ul>
<li>forwared-list</li>
</ul>
</li>
<li>hashtable<ul>
<li>根据底层链表实现</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="vector实现"><a href="#vector实现" class="headerlink" title="vector实现"></a>vector实现</h2><ul>
<li>维护三个迭代器<ul>
<li>start     begin()</li>
<li>finish    end()</li>
<li>end_of_storage 目前可使用空间的尾</li>
</ul>
</li>
<li>动态增加内存，而是以原大小2倍另外重新配置空间，迭代器失效问题</li>
<li>erase 或者insert 之后的迭代器失效，理论上，每次insert、erase后，所有的迭代器重新计算，所以都看作是失效的，原则是不能使用过期的内存。</li>
</ul>
<h2 id="list实现"><a href="#list实现" class="headerlink" title="list实现"></a>list实现</h2><ul>
<li>环状双向链表，用一个指针Node表示，insert、splice均不会引起迭代器失效，</li>
<li>指针Node刻意置于尾端的一个空白节点</li>
<li>以节点为单位存储数据，节点的地址在内存中不一定连续，每次插入或者删除一个元素，就配置或者释放一个元素空间</li>
<li>list merge 将两个list合并成一个，前提是必须经过递增排序</li>
<li>list sort 排序<ul>
<li>将前两个元素合并，再将后两个合并，然后合并这两个子序列为4个元素的子序列，重复，依次得到8,16，。。子序列，最后得到的就是排序后的序列 时间复杂度O（logN）</li>
</ul>
</li>
</ul>
<h2 id="deque实现"><a href="#deque实现" class="headerlink" title="deque实现"></a>deque实现</h2><ul>
<li>对deque的排序，可以复制到vector上进行排序，后续复制到deque</li>
<li>deque  VS vector<ul>
<li>deque允许常数时间内对头端进行元素的插入和移除操作</li>
<li>deque没有容量观念，它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并连接起来</li>
</ul>
</li>
<li>deque以分段连续的空间组合构成，通过中控器map连接而成，map为一段连续空间，每个元素（节点）为指针，均指向另一段连续性空间（缓冲区，默认512字节）</li>
<li>deque迭代器<ul>
<li>cur指向当前缓冲区，当前所指元素</li>
<li>first当前缓冲区的头</li>
<li>last当前缓冲区的尾</li>
<li>map_pointer node 指向中控器</li>
</ul>
</li>
<li>deque 维护迭代器<ul>
<li>iterator start 第一个缓冲区的第一个元素 begin（）</li>
<li>iterator end 最后一个缓冲区的最后一个元素的下一个位置 end()</li>
<li>map_pointer map指向中控器</li>
<li>size_type map_size map中有几个指针</li>
</ul>
</li>
<li>push_back时，在最后一个节点的缓冲区从左往右push，如果缓冲区剩余个数大于2个，直接填充，否则，填充一个，缓冲区满，再扩充map</li>
<li>push_front时，在第一个节点的缓冲区从右往左push，若有空间则填充，否则扩充map</li>
</ul>
<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><ul>
<li>没有迭代器，最大堆实现（vector表现的完全二叉树）</li>
</ul>
<h2 id="set-map实现"><a href="#set-map实现" class="headerlink" title="set-map实现"></a>set-map实现</h2><ul>
<li><p>底层红黑树</p>
</li>
<li><p>set 迭代器 const iterator，不可以通过迭代器修改元素</p>
</li>
<li><p>set map 同list相同，当客户端对它进行元素insert和erase后，操作之前的所有迭代器在操作完成之后依然有效</p>
</li>
<li><p>自定义类提供compare函数</p>
</li>
<li><p>红黑树执行插入、删除、查找时间复杂度logN</p>
</li>
<li><p>set/map插入删除效率高</p>
<ul>
<li>不需要内存的拷贝和移动</li>
</ul>
</li>
<li><p>set/map每次insert、erase后之前保存的iterator不会失效</p>
<ul>
<li>插入操作只是结点指针换来换去，结点内存不变，而iterator就像指向结点的指针，内存不变，指向内存的指针也不变</li>
</ul>
</li>
</ul>
<h2 id="unordered-set-map实现"><a href="#unordered-set-map实现" class="headerlink" title="unordered-set/map实现"></a>unordered-set/map实现</h2><ul>
<li>底层 hashtable 不具有排序功能</li>
<li>自定义类提供hash函数以及等于函数</li>
<li>unordered-map VS map<ul>
<li>构造函数：unordered-map 提供hash 函数和等于函数，map提供比较函数</li>
<li>存储结构：unordered-map 底层 hashtable，不提供排序功能，map底层 rb-tree,提供排序功能</li>
<li>hash-map 查找速度快，查找速度和数据量大小无关，常数级别，map查找速度 logN</li>
<li>考虑效率，当元素数量到达一定数量级时，用unordered-map</li>
<li>考虑内存，或者元素数量较少用map</li>
<li>选用unordered-map还是map，关键看关键字查询操作次数，以及所要保证的是查询总体时间还是单个查询的时间。如果很多次操作，要求其整体效率，使用hash-map，平均处理时间短。如果少数次操作，使用hash-map导致不确定的O（N）。map用在平均处理时间相对较慢，单次处理事件恒定，整体稳定性高于整体效率，前提是操作次数少。</li>
</ul>
</li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul>
<li><h1 id="C-11-多线程"><a href="#C-11-多线程" class="headerlink" title="C++11 多线程"></a>C++11 多线程</h1></li>
</ul>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><ul>
<li><p>死锁</p>
<ul>
<li>死锁是指多个进程在运行过程中因争夺资源而造成的一种僵局。当进程处于这种僵局时，若无外力作用，都将无法在向前推进</li>
<li>原因<ul>
<li>竞争资源。当系统中多个进程共享的资源数目不足以满足进程的需要时，引起进程对资源的竞争</li>
<li>进程间的推进顺序非法。进程在运行过程中，请求和释放资源的顺序不当，也会造成死锁。</li>
</ul>
</li>
<li>必要条件<ul>
<li>互斥条件。进程要求对所分配的资源进行排他性控制，即在一段时间内某资源仅为一进程所有。</li>
<li>请求和保持条件。当进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不可剥夺条件。进程已获得的资源在未使用完之前，不能剥夺，只能在使用完毕时自己释放。</li>
<li>环路等待条件。在发生死锁时，必然存在一个进程–资源的环形链。</li>
</ul>
</li>
<li>解决方法<ul>
<li>避免死锁<ul>
<li>加锁顺序</li>
<li>加锁时限</li>
<li>死锁检测</li>
</ul>
</li>
<li>预防死锁<ul>
<li>资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）</li>
<li>只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏保持条件）</li>
<li>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</li>
<li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>进程间通信方式</p>
<ul>
<li>管道，半双工的通信方式，数据只能单向流动，而且只能在具有父子进程间使用。</li>
<li>有名管道，半双工的通信方式，但是它允许无亲缘关系进程间的通信 </li>
<li>信号量，一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，<br>防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同<br>一进程内不同线程之间的同步手段 </li>
<li>消息队列 ，由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号<br>传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 </li>
<li>信号 ，通知接收进程某个事件已经发生。 </li>
<li>共享内存 ，映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多<br>个进程都可以访问 ，共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率<br>低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和<br>通信。 </li>
<li>套接字，可用于不同设备及其间的进程通信。</li>
</ul>
</li>
<li><p>线程间通讯方式</p>
<ul>
<li>锁机制：包括互斥锁、条件变量、读写锁 ，<ul>
<li>互斥锁提供了以排他方式防止数据结构被并发修改的方法。 读写锁允许多个线程同时读共<br>享数据，而对写操作是互斥的。 条件变量可以以原子的方式阻塞进程，直到某个特定条件<br>为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。 </li>
</ul>
</li>
<li>信号量机制(Semaphore)：<ul>
<li>包括无名线程信号量和命名线程信号量 </li>
</ul>
</li>
<li>信号机制(Signal)：类似进程间的信号处理<ul>
<li>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通<br>信机制。 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="linux-IO模型"><a href="#linux-IO模型" class="headerlink" title="linux IO模型"></a>linux IO模型</h2><ul>
<li>阻塞IO，调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去查询这个函数是否返回，必须等待这个函数返回后才能执行下一步动作</li>
<li>非阻塞IO，非阻塞等待，每隔一段时间就去检查IO时间是否就绪，没有就绪就可以做其他事</li>
<li>信号驱动IO，linux使用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号，然后处理IO事件</li>
<li>IO复用，linux用slelect epoll实现IO复用，也会使进程阻塞，但是和阻塞IO不同的是，IO复用可以同时阻塞多个IO操作，而且可以同时对多个读/写操作的IO函数进行检测。直到有数据可读、可写时，才调用IO操作函数</li>
<li>异步IO：linux调用aio-read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移以及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序</li>
</ul>
<h2 id="select-epoll"><a href="#select-epoll" class="headerlink" title="select epoll"></a>select epoll</h2><ul>
<li>select 支持的fd数量有限，单个进程能够监视的文件描述符的数量存在限制，通常1024</li>
<li>每次调用select，都会把fd从用户态拷贝到内核态</li>
<li>使用轮询方式，需遍历所有fd</li>
<li>本身没有最大并发连接的限制，仅受系统进程能够打开的最多文件数目限制</li>
<li>省去不必要的内存拷贝，epoll通过内核与用户空间map同一块内存实现</li>
<li>效率提升，返回的是fd发生变化的fd</li>
</ul>
<h2 id="进程VS-线程VS-协程"><a href="#进程VS-线程VS-协程" class="headerlink" title="进程VS 线程VS 协程"></a>进程VS 线程VS 协程</h2><ul>
<li><p>一个线程属于一个进程，一个进程有多个线程，至少有一个线程，线程依赖于进程存在</p>
</li>
<li><p>进程在执行过程中有独立的内存单元，而多个线程共享进程的内存</p>
</li>
<li><p>进程为资源分配的最小单位，线程为CPU调度的最小单位</p>
</li>
<li><p>进程创建、撤销进程时，系统都要为之分配或者回收资源，如内存空间、IO设备等。大于创建、撤销线程的开销。进程切换时，涉及到整个当前进程的CPU环境的保存和新进程的CPU环境的设置，大于线程切换</p>
<ul>
<li>进程切换，需要切换系统指令以及地址空间，而线程共享地址空间，不需要切换地址空间，只切换指令</li>
</ul>
</li>
<li><p>进程间通信IPC，线程间共享地址空间，线程间同步和通信实现简单</p>
</li>
<li><p>进程调试简单可靠性高，线程调试复杂</p>
</li>
<li><p>进程间不会相互影响，线程一个线程挂掉使得整个进程挂掉</p>
</li>
<li><p>进程适合多核、多机分布，线程适用于多核</p>
<p>网络服务器中，多进程VS多线程</p>
<ul>
<li><table>
<thead>
<tr>
<th align="center">对比维度</th>
<th>多进程</th>
<th>多线程</th>
<th>总结</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数据共享、同步</td>
<td>数据共享复杂，需要IPC；数据分开，同步简单</td>
<td>共享进程数据，共享简单，同步复杂</td>
<td>各有优势</td>
</tr>
<tr>
<td align="center">内存、CPU</td>
<td>占用内存多，切换复杂，CPU利用率低</td>
<td>占用内存少，切换简单，CPU利用率高</td>
<td>线程win</td>
</tr>
<tr>
<td align="center">创建销毁、切换</td>
<td>创建销毁、切换复杂，速度慢</td>
<td>创建销毁、切换简单，速度快</td>
<td>线程win</td>
</tr>
<tr>
<td align="center">编程、调试</td>
<td>编程简单，调试简单</td>
<td>编程复杂，调试复杂</td>
<td>进程win</td>
</tr>
<tr>
<td align="center">可靠性</td>
<td>进程间不会相互影响</td>
<td>一个线程挂掉导致整个线程挂掉</td>
<td>进程win</td>
</tr>
<tr>
<td align="center">分布式</td>
<td>适应于多核、多机分布式；扩展多个机器简单</td>
<td>适应于多核分布式</td>
<td>进程win</td>
</tr>
</tbody></table>
<ul>
<li>优先进程<ul>
<li>弱相关</li>
<li>多机分布</li>
</ul>
</li>
<li>优先线程<ul>
<li>频繁创建销毁</li>
<li>大量计算</li>
<li>强相关</li>
<li>多核分布</li>
</ul>
</li>
<li>最拿手的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><ul>
<li>TCP/IP协议体系</li>
<li>链路层<ul>
<li>以太网帧的格式</li>
<li>MTU</li>
<li>ARP/RARP</li>
</ul>
</li>
<li>网络层<ul>
<li>IP首部格式</li>
<li>IP分片</li>
<li>IP选路</li>
<li>ICMP协议<ul>
<li>报文格式</li>
<li>分类 查询+差错</li>
<li>两种+五种</li>
<li>传输层</li>
</ul>
</li>
</ul>
</li>
<li>传输层<ul>
<li>UDP<ul>
<li>特点</li>
<li>首部字段</li>
</ul>
</li>
<li>TCP<ul>
<li>特点</li>
<li>首部字段</li>
<li>可靠机制</li>
<li>连接控制</li>
<li>流量控制机制</li>
<li>超时重传</li>
</ul>
</li>
</ul>
</li>
<li>应用层<ul>
<li>DNS<ul>
<li>命名空间</li>
<li>指针查询（反向查找或逆向解析）基本原理</li>
<li>DNS缓存</li>
</ul>
</li>
<li>FTP协议——————<ul>
<li>两条连接。控制流、数据流</li>
<li>两种工作模式PASV PORT</li>
<li>各种指令和相应码</li>
<li>断点续传和匿名FTP概念</li>
</ul>
</li>
<li>HTTP协议<ul>
<li>报文格式：请求报文，响应报文，请求各种字段，响应头各种字段</li>
<li>HTTP状态码</li>
</ul>
</li>
<li>HTTPS协议<ul>
<li>握手具体过程</li>
<li>摘要算法，数字签名，数字证书的原理和过程</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="TCP-IP协议体系"><a href="#TCP-IP协议体系" class="headerlink" title="TCP/IP协议体系"></a>TCP/IP协议体系</h2><ul>
<li>OSI 有哪几层，会画出来，知道主要几层的各自作用 <ul>
<li>应用层（数据）：确定进程之间通信的性质以满足用户需要以及提供网络与用户应用</li>
</ul>
<ol start="2">
<li>表示层（数据）：主要解决拥护信息的语法表示问题，如加密解密</li>
<li>会话层（数据）：提供包括访问验证和会话管理在内的建立和维护应用之间通信的机<br>制，如服务器验证用户登录便是由会话层完成的</li>
<li>传输层（段）：实现网络不同主机上用户进程之间的数据通信，可靠<br>与不可靠的传输，传输层的错误检测，流量控制等</li>
<li>网络层（包）：提供逻辑地址（IP）、选路，数据从源端到目的端的<br>传输</li>
<li>数据链路层（帧）：将上层数据封装成帧，用 MAC 地址访问媒介，错误检测与修正</li>
<li>物理层（比特流）：设备之间比特流的传输，物理接口，电气特性等 </li>
</ol>
</li>
<li>知道各个层使用的是哪个数据交换设备。（交换机、路由器、网关） <ul>
<li><strong>网关：应用层、传输层（网关在传输层上以实现网络互连，是最复杂的网络互连设</strong><br><strong>备，仅用于两个高层协议不同的网络互连。网关的结构也和路由器类似，不同的是</strong><br><strong>互连层。网关既可以用于广域网互连，也可以用于局域网互连）</strong></li>
</ul>
<ol start="2">
<li><strong>路由器：网络层（路由选择、存储转发）</strong></li>
<li><strong>交换机：数据链路层、网络层（识别数据包中的 MAC 地址信息，根据 MAC 地址进</strong></li>
</ol>
<strong>行转发，并将这些 MAC 地址与对应的端口记录在自己内部的一个地址表中）</strong><ol start="4">
<li>网桥：数据链路层（将两个 LAN 连起来，根据 MAC 地址来转发帧）</li>
<li>集线器（Hub）：物理层（纯硬件设备，主要用来连接计算机等网络终端）</li>
<li>中继器：物理层（在比特级别对网络信号进行再生和重定时，从而使得它们能够在<br>网络上传输更长的距离） </li>
</ol>
</li>
</ul>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><ul>
<li>ARP  <ul>
<li>IP地址到对应的硬件地址之间提供动态映射。动态—自动完成</li>
<li>RARP被那些没有磁盘驱动器的系统使用，需要系统管理员进行手动设置</li>
<li>点对点网络无需地址解析协议</li>
<li>ARP高效运行的关键是，<strong>每个主机都有一个ARP高速缓存/存放了最近Internet地址到硬件地址之间的映射记录</strong>。高速缓存每一项的生存时间一般为20分钟，起始时间从被创建时开始。</li>
<li>ARP报文<ul>
<li><img src="cpp-review/c9Rd4j0YFFdr.png" alt="mark"></li>
<li>帧类型0800 IP 0806 ARP 0835 RARP</li>
<li>硬件类型 以太网 =1</li>
<li><strong>协议类型 IPv4 0x0800</strong></li>
<li>硬件长度 <strong>以太网地址长度6 字节</strong></li>
<li>协议长<strong>度 IPv4=4字节</strong></li>
<li>操作码 1 request 2 reply 3 RARP请求 4 RARP 应答</li>
</ul>
</li>
</ul>
</li>
<li>ARP 协议有什么弱点？ <ul>
<li>1）缓存：主机的地址映射是基于高速缓存的，动态更新的。地址刷新是有时间限制的。 可<br>以通过下次更新之前修改计算机上的地址缓存，造成拒绝服务攻击或者 ARP 欺骗。<br>2）广播: 攻击者可以伪装 ARP 应答。<br>3） ARP 应答没有认证，都是合法的。可以在不接受到请求的时候就发出应答包。 </li>
</ul>
</li>
<li>ARP 代理的概念和应用场景 <ul>
<li>若 ARP 请求是从一个网络的主机发送给另一个网络上的主机，那么连接这两个网络的路由<br>器就可以回答该请求，这个过程叫做 ARP 代理。 ARP 代理路由器响应 ARP 请求的 MAC 地<br>址为路由器的 MAC 地址而非 ARP 请求的主机的 MAC 地址。 </li>
<li>ARP 代理的应用环境：<br>两个物理网络之间的路由是使用相同的网络号，两个路由器设置成 ARP 代理，实现相互隐<br>瞒物理网络</li>
</ul>
</li>
<li>免费 ARP <ul>
<li>主机发送 ARP 查找自己的 IP 地址，即数据链路层 SIP=DIP </li>
<li>作用有两个：<br>1）一个主机使用免费 ARP 确定是有存在有其他主机设置了相同的 IP 地址–检测IP冲突<br>2）如果发送免费 ARP 的主机改变了 MAC 地址，可以通过发送免费 ARP 的方式告知其他<br>主机端更新 ARP 表 –更新ARP表,网络设备冷备</li>
</ul>
</li>
<li>数据链路层 MTU 的最大值和最小值是多少 <ul>
<li>数据链路层的最小 MTU 为 64 字节。 </li>
<li>数据链路层的最大 MTU 为 1500 字节，即数据字段的最大长 </li>
</ul>
</li>
</ul>
<h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><ul>
<li><p>IP提供不可靠的无连接的数据报传送服务</p>
<ul>
<li>不可靠（unreliable）指的是不能保证IP数据报能成功到达目的地。如果发生某种错误。IP有一个简单的错误处理算法，丢弃该数据报，然后发送ICMP消息给信源端。任何要求的可靠性必须由上层来提供（tcp/ip）</li>
<li>无连接（connectionless）IP并不维护任何关于后续数据报的状态信息。IP 数据可以不按顺序发送和接收。 A 发送连续的数据报，到达 B 不一定是连续的，来回路由选择可能不一样，路线也不一样，到达先后顺序也不一样。 TCP对数据包排序，顺序不对时，缓存。</li>
</ul>
</li>
<li><p>IP报文格式</p>
<ul>
<li><img src="cpp-review/lp02PfVJt4c9.png" alt="mark"></li>
<li>版本号：4-IPV4,6-IPV6</li>
<li>首部长度：单位为4字节，即一行。最小为5（20字节，无可选项），最大为15（60字节）</li>
<li>Tos，忽略</li>
<li>总长度，IP首部+数据部分，最大2^16=65536字节</li>
<li>标识字段，16bit，四字节，用于分片重组</li>
<li>标志，3bit，表示是否可分片，分片的情况下，是否是最后一片</li>
<li>片位移：13bit，标识被分片的每一个片段相对于原始数据的位置，单位为8字节，是2^13=8192*8=65536，最多表示原始数据的65536字节的位置</li>
<li>TTL生存时间：可以中转多少个路由器，每经过一个路由就减1，防止环形路由</li>
<li>协议：8bit，表示IP首部的下一个是什么协议</li>
<li>首部检验和：只校验IP首部，不校验数据部分</li>
<li>可选项：最多40字节，</li>
<li>填充pad，确保首部长度为32bit的整数倍</li>
</ul>
</li>
<li><p>为什么IP首部需要总长度字段</p>
<ul>
<li>因为一些数据链路（以太网）需要填充一些数据以达到最小长度。因为以太网帧的最小长度<br>是 46 个字节，但是 IP 长度可能更短，所以需要总长度来确定 IP 数据部分的内容。 </li>
</ul>
</li>
<li><p>IP 首部校验和怎么计算的，与 ICMP， IGMP， TCP， UDP 的首部校验和有什么区<br>别与共同点？ </p>
<ul>
<li>（1） 先把校验和字段置 0。<br>（2） 对首部中每个 16 位比特进行二进制求和，多余4个字节的，把大于4字节的同剩下的四个字节继续相加。<br>（3） 结果取反 保存在检验和字段中。<br>（4） 收到一份 IP 数据包后，同样对首部中每个 16bit 二进制求和，同样大于四个字节的同剩下四个字节相加，并取反<br>（5） 最后结果全为 1，表示正确，否则表示错误。<br>（6） 如果是错误的， IP 就丢弃该数据报，但是不生成差错报文，由上层去处理。 </li>
<li>共同点：用到的算法都是一样的。<br>区别： IP 计算的时候没有将数据包括在内。<br>ICMP， IGMP， TCP， UDP 同时覆盖首部和数据检验码。 </li>
</ul>
</li>
<li><p>IP路由</p>
<ul>
<li>IP路由选择的过程<ul>
<li>根据最长匹配原则，找到条目，发送到指定的路由器。如果不能找到，返回一个“主机不可<br>达”或“网络不可达”的错误。 </li>
</ul>
</li>
<li>IP路由选择的特点<ul>
<li>IP 路由选择是逐跳进行的。 IP 并不知道到达任何目的的完整路径，只提供下一跳地址。 </li>
<li>为一个网络指定一个路由器，而不是为每个主机指定一个路由器 ，这样可以缩小路由表规模。 </li>
</ul>
</li>
<li>IP搜索路由表的步骤<ul>
<li>搜索匹配的主机地址（网络号和主机号都要匹配） —-》搜索匹配的网络地址 —-》搜索默认选项 </li>
</ul>
</li>
<li>如果路由表中没有默认项，而又没有找到匹配项，这时如何处理？ <ul>
<li>数据报是由本机产生的，那么就给发送该数据报的应用程序返回一个差错，或者是“主<br>机不可达差错”或者是“网络不可达差错”。 </li>
<li>如果是被转发的数据报，就给原始发送端发送一份 ICMP 主机不可达的差错报文。 </li>
</ul>
</li>
</ul>
</li>
<li><p>IP地址分类</p>
<ul>
<li><ol>
<li><p>A 类地址：首位为 0， 1.0.0.1~~126.255.255.254；主机号 24 位</p>
</li>
<li><p>B 类地址：首位为 10， 128.0.0.1~~191.255.255.254；主机号 16 位</p>
</li>
<li><p>C 类地址：首位为 110， 192.0.0.1~~223.255.255.254；主机号 8 位</p>
</li>
<li><p>D 类地址（多播地址，也叫做组播地址）：首位为 1110， 224.0.0.1~~239.255.255.254</p>
</li>
<li><p>E 类地址：此类地址是保留地址，首位为 11110， 240.0.0.1~~254.255.255.254 </p>
</li>
</ol>
</li>
<li><p>网络地址就是：把IP地址转成二进制和子网掩码进行与运算</p>
</li>
<li><p>主机的数量=2^二进制位数的主机-2</p>
</li>
<li><p>广播地址：网络地址的主机位全部变成1 </p>
</li>
<li><p>网络地址+1即为第一个主机地址，广播地址-1即为最后一个主机地址</p>
</li>
</ul>
</li>
<li><p>ICMP</p>
<ul>
<li>ICMP报<strong>文前四个字节都相同</strong>，IP 首部20字节。</li>
<li><img src="cpp-review/IAyD5lcoVH3k.png" alt="mark"></li>
<li>ICMP 协议在 IP头部中 协议为1  <strong>ICMP</strong>:1  |  <strong>TCP</strong>:6  |  <strong>UDP</strong>:17  |  GRE:47  |  ESP:50  |  AH:51</li>
<li>echo request 类型为8 代码为0</li>
<li>echo reply 类型为0 代码为0</li>
<li>校验和：<ul>
<li>以太网管自己的，IP校验和–IP头部，TCP /ICMP 管自己头部和后面所有的</li>
</ul>
</li>
<li>ICMP报文分类<ul>
<li>一类是 ICMP 查询报文，另一类是 ICMP 差错报文。 </li>
<li><img src="cpp-review/1567476237158.png" alt="1567476237158"></li>
<li>ICMP 的主机不可达报文是在什么情况下发出的？ <ul>
<li>三层设备（路由器）给该主机寻路时，没有找到相应路径，向源 IP 发回 ICMP 主机不可达 </li>
</ul>
</li>
</ul>
</li>
<li>什么情况不会导致产生 ICMP 差错报文？为了防止过去允许ICMP差错报文对广播分组响应所带来的广播风暴<ul>
<li><strong>ICMP差错报文，但是ICMP查询报文可能会产生差错报文</strong></li>
<li>目的地址是广播地址或多播地址的IP数据报</li>
<li>作为链路层广播的数据报</li>
<li>不是IP分片的第一片，因为只有第一片才有四层端口号的信息。</li>
<li>源地址不是单个主机的数据报。即源地址不能为零地址、环回地址、广播地址、多播地址</li>
</ul>
</li>
<li>ping<ul>
<li>第一个是看看是不是超时</li>
<li>第二个看看是不是延迟太高<ul>
<li>A 电脑（ <code>192.168.2.135</code>）发起 <code>ping</code>请求， <code>ping192.168.2.179</code></li>
<li>A 电脑广播发起 <code>ARP</code>请求，查询 <code>192.168.2.179</code>的 MAC地址。</li>
<li>B 电脑应答 <code>ARP</code>请求，向 A电脑发起单向应答，告诉 A电脑自己的 MAC地址为 <code>90:A4:DE:C2:DF:FE</code></li>
<li>知道了 MAC地址后，开始进行真正的 ping请求，由于 B电脑可以根据A电脑发送的请求知道 <strong>源 MAC地址</strong>，所以就可以根据源 MAC地址进行响应了。</li>
<li>发送ICMP ECHO request （ 类型为8 代码为0）报文，响应ICMP reply（类型为0 代码为0）报文</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><ul>
<li><img src="cpp-review/1567391865764.png" alt="1567391865764"></li>
<li>UDP 长度：是 UDP 的报文总长度，是多于8的。 IP 总长度减去首部长度就是此值 </li>
<li>UDP 校验和：注意点：校验和是可选的。 （TCP 是必选的）校验和覆盖 UDP 首部和数据<br>（TCP 也一样覆盖首部和数据，但是 IP 只覆盖首部）</li>
<li>UDP校验和如何计算<ul>
<li>UDP 的校验和要计算首部和数据部分。首部还包括伪首部 </li>
<li><img src="cpp-review/1567391955508.png" alt="1567391955508"></li>
<li>多了 12 个字节的伪首部。 </li>
<li>为什么加伪头部<ul>
<li><strong>目的是让 UDP 两次检查数据是否已经正确到达目的地</strong>。IP 接受正确的目的地址，传送到正确的上层程序。所有伪首部包括：源 IP 地址，目的 IP 地址， 0，协议号， UDP 长度。 </li>
</ul>
</li>
</ul>
</li>
<li>TCP、 UDP 为什么存在伪包头？ <ul>
<li>UDP(TCP)检验和：是根据 UDP(TCP)数据报和伪报头计算得到的差错检测值。 </li>
<li>伪报头包含源和目的 IP 地址，以及来自 IP 数据报报头的协议值。 IP 数据报在网络中传送时<br>包含 UDP（TCP） 数据报。 </li>
<li>伪报头并不会在网络中传送，校验和中所包含的伪报头内容可以避免目的端错误地接收错误<br>路由的数据报。校验和值的计算方法和 IP 报头检验和的计算方法类似 </li>
</ul>
</li>
</ul>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><ul>
<li><p><img src="cpp-review/8AMLnhHgXyzf.png" alt="mark"></p>
</li>
<li><p>TCP VS UDP</p>
<ul>
<li>UDP 没有复杂控制，提供面向无连接通信服务的一种协议，将部分控制转移给应用程序</li>
<li>TCP 对传输、发送、通信进行控制的协议，仅在确认对端存在时才发送数据，控制通信流量，提供可靠的传输机制</li>
</ul>
</li>
<li><p>TCP面向连接，UDP面向无连接</p>
<ul>
<li>TCP面向报文，UDP面向字节流</li>
<li>TCP提供可靠传输服务，UDP传输不可靠</li>
<li>TCP协议速度慢，UDP快</li>
<li>TCP协议对资源要求多（头部开销大），UDP协议要求少</li>
</ul>
</li>
<li><p>TCP的可靠性</p>
<ul>
<li>应用数据被分割为TCP最为合适发送的大小</li>
<li>TCP发送一个字段后，启动一个定时器，等待目的端收到报文段，如果不能及时收到ACK,将重新发送</li>
<li>TCP收到数据，发送延迟的ack（200ms），delayed_ack</li>
<li>TCP保持首部和数据的校验和</li>
<li>TCP会对收到的数据进行重新排序</li>
<li>TCP提供对流的控制。TCP连接的每一方都有固定大小的缓冲空间。<strong>TCP的接收端只允许另一端发送  接收端缓冲区所能容纳的数据。</strong>这将防止较快主机致使较慢主机的缓冲区溢出</li>
</ul>
</li>
<li><p>序号</p>
<ul>
<li>序号标识从TCP发送端到接收端的字节流，标识这个报文段中第一个数据字节的序号，不会从0开始，在建立连接时（发送SYN时），由计算机生成的随机数作为初始值。序号无符号32bit，达到2^32后，变为0重新开始</li>
<li>确认序号是上次已成功收到数据字节序号加1（SYN占用一个序号）。只有ACK标志位1时确认序号字段才有效。</li>
</ul>
</li>
<li><p>窗口大小，16bit，用于通知从相同的TCP首部应答好所指位置开始能接受的数据大小，TCP不能发送超过次值大小的数据段，窗口为0表示可以发送窗口探测，以了解最新窗口大小。但这个数据必须为1个字节。</p>
<ul>
<li>接收端能够接收的字节数，（即允许当前发送端发送的字节数）</li>
</ul>
</li>
<li><p>MSS，每个连接方通常在通信的第一个报文段（SYN段），设置本端所能接受的报文段的最大长度</p>
</li>
<li><p>连接</p>
<ul>
<li>三次握手<ul>
<li>客户端发送SYN，     序列号 A，ACK号=0   进入SYN_SENT状态</li>
<li>服务器发送SYN+ACK, 序列号B    ACK号   A+1 进入 SYN_RCVD</li>
<li>客户端发送ACK，序列号 A+1     ACK号B+1   进入ESTABLISHED</li>
<li>服务器收到ACK后，进入 ESTABLISHED</li>
</ul>
</li>
</ul>
</li>
<li><p>断开</p>
<ul>
<li>四次挥手<ul>
<li>客户端发送FIN    序列号A    ACK 号          进入FIN_WAIT_1</li>
<li>服务器发送ACK  序列号 B,   ACK号 A+1 进入CLOSE_WAIT </li>
<li>接收端收到ACK后，进入FIN_WAIT_2，继续接受来自服务器的数据</li>
<li>服务器发送FIN   进入LAST_ACK</li>
<li>客户端发送ACK  进入TIME_WAIT，等待2MSL后进入CLOSED状态</li>
<li>服务器收到ACK后，进入CLOSED</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么三次？为什么四次</p>
<ul>
<li>3 次握手：防止已过期的连接请求报文突然又传送到服务器，因而产生错误 <ul>
<li>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤</li>
<li>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认</li>
</ul>
</li>
<li>4 次挥手：确保数据能够完成传输，但关闭连接时，当收到对方的 FIN 报文通知时，它<br>仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以<br>未必会马上会关闭 SOCKET,也即你可能还需要发送一些数据给对方之后，再发送 FIN 报文<br>给对方来表示你同意现在可以关闭连接了，所以它这里的 ACK 报文和 FIN 报文多数情况下<br>都是分开发送的 </li>
</ul>
</li>
<li><p>状态变迁图</p>
<ul>
<li><p><img src="cpp-review/20180208112533496" alt="https://img-blog.csdn.net/20180208112533496"></p>
</li>
<li><p><img src="cpp-review/Ou1Q34TIaU52.png" alt="mark"></p>
</li>
<li><p>2MSL </p>
<ul>
<li><p>TIME_WAIT状态又称2MSL状态。每个具体TCP实现选择一个报文段最大生存时间MSL，它是任何报文段被丢弃前在网络内的最长时间</p>
</li>
<li><p>原因</p>
<ul>
<li>如果服务器在发送FIN后，没有收到ACK，超过超时重传时间后，服务器重新发送FIN，客户端再F发送ACK。如果没有TIME_WAIT状态，服务器可能一直收不到ACK，一直保持该会话</li>
<li><strong>可靠的实现TCP全双工连接的终止</strong></li>
<li><strong>允许老的重复芬姐在网络中消失</strong></li>
</ul>
</li>
<li><p>效果</p>
<ul>
<li>等待2MSL期间，这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能在被使用。这个连接只能在2MSL结束后才能被使用</li>
<li>连接处于2MSL等待时，任何迟到的报文段将被丢弃。因为处于2MSL等待的、由该插口对定义的连接在这段时间不能被再用</li>
<li>客户执行主动关闭并进入TIME_WAIT状态是正常的。服务器通常执行被动关闭，不会进入TIME_WAIT状态。这暗示如果终止一个客户程序并重新启动这个客户程序，则这个新客户程序将不能重用相同的本地端口。</li>
<li>对于服务器，使用熟知端口。如果我们终止一个已经建立连接的服务器程序，并试图立即重新启动这个服务器程序，服务器程序将不能把它的这个熟知端口赋值给它的端点，因为那个端口处于2MSL连接的一部分。</li>
</ul>
</li>
<li><p>解决</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> option=TRUE;</span><br><span class="line"><span class="keyword">int</span> optlen=<span class="keyword">sizeof</span>(option)</span><br><span class="line">setsocketopt(serv_sock，SOL_SOCKET,SO_REUSEADDR,(<span class="keyword">void</span>*)&amp;option,optlen)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>FIN_WAIT_2</p>
<ul>
<li>长时间停在FIN_WAIT_2状态，对端停留在CLOSE_WAIT状态</li>
<li>一般防火墙都有解决半关闭（FIN_WAIT_2）的超时时间设置，如果超时，防火墙会向双方发送RSET(伪装源)来踢掉连接。</li>
</ul>
</li>
</ul>
</li>
<li><p>TCP交互式数据流</p>
<ul>
<li>延迟的ACK<ul>
<li>通常TCP在接收到数据后并不立即发送ACK，相反，它推迟发送，以便将ACK与需要沿该方向发送的数据一起发送（<strong>数据捎带ACK</strong>），绝大多数实现采用的时延为200ms，即，TCP将以最大200ms的时延等待是否有数据一起发送</li>
</ul>
</li>
<li>Nagle算法<ul>
<li>要求<strong>一个TCP连接上最多只有一个未被确认的未完成的小分组，在该分组的确认到达前不能发送其他的小分组</strong>，这时可以缓冲接下来要发送的数据包，<strong>TCP收集这些少量的分组，并在确认到来时以一个分组的方式发出去</strong>。该算法的<strong>优越性在于它是自适应的</strong>：确认到达的越快，数据也就发送的越快。而在希望减少微小分组数目的低速广域网上，则会发送更少的分组</li>
<li>关闭Nagle算法，实时预览的通讯程序而言，e.g.小消息必须无时延的发送<ul>
<li>将套接字描述符设置TCP_NODELAY选项可以禁止nagle算法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>TCP成块的数据流</p>
<ul>
<li>正常数据流<ul>
<li>确认机制<ul>
<li>通常使用的“<strong>隔一个报文段确认”</strong>策略，A发送一个报文给B，A再发送一个报文给B，B发送ACK确认收到的两个报文给A</li>
<li><strong>delay_ed ACK, 如果tcp对每个数据包都发送一个ack确认，那么只是一个单独的数据包为了发送一个ack代价比较高，所以tcp会延迟一段时间，如果这段时间内有数据发送到对端，则捎带发送ack，如果在延迟ack定时器触发(200ms)时候，发现ack尚未发送，则立即单独发送</strong></li>
</ul>
</li>
</ul>
</li>
<li>滑动窗口<ul>
<li>接受方的流控，发送方快，接收方慢，协调双方工作节奏</li>
<li>MSS 最大消息长度，在建立连接时确定，为IP中不会被分片的最大数据长度（1500-20-20=1460）</li>
<li>滑动窗口本质上是描述接受方的TCP数据报缓冲区大小的数据，发送方根据这个数据来计算自己最多能发送多长的数据。</li>
<li>窗口左边右移<ul>
<li>发生在数据被发送（发送端）和确认时（接收端）</li>
<li>发送端的slide window 左侧是自己发出，并被对方确认的字节序列号，右侧是左侧+ B通告window size。</li>
</ul>
</li>
<li>窗口右边右移<ul>
<li>收到已经确认的数据并释放了TCP接收缓存时</li>
</ul>
</li>
<li>发送端状态<ul>
<li>已发送已收到ACK，已发送未收到ACK,准备发送，未发送</li>
</ul>
</li>
<li>接收端状态<ul>
<li>已收到ACK，已收到未发送ACK，未收到</li>
</ul>
</li>
<li>发送方根据接收方的窗口连续发送数据窗口大小的数据不受ACK，收到ACK后窗口左边右移</li>
<li>接收方则确认ACK 连续的数据分组，对于乱序的分组则先接收下来，避免网络重复传递，丢失的触发超时重传</li>
</ul>
</li>
<li>慢启动<ul>
<li><strong>拥塞窗口是由发送方使用的流量控制，而通告窗口则是接收方使用的流量控制</strong></li>
<li>TCP采用慢启动算法来<strong>降低一开始就发送过多的数据到网络</strong>,采用slow start 算法来快速摸到传输路径带宽的峰值。（一开始发送大量数据，在发送方和接收方之间存在多个路由器和速率较慢的链路时，就有可能出现一些问题。一些中间路由器必须缓存分组，并有可能耗尽存储器的空间，然后发生丢包）</li>
<li>发送方有一个拥塞窗口（cwnd），拥塞窗口被初始化为1个报文段，每收到一个ACK，拥塞窗口就增加一个报文段（<strong>cwnd以字节为单位，但是慢启动以报文段为单位进行增加</strong>），收到一个ACK，1-&gt;2，收到两个ACK,2-&gt;4，指数增加</li>
<li>发送方取拥塞窗口与通告窗口中的最小值作为发送上限。</li>
<li>不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。这里用报文段的个数的拥塞窗口大小举例说明慢开始算法，实时拥塞窗口大小是以字节为单位的。 </li>
<li>为了防止 cwnd 增长过大引起网络拥塞，设置一个慢开始门限（ssthresh 状态变量） <ul>
<li>当 cnwd＜ssthresh，使用慢开始算法</li>
<li>当 cnwd=ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法</li>
<li>当 cnwd＞ssthresh，使用拥塞避免算法 <ul>
<li>拥塞避免并非完全能够避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性规律增<br>长，使网络比较不容易出现拥塞。 </li>
<li>思路：让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞控<br>制窗口加一。 </li>
<li>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有<br>收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做<br>拥塞来处理），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口<br>设置为 1，执行慢开始算法。 </li>
<li><img src="cpp-review/1567386917332.png" alt="1567386917332"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>TCP的超时和重传</p>
<ul>
<li><p>对每个连接，TCP管理4个不同的定时器</p>
<ul>
<li>重传定时器用于当发送一个数据报文时，在规定时间内，发送方需要收到另一端发出的接收报文确认。</li>
<li>坚持persist定时器使窗口大小信息保持不断流动，即使另一端关闭了其接收窗口 chapter23</li>
<li>保活keepalive定时器用于检测一个空闲连接的另一端是否依然保持连接。chapter23</li>
<li>2MSL定时器测量一个连接处于TIME_WAIT状态的时间。chapter18.6</li>
</ul>
</li>
<li><p>快重传算法</p>
<ul>
<li>要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及<br>早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发<br>送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设<br>置的重传计时器时间到期。 </li>
<li>由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网<br>络的吞吐量 </li>
<li>快速重传后执行的不是慢启动，而是拥塞避免算法</li>
</ul>
</li>
<li><p>快速恢复算法</p>
<ul>
<li>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把 ssthresh 门限减半。<br>但是接下去并不执行慢开始算法 </li>
<li>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络<br>可能没有出现拥塞。所以此时不执行慢开始算法，而是将 cwnd 设置为 ssthresh 的大小，<br>然后执行拥塞避免算法。 </li>
<li><img src="cpp-review/1567388045381.png" alt="1567388045381"></li>
</ul>
</li>
</ul>
</li>
<li><p>TCP坚持定时器</p>
<ul>
<li>解决问题：接收端的缓存满的时候，接收端回向发送端回复一个窗口为0的ＡＣＫ，当是ａｃｋ的输出是不可靠的，如果ａｃｋ丢失了，那么，发送端永远不会向接收端发送数据，因为他认为接收端的缓存是满的，而接收端却在等待发送端发送数据，这就产生了死锁。</li>
<li>解决方案： 使用坚持定时器。当发送端接收到接收端窗口为０的回复，那么发送端启动坚持定时器，然后定期向接收端发送一个字节的报文段的，直到接收端回复缓存可用为止。（TCP总是允许在关闭连接前发送一个字节的数据）</li>
<li>糊涂窗口综合征<ul>
<li>可发生在两端中的任何一端：**接收方可以通告一个小的窗口（而不是一直等到有大的窗口时才通告），而发送方也可以发送少量的数据（而不是等待其他的数据以便发送一个大的报文段）</li>
<li>解决方案<ul>
<li>接收方不通告小窗口</li>
<li>发送方避免出现糊涂窗口综合症的措施是仅在满足下列条件时才发送数据<ul>
<li>可以发送一个满长度的报文</li>
<li>可以发送至少是接收方通告最大窗口大小一半的报文</li>
<li>没有还未被确认的数据时或者TCP连接上禁止使用Nagle算法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>TCP保活定时器</p>
<ul>
<li>许多时候一个服务器希望知道客户主机是否关机或者崩溃又重新启动。许多实现提供的保活定时器可以提供这种能力</li>
</ul>
</li>
</ul>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><ul>
<li>域名解析， <a href="http://www.xxx.com" target="_blank" rel="noopener">www.xxx.com</a> 转换成 ip </li>
<li>DNS 协议运行在 UDP 协议之上，使用端口号 53 </li>
<li>主机解析域名的顺序 <ul>
<li>浏览器缓存 </li>
<li>找本机的 hosts 文件 </li>
<li>路由缓存 </li>
<li>找 DNS 服务器(本地域名、顶级域名、根域名) <ul>
<li>迭代查询、递归查询 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ul>
<li>超文本传输协议，<ul>
<li>请求报文由请求行，请求头，空行，消息体实现</li>
<li>响应报文由状态行，响应头，空行，消息体实现</li>
</ul>
</li>
<li>返回码<ul>
<li>1xx，指示信息-表示请求已接收，继续处理</li>
<li>2xx，成功-表示请求已被成功接收、理解、接受</li>
<li>3xx，重定向-要完成请求必须进行更进一步的操作</li>
<li>4xx，客户端错误-请求有语法错误或者请求无法实现</li>
<li>5xx，服务器错误=服务器未能实现合法的请求</li>
<li>200 OK，客户端请求成功</li>
<li>206 partial conten 服务器已经正确处理部分GET请求，实现断点续传或同时分片下载，该请求必须包含Range请求头来指示客户端期望得到的范围</li>
<li>300 multiple choice（可选重定向）被请求的资源有一系列可供选择的反馈信息，由浏览器/用户自行选择其中一个</li>
<li>301 moved permanently(永久重定向)，该资源已被永久移动到新位置，将来任何对该资源的访问都要使用本响应返回的若干个URI之一</li>
<li>302 move temporarily(临时重定向)；请求的资源现在临时从不同的URI中获得</li>
<li>304 not modified 如果客户端发送一个待条件的GET请求并且该请求已经被允许，而文档内容未改变，则返回304，响应不包含内容体</li>
<li>403 forbidden 服务器收到请求，但是拒绝提供服务</li>
</ul>
</li>
<li>GET VS POST<ul>
<li>GET请求，浏览器会将http header 和data一并发送出去，服务器响应200（返回数据）</li>
<li>POST请求，浏览器首先发送header，服务器响应100，浏览器再发送data，服务器响应200</li>
<li>get通过url传递，post放在request body中</li>
<li>get请求在url中传递的参数有长度限制，post没有</li>
<li>get比post更不安全，因为参数直接暴露在url中</li>
<li>get请求只能进行url编码，浏览器主动cache，post支持多种编码方式</li>
<li>get请求参数会完整保留在浏览历史记录中，post参数不会</li>
<li>GET/POST本质都基于TCP协议，GET产生一个TCP数据包，POST产生两个TCP数据包</li>
</ul>
</li>
<li>Cookie VS Session<ul>
<li>cookie 是一种发送到客户浏览器的文本串句柄，并保存在客户机硬盘上，可以用来在<br>某个 WEB 站点会话间持久的保持数据 </li>
<li>session 其实指的就是访问者从到达某个特定主页到离开为止的那段时间。 Session 其<br>实是利用 Cookie 进行信息处理的，当用户首先进行了请求后，服务端就在用户浏览器<br>上创建了一个 Cookie，当这个 Session 结束时，其实就是意味着这个 Cookie 就过期<br>了 </li>
<li>cookie 数据保存在客户端， session 数据保存在服务器端 </li>
</ul>
</li>
<li>一次完整的HTTP请求<ul>
<li>客户端浏览器通过DNS解析IP地址。</li>
<li>发起TCP的3次握手</li>
<li>建立TCP连接后发起http请求 </li>
<li>服务器响应http请求，浏览器得到html代码 </li>
<li>浏览器解析html代码，并请求html代码中的资源</li>
<li>浏览器对页面进行渲染呈现给用户</li>
</ul>
</li>
<li>HTTP VS HTTPS<ul>
<li>HTTP协议以明文方式在网络中传输数据，HTTPS协议传输的数据经TLS加密后传输</li>
<li>HTTPS在经过TCP三次握手后，还要进行SSL的handshake，协商加密使用的对称加密秘钥</li>
<li>HTTPS需要服务端申请证书，浏览器安装相应证书</li>
<li>HTTP端口80，HTTPS端口443</li>
<li>HTTPS传输过程中使用秘钥加密，安全</li>
<li>HTTPS认证用户和服务器，确保数据发送到正确的用户和服务器</li>
</ul>
</li>
<li>HTTP1.1 VS HTTP2.0<ul>
<li>HTTP2.0采用二进制格式而不是文本格式</li>
<li>HTTP2.0完全的多路复用，非有序阻塞，只要有一个连接就可以实现并行</li>
<li>使用报头压缩，HTTP2.0降低了开销</li>
<li>HTTP2.0让服务器可以将响应主动推送到客户端缓存中</li>
</ul>
</li>
</ul>
<h2 id="套接字socket"><a href="#套接字socket" class="headerlink" title="套接字socket"></a>套接字socket</h2><ul>
<li><h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1></li>
</ul>
<h2 id="hashtable-哈希表"><a href="#hashtable-哈希表" class="headerlink" title="hashtable 哈希表"></a>hashtable 哈希表</h2><ul>
<li><p>负载系数=元素个数/表格大小</p>
</li>
<li><p>避免地址冲突</p>
<ul>
<li>线性探测：如果hash函数计算某个元素的插入位置后，如果该位置的空间已经被占据，则继续向下寻找，直到找到一个可用空间为止，尝试H+1，H+2，H+3，H+4</li>
</ul>
</li>
<li><p>二次探测：如果计算的位置被占用，依次尝试H+1^2，H+2^2，H+3^2，H+4^2，</p>
<ul>
<li>设置表格大小为质数，永远保持负载系数在0.5以下（超过0.5重新配置并整理表格），确定没插入一个元素所需要的探测次数不多于2<ul>
<li>开链，维护buckets，bucket个数为质数，每个表格元素bucket维护一个list，在那个list中执行插入，删除，前提list够短，负载&gt;1，当元素个数大于bucket个数时，链表打散rehashing，bucket大小变为两倍大小左右的素数</li>
</ul>
</li>
<li>vector 维护buckets</li>
<li>通过hash函数%表长，获得bucket索引，之后再bucket所维护的链表中轮询，如果相等，直接插入前面，否则，新建节点添加到头部</li>
<li></li>
</ul>
</li>
</ul>
<h2 id="二叉树性质"><a href="#二叉树性质" class="headerlink" title="二叉树性质"></a>二叉树性质</h2><ul>
<li><p>​        性质1 ： 二叉树的第 i 层上至多有 2^(i-1) 个结点 (i&gt;=1)</p>
<p>​        性质2 ：  深度为 k 的二叉树至多有 2^k -1 个结点( k&gt;=1)</p>
<p>​        性质3 ：  对任意的一颗二叉树 T ，若叶子结点数为 n0,而其度数为 2 的结点数为 n2,则 n0 = n2+1</p>
<p>​        性质4 ：  具有 n 个结点的完全二叉树的深度 [log2n]+1</p>
<p>​        性质 5：  如果有一颗有n个节点的完全二叉树的节点按层次序编号，对任一层的节点i（1&lt;=i&lt;=n）有</p>
<p>​                        (1).如果i=1，则节点是二叉树的根，无双亲，如果i&gt;1，则其双亲节点为[i/2]，向下取整</p>
<p>​                        (2).如果2i&gt;n那么节点i没有左孩子，否则其左孩子为2i</p>
<p>​                        (3).如果2i+1&gt;n那么节点没有右孩子，否则右孩子为2i+1</p>
</li>
</ul>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><ul>
<li><p>二叉搜索树</p>
</li>
<li><p>AVL-TREE</p>
</li>
<li><p>RB-tree 是二叉搜索树</p>
<ul>
<li>每个节点不是黑色就是红色</li>
<li>根节点为黑色</li>
<li>若节点为红色，子节点一定为黑</li>
<li>任一节点到NULL（树尾端）的任何路径，所含黑节点个数必须相同</li>
</ul>
</li>
<li><p>AA-TREE</p>
</li>
</ul>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><ul>
<li>线程池实现<ul>
<li>领导者跟随者模式<ul>
<li>在LF线程池中，线程可处在3种线程状态之一：leader、follower或processor。处于leader状态的线程负责监听网络端口，当有消息到达时，该线程负责消息分离，并从处于 follower状态中的线程中按照某种机制如FIFO或基于优先级等选出一个来当新的leader，然后将自己设置为processor状态去分配和处理该事件。处理完毕后线程将自身的状态设置为follower状态去等待重新成为leader。在整个线程池中同一时刻只有一个线程可以处于leader状态，这保证了同一事件不会被多个线程重复处理</li>
<li>一个线程安全的queue维护一个任务队列，（类，有thread_handle函数）</li>
<li>创建N个线程，每个线程的处理函数都process_task函数，</li>
<li>在process_task中，提升一个领导者，然后从任务队列中pop一个，添加一个跟随者，执行线程处理函数</li>
</ul>
</li>
<li></li>
</ul>
</li>
</ul>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="singleton"><a href="#singleton" class="headerlink" title="singleton"></a>singleton</h2>
      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2019/08/30/cpp-review/">cpp-review</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">bliss7</a></p>
        <p><span>发布时间:</span>2019-08-30, 08:30:52</p>
        <p><span>最后更新:</span>2019-09-07, 13:02:28</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2019/08/30/cpp-review/" title="cpp-review">blissseven.top/2019/08/30/cpp-review/</a>
            <span class="copy-path" data-clipboard-text="原文: blissseven.top/2019/08/30/cpp-review/　　作者: bliss7" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2019/09/05/code-review/">
                    code-review
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2019/08/28/network-program/">
                    network-program
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C"><span class="toc-number">1.</span> <span class="toc-text">C++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#变量的声明和定义"><span class="toc-number">1.1.</span> <span class="toc-text">变量的声明和定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new的变种"><span class="toc-number">1.2.</span> <span class="toc-text">new的变种</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#特殊对象构建"><span class="toc-number">1.3.</span> <span class="toc-text">特殊对象构建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存分配方式"><span class="toc-number">1.4.</span> <span class="toc-text">内存分配方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static-const关键字"><span class="toc-number">1.5.</span> <span class="toc-text">static const关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#define-和const的区别"><span class="toc-number">1.6.</span> <span class="toc-text">define 和const的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#智能指针"><span class="toc-number">1.7.</span> <span class="toc-text">智能指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#移动语义"><span class="toc-number">1.8.</span> <span class="toc-text">移动语义</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#STL"><span class="toc-number">2.</span> <span class="toc-text">STL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#空间配置器"><span class="toc-number">2.1.</span> <span class="toc-text">空间配置器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#迭代器"><span class="toc-number">2.2.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vector实现"><span class="toc-number">2.3.</span> <span class="toc-text">vector实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#list实现"><span class="toc-number">2.4.</span> <span class="toc-text">list实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#deque实现"><span class="toc-number">2.5.</span> <span class="toc-text">deque实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#priority-queue"><span class="toc-number">2.6.</span> <span class="toc-text">priority_queue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set-map实现"><span class="toc-number">2.7.</span> <span class="toc-text">set-map实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unordered-set-map实现"><span class="toc-number">2.8.</span> <span class="toc-text">unordered-set/map实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法"><span class="toc-number">2.9.</span> <span class="toc-text">算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-11-多线程"><span class="toc-number">3.</span> <span class="toc-text">C++11 多线程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#操作系统"><span class="toc-number">4.</span> <span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#linux-IO模型"><span class="toc-number">4.1.</span> <span class="toc-text">linux IO模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#select-epoll"><span class="toc-number">4.2.</span> <span class="toc-text">select epoll</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程VS-线程VS-协程"><span class="toc-number">4.3.</span> <span class="toc-text">进程VS 线程VS 协程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#计算机网络"><span class="toc-number">5.</span> <span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-IP协议体系"><span class="toc-number">5.1.</span> <span class="toc-text">TCP/IP协议体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据链路层"><span class="toc-number">5.2.</span> <span class="toc-text">数据链路层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP"><span class="toc-number">5.3.</span> <span class="toc-text">IP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP"><span class="toc-number">5.4.</span> <span class="toc-text">UDP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP"><span class="toc-number">5.5.</span> <span class="toc-text">TCP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DNS"><span class="toc-number">5.6.</span> <span class="toc-text">DNS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP"><span class="toc-number">5.7.</span> <span class="toc-text">HTTP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#套接字socket"><span class="toc-number">5.8.</span> <span class="toc-text">套接字socket</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数据结构和算法"><span class="toc-number">6.</span> <span class="toc-text">数据结构和算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#hashtable-哈希表"><span class="toc-number">6.1.</span> <span class="toc-text">hashtable 哈希表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树性质"><span class="toc-number">6.2.</span> <span class="toc-text">二叉树性质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#平衡二叉树"><span class="toc-number">6.3.</span> <span class="toc-text">平衡二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#排序算法"><span class="toc-number">6.4.</span> <span class="toc-text">排序算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数据库"><span class="toc-number">7.</span> <span class="toc-text">数据库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#项目"><span class="toc-number">8.</span> <span class="toc-text">项目</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#设计模式"><span class="toc-number">9.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#singleton"><span class="toc-number">9.1.</span> <span class="toc-text">singleton</span></a></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"cpp-review　| bliss7's blog　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2019/09/05/code-review/" title="上一篇: code-review">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2019/08/28/network-program/" title="下一篇: network-program">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/09/05/code-review/">code-review</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/30/cpp-review/">cpp-review</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/28/network-program/">network-program</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/27/cpp11-singleton/">cpp11-singleton</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/22/object-model3/">object-model3</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/21/muduo-note/">muduo_note</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/14/OS/">OS</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/01/object-model2/">C++对象模型探索-2</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/30/cpp-trivial/">cpp_trivial</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/17/数据结构补全计划/">数据结构补全计划</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/13/object-model/">C++对象模型探索-1</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/13/hello-hexo-blog/">hello-hexo-blog</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/13/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/04/tcp-ip-note/">TCP/IP网络协议</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/17/concurrency-in-cpp11-2/">C++11 多线程编程2</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/03/concurrency-in-cpp11/">C++11 多线程编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/17/C-11-note/">C++ 11 新特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/10/design-pattern-note/">Design Pattern</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/08/STL-note/">STL_note</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2019 bliss7
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 7;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>